<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Mingshan&#39;s Blog</title>
  <subtitle>一念开明，反身而诚</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-09-18T02:40:51.885Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Mingshan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Class类文件结构简单分析</title>
    <link href="http://yoursite.com/2018/09/18/%E5%85%A8%E9%99%90%E5%AE%9A%E5%90%8D%E3%80%81%E7%AE%80%E5%8D%95%E5%90%8D%E7%A7%B0%E5%92%8C%E6%8F%8F%E8%BF%B0%E7%AC%A6%E6%98%AF%E4%BB%80%E4%B9%88%E4%B8%9C%E8%A5%BF%EF%BC%9F/"/>
    <id>http://yoursite.com/2018/09/18/全限定名、简单名称和描述符是什么东西？/</id>
    <published>2018-09-17T16:00:00.000Z</published>
    <updated>2018-09-18T02:40:51.885Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在看Class文件的结构时，我们会遇到这样几个概念，全限定名（Fully Qualified Name）、简单名称（Simple Name）和描述符（Descriptor），那么这些是什么东东呢？</p>
<a id="more"></a>
<p>首先来说全限定名，一个类的全限定名是将类全名的<code>.</code>全部替换为<code>/</code>，示例如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">me/mingshan/cglib/SampleClass</div></pre></td></tr></table></figure>
<p>简单名称是指没有类型和参数修饰的方法或字段名称，比如一个类的test()方法，它的简单名称是<code>test</code>。</p>
<p>那么描述符是什么呢？下面是JVM规范的定义：</p>
<blockquote>
<p>A descriptor is a string representing the type of a field or method. </p>
</blockquote>
<p>注意描述符的概念是针对Java字节码的。描述符的作用是用来描述字段的数据类型、方法的参数列表（包括数量、类型以及顺序）和返回值。在JVM规范中，定义了两种类型的描述符，Field Descriptors 和 Method Descriptors。</p>
<p><strong>Field Descriptors</strong></p>
<blockquote>
<p>A field descriptor represents the type of a class, instance, or local variable.</p>
</blockquote>
<p>字段描述符包含BaseType、ObjectType、ArrayType三部分，对于基本数据类型(byte、char、double、float、int、long、short、boolean)都用一个大写字母来表示，而对象用字符L加对象的全限定名和<code>；</code>来表示，具体表示如下：</p>
<table>
<thead>
<tr>
<th>FieldType term</th>
<th>Type</th>
<th>Interpretation </th>
</tr>
</thead>
<tbody>
<tr>
<td>B</td>
<td>byte</td>
<td>signed byte</td>
</tr>
<tr>
<td>C</td>
<td>char</td>
<td>Unicode character code point in the Basic Multilingual Plane, encoded with UTF-16</td>
</tr>
<tr>
<td>D</td>
<td>double</td>
<td>double-precision floating-point value</td>
</tr>
<tr>
<td>F</td>
<td>float</td>
<td>single-precision floating-point value</td>
</tr>
<tr>
<td>I</td>
<td>int</td>
<td>integer</td>
</tr>
<tr>
<td>J</td>
<td>long</td>
<td>long integer</td>
</tr>
<tr>
<td>L ClassName ;</td>
<td>reference</td>
<td>an instance of class ClassName</td>
</tr>
<tr>
<td>S</td>
<td>short</td>
<td>signed short</td>
</tr>
<tr>
<td>Z</td>
<td>boolean</td>
<td>true or false</td>
</tr>
<tr>
<td>[</td>
<td>reference</td>
<td>one array dimension</td>
</tr>
</tbody>
</table>
<p>对于数组类型，每一个维度使用一个前置的<code>[</code>来描述，如一个定义为java.lang.String[][]类型的二维数组，将被记录为<code>[[Ljava/lang/String;</code>，一个double型数组<code>double[][][]</code>将被记录为<code>[[[D</code>。</p>
<p><strong>Method Descriptors</strong></p>
<blockquote>
<p>A method descriptor contains zero or more parameter descriptors, representing the types of parameters that the method takes, and a return descriptor, representing the type of the value (if any) that the method returns.</p>
</blockquote>
<p>方法描述符用来描述方法，一个方法既有参数，又有返回值，那么在用描述符描述方法时，按照先参数列表，后返回值的顺序描述。参数列表按照参数的严格顺序放在一组小括号<code>()</code>内，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">( &#123;ParameterDescriptor&#125; ) ReturnDescriptor</div></pre></td></tr></table></figure>
<p>注意如果返回值为void，那么就是一个大写字母<code>V</code>表示。</p>
<p>例如，一个方法的定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Object m(int i, double d, Thread t) &#123;...&#125;</div></pre></td></tr></table></figure>
<p>那么它的描述符就是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(IDLjava/lang/Thread;)Ljava/lang/Object;</div></pre></td></tr></table></figure>
<p>又如方法的参数列表和返回值为空，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">void test()</div></pre></td></tr></table></figure>
<p>它的描述符为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">()V</div></pre></td></tr></table></figure>
<p><strong>最后上代码分析一波</strong></p>
<p>我们新建Test类，包含一个成员变量和方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> me.mingshan.cglib;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> a;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">inc</span><span class="params">(<span class="keyword">int</span> b)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> c = a + b;</div><div class="line">        <span class="keyword">return</span> c + <span class="string">"666"</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>利用<code>javap -c Test</code>来查看字节码，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">public class me.mingshan.cglib.Test &#123;</div><div class="line">  public me.mingshan.cglib.Test();</div><div class="line">    Code:</div><div class="line">       0: aload_0</div><div class="line">       1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</div><div class="line">       4: return</div><div class="line"></div><div class="line">  public java.lang.String inc(int);</div><div class="line">    Code:</div><div class="line">       0: aload_0</div><div class="line">       1: getfield      #2                  // Field a:I</div><div class="line">       4: iload_1</div><div class="line">       5: iadd</div><div class="line">       6: istore_2</div><div class="line">       7: iload_2</div><div class="line">       8: invokedynamic #3,  0              // InvokeDynamic #0:makeConcatWithConstants:(I)Ljava/lang/String;</div><div class="line">      13: areturn</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到<code>Field a:I</code>和<code>(I)Ljava/lang/String;</code>， 没什么错^_^</p>
<p><strong>参考：</strong></p>
<ul>
<li><a href="https://docs.oracle.com/javase/specs/jls/se10/html/jls-6.html#jls-6.7" target="_blank" rel="external">jls</a></li>
<li><a href="https://docs.oracle.com/javase/specs/jvms/se10/html/jvms-4.html#jvms-4.3" target="_blank" rel="external">JVM Descriptor</a></li>
<li>深入理解Java虚拟机：JVM高级特性与最佳实践（第2版）</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在看Class文件的结构时，我们会遇到这样几个概念，全限定名（Fully Qualified Name）、简单名称（Simple Name）和描述符（Descriptor），那么这些是什么东东呢？&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="jvm" scheme="http://yoursite.com/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>NIO之Channels</title>
    <link href="http://yoursite.com/2018/09/10/NIO~Channels/"/>
    <id>http://yoursite.com/2018/09/10/NIO~Channels/</id>
    <published>2018-09-09T16:00:00.000Z</published>
    <updated>2018-09-11T05:55:07.741Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Channel介绍"><a href="#Channel介绍" class="headerlink" title="Channel介绍"></a>Channel介绍</h2><p>Channel? 我们在使用Buffer的时候，需要往Buffer中放数据，再从Buffer中取数据，那么在NIO体系中，与Buffer交互是什么呢，没错，就是Channel。所有的NIO的I/O操作都是从Channel 开始的，读操作的时候将Channel中的数据填充到Buffer 中，而写操作时将Buffer中的数据写入到Channel中。</p>
<a id="more"></a>
<p>下面Channel的官方解释：</p>
<blockquote>
<p>A channel represents an open connection to an entity such as a hardware device, a file, a network socket, or a program component that is capable of performing one or more distinct I/O operations, for example reading or writing. As specified in the Channel interface, channels are either open or closed, and they are both asynchronously closeable and interruptible.</p>
</blockquote>
<p>在官方文档中，Channels根据不同的使用场景实现不一样，官方文档Channels可以在以下场景使用：</p>
<ul>
<li>File channels</li>
<li>Multiplexed, non-blocking I/O</li>
<li>Asynchronous I/O</li>
</ul>
<p>FileChannel类支持从连接到文件的通道中读取字节和将字节写入到通道。</p>
<p>多路复用、非阻塞I/O由<code>selector</code>、<code>selectable channels</code>和<code>SelectionKey</code>提供，它比阻塞I/O更具可伸缩性。</p>
<p>异步通道是一种能够进行异步I/O操作的特殊通道。异步通道是非阻塞的，并定义方法来启动异步操作，返回表示每个操作的Future。</p>
<p>目前使用较多Channel的实现类有：</p>
<ul>
<li>FileChannel：文件通道，用于文件的读和写</li>
<li>DatagramChannel：用于 UDP 连接的接收和发送</li>
<li>SocketChannel：TCP通道，用于TCP数据传输</li>
<li>ServerSocketChannel：用于监听服务端某个端口进来的TCP请求</li>
</ul>
<h2 id="FileChannel"><a href="#FileChannel" class="headerlink" title="FileChannel"></a>FileChannel</h2><p>Java针对支持通道的类提供了<code>getChannel()</code>方法来获取<code>FileChannel</code>，<code>FileChannel</code>是一个用来写、读、映射和操作文件的通道。下面是利用<code>FileChannel</code>读写文件的一个例子:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line">FileInputStream fis = <span class="keyword">null</span>;</div><div class="line">FileOutputStream fos = <span class="keyword">null</span>;</div><div class="line">FileChannel inChannel = <span class="keyword">null</span>;</div><div class="line">FileChannel outChannel = <span class="keyword">null</span>;</div><div class="line"></div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">    fis = <span class="keyword">new</span> FileInputStream(<span class="string">"1.png"</span>);</div><div class="line">    fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"2.png"</span>);</div><div class="line">    <span class="comment">// 获取通道</span></div><div class="line">    inChannel = fis.getChannel();</div><div class="line">    outChannel = fos.getChannel();</div><div class="line">    <span class="comment">// 创建缓冲区</span></div><div class="line">    ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</div><div class="line">    <span class="keyword">while</span> (inChannel.read(buffer) != -<span class="number">1</span>) &#123;</div><div class="line">        <span class="comment">// 切换到读数据模式</span></div><div class="line">        buffer.flip();</div><div class="line">        <span class="comment">// 将缓冲区的内容写入通道</span></div><div class="line">        outChannel.write(buffer);</div><div class="line">        <span class="comment">// 清空缓冲区</span></div><div class="line">        buffer.clear();</div><div class="line">    &#125;</div><div class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">    e.printStackTrace();</div><div class="line">&#125; <span class="keyword">finally</span> &#123;</div><div class="line">    <span class="keyword">if</span> (inChannel != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            inChannel.close();</div><div class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (outChannel != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            outChannel.close();</div><div class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (fis != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            fis.close();</div><div class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (fos != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            fos.close();</div><div class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>由于FileChannel是抽象类，它的read、write和map通过其实现类FileChannelImpl实现，注意<br><a href="https://github.com/unofficial-openjdk/openjdk/blob/531ef5d0ede6d733b00c9bc1b6b3c14a0b2b3e81/src/java.base/share/classes/sun/nio/ch/FileChannelImpl.java" target="_blank" rel="external">FileChannelImpl</a>是在sun.nio.ch包中的，这里类需要在openjdk源码中看到，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(ByteBuffer dst)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">    ensureOpen();</div><div class="line">    <span class="keyword">if</span> (!readable)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NonReadableChannelException();</div><div class="line">    <span class="keyword">synchronized</span> (positionLock) &#123;</div><div class="line">        <span class="keyword">if</span> (direct)</div><div class="line">            Util.checkChannelPositionAligned(position(), alignment);</div><div class="line">        <span class="keyword">int</span> n = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> ti = -<span class="number">1</span>;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            beginBlocking();</div><div class="line">            ti = threads.add();</div><div class="line">            <span class="keyword">if</span> (!isOpen())</div><div class="line">                <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">            <span class="keyword">do</span> &#123;</div><div class="line">                n = IOUtil.read(fd, dst, -<span class="number">1</span>, direct, alignment, nd);</div><div class="line">            &#125; <span class="keyword">while</span> ((n == IOStatus.INTERRUPTED) &amp;&amp; isOpen());</div><div class="line">            <span class="keyword">return</span> IOStatus.normalize(n);</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            threads.remove(ti);</div><div class="line">            endBlocking(n &gt; <span class="number">0</span>);</div><div class="line">            <span class="keyword">assert</span> IOStatus.check(n);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这个方法中，会检测通道是否可用，如果操作position和size，会进行同步处理，加上对象锁，然后调用<a href="https://github.com/unofficial-openjdk/openjdk/blob/531ef5d0ede6d733b00c9bc1b6b3c14a0b2b3e81/src/java.base/share/classes/sun/nio/ch/IOUtil.java" target="_blank" rel="external">IOUtil</a>类的read方法，注意是while循环，条件IOStatus是INTERRUPTED（系统底层调用中断？），在<a href="https://github.com/unofficial-openjdk/openjdk/blob/531ef5d0ede6d733b00c9bc1b6b3c14a0b2b3e81/src/java.base/share/classes/sun/nio/ch/IOStatus.java" target="_blank" rel="external">IOStatus</a>类中，定义了一些常量，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="meta">@Native</span> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EOF = -<span class="number">1</span>;              <span class="comment">// End of file</span></div><div class="line"><span class="meta">@Native</span> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNAVAILABLE = -<span class="number">2</span>;      <span class="comment">// Nothing available (non-blocking)</span></div><div class="line"><span class="meta">@Native</span> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INTERRUPTED = -<span class="number">3</span>;      <span class="comment">// System call interrupted</span></div><div class="line"><span class="meta">@Native</span> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNSUPPORTED = -<span class="number">4</span>;      <span class="comment">// Operation not supported</span></div><div class="line"><span class="meta">@Native</span> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THROWN = -<span class="number">5</span>;           <span class="comment">// Exception thrown in JNI code</span></div><div class="line"><span class="meta">@Native</span> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNSUPPORTED_CASE = -<span class="number">6</span>; <span class="comment">// This case not supported</span></div></pre></td></tr></table></figure>
<p>IOUtil的代码如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">static int read(FileDescriptor fd, ByteBuffer dst, long position,</div><div class="line">                    boolean directIO, int alignment, NativeDispatcher nd)</div><div class="line">        throws IOException</div><div class="line">    &#123;</div><div class="line">        if (dst.isReadOnly())</div><div class="line">            throw new IllegalArgumentException(&quot;Read-only buffer&quot;);</div><div class="line">        if (dst instanceof DirectBuffer)</div><div class="line">            return readIntoNativeBuffer(fd, dst, position, directIO, alignment, nd);</div><div class="line"></div><div class="line">        // Substitute a native buffer</div><div class="line">        ByteBuffer bb;</div><div class="line">        int rem = dst.remaining();</div><div class="line">        if (directIO) &#123;</div><div class="line">            Util.checkRemainingBufferSizeAligned(rem, alignment);</div><div class="line">            bb = Util.getTemporaryAlignedDirectBuffer(rem, alignment);</div><div class="line">        &#125; else &#123;</div><div class="line">            bb = Util.getTemporaryDirectBuffer(rem);</div><div class="line">        &#125;</div><div class="line">        try &#123;</div><div class="line">            int n = readIntoNativeBuffer(fd, bb, position, directIO, alignment,nd);</div><div class="line">            bb.flip();</div><div class="line">            if (n &gt; 0)</div><div class="line">                dst.put(bb);</div><div class="line">            return n;</div><div class="line">        &#125; finally &#123;</div><div class="line">            Util.offerFirstTemporaryDirectBuffer(bb);</div><div class="line">        &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过上面的代码可以大致了解到，FileChannel读取数据过程如下：</p>
<ol>
<li>判断用户传入的buffer是否是DirectBuffer，如果是直接由readIntoNativeBuffer进行读取</li>
<li>如果不是（directIO为false），申请一块和缓存同大小的DirectByteBuffer bb</li>
<li>读取数据到缓存bb，底层由NativeDispatcher的read实现</li>
<li>把bb的数据读取到dst（用户定义的ByteBuffer，在jvm中分配内存）</li>
</ol>
<p>其他方法的具体实现细节可参考openjdk的代码，就不再分析了。</p>
<h2 id="ServerSocketChannel和SocketChannel"><a href="#ServerSocketChannel和SocketChannel" class="headerlink" title="ServerSocketChannel和SocketChannel"></a>ServerSocketChannel和SocketChannel</h2><p>ServerSocketChannel可以监听新进来的TCP连接，主要用于处理网络连接。对每一个新进来的连接都会创建一个SocketChannel。ServerSocketChannel可以被设置为阻塞或者非阻塞，</p>
<p>如果设置为阻塞，那么通道的读写等操作是阻塞的，该线程被阻塞，直到有一些数据被读取或写入，该线程在此期间不能执行其他任务</p>
<p>如果设置为非阻塞，那么读写请求并不会阻塞当前线程，在数据可读/写前当前线程可以继续做其它事情，所以一个单独的线程可以管理多个输入和输出通道。需要结合Selector使用。</p>
<p>下面仅介绍阻塞式的写法，非阻塞在Selector中详细探讨下。代码如下：</p>
<p>Server端：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 创建通道</span></div><div class="line">ServerSocketChannel server = ServerSocketChannel.open();</div><div class="line"><span class="comment">// 绑定端口</span></div><div class="line">server.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">9898</span>));</div><div class="line">FileChannel outChannel = FileChannel.open(Paths.get(<span class="string">"2.png"</span>), StandardOpenOption.WRITE,StandardOpenOption.READ,StandardOpenOption.CREATE);</div><div class="line"></div><div class="line"><span class="comment">// 获取客户端连接的通道</span></div><div class="line">SocketChannel socketChannel = server.accept();</div><div class="line"><span class="comment">// 分配指定大小的缓冲区</span></div><div class="line">ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</div><div class="line"></div><div class="line"><span class="comment">// 接受客户端的数据，并保存到本地</span></div><div class="line"><span class="keyword">while</span>(socketChannel.read(buffer) != -<span class="number">1</span>)&#123;</div><div class="line">    buffer.flip();</div><div class="line">    outChannel.write(buffer);</div><div class="line">    buffer.clear();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 关闭通道</span></div><div class="line">socketChannel.close();</div><div class="line">outChannel.close();</div><div class="line">server.close();</div></pre></td></tr></table></figure>
<p>通过上面代码我们可以总结下Server端的流程：</p>
<ol>
<li>创建ServerSocketChannel通道</li>
<li>绑定ip地址和端口号</li>
<li>通过ServerSocketChannel的accept()方法创建一个SocketChannel对象，用户从客户端读/写数据</li>
<li>创建读数据/写数据缓冲区对象来读取客户端数据或向客户端发送数据</li>
<li>关闭SocketChannel和ServerSocketChannel</li>
</ol>
<p>Client端：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 获取通道</span></div><div class="line">SocketChannel client = SocketChannel.open(<span class="keyword">new</span> InetSocketAddress(<span class="string">"127.0.0.1"</span>, <span class="number">9898</span>));</div><div class="line"><span class="comment">// 获取文件</span></div><div class="line">FileChannel inChannel = FileChannel.open(Paths.get(<span class="string">"1.png"</span>), StandardOpenOption.READ);</div><div class="line">        </div><div class="line"><span class="comment">// 分配缓冲区</span></div><div class="line">ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</div><div class="line"></div><div class="line"><span class="comment">// 读取本地文件</span></div><div class="line"><span class="keyword">while</span> (inChannel.read(buffer) != -<span class="number">1</span>) &#123;</div><div class="line">    buffer.flip();</div><div class="line">    client.write(buffer);</div><div class="line">    buffer.clear();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 关闭</span></div><div class="line">inChannel.close();</div><div class="line">client.close();</div></pre></td></tr></table></figure>
<p>总结下Client端的流程：</p>
<ol>
<li>获取SocketChannel，绑定ip和端口</li>
<li>创建读数据/写数据缓冲区对象来读取服务端数据或向服务端发送数据</li>
<li>关闭SocketChannel</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://docs.oracle.com/javase/10/docs/api/java/nio/channels/package-summary.html" target="_blank" rel="external">JDK API</a></li>
<li><a href="https://segmentfault.com/a/1190000014869494" target="_blank" rel="external">Java NIO 之 Channel（通道）</a></li>
<li><a href="https://www.jianshu.com/p/052035037297" target="_blank" rel="external">深入浅出NIO之Channel、Buffer</a></li>
<li><a href="http://www.jasongj.com/java/nio_reactor/" target="_blank" rel="external">Java进阶（五）Java I/O模型从BIO到NIO和Reactor模式 </a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Channel介绍&quot;&gt;&lt;a href=&quot;#Channel介绍&quot; class=&quot;headerlink&quot; title=&quot;Channel介绍&quot;&gt;&lt;/a&gt;Channel介绍&lt;/h2&gt;&lt;p&gt;Channel? 我们在使用Buffer的时候，需要往Buffer中放数据，再从Buffer中取数据，那么在NIO体系中，与Buffer交互是什么呢，没错，就是Channel。所有的NIO的I/O操作都是从Channel 开始的，读操作的时候将Channel中的数据填充到Buffer 中，而写操作时将Buffer中的数据写入到Channel中。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="NIO" scheme="http://yoursite.com/tags/NIO/"/>
    
  </entry>
  
  <entry>
    <title>Class类文件结构简单分析</title>
    <link href="http://yoursite.com/2018/09/08/Class%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2018/09/08/Class类文件结构简单分析/</id>
    <published>2018-09-07T16:00:00.000Z</published>
    <updated>2018-09-08T13:58:45.855Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>代码编译的结果从本地机器码转变为字节码，是存储格式发展的一小步，却是编程语言的一大步。</p>
</blockquote>
<p>在Java平台中，实现语言无关性基础是虚拟机和存储格式。Java虚拟机不和Java等运行在其上的语言绑定，它只是与Class文件这种特殊的字节码文件所关联，每一个类文件包含单个类、接口或模块的定义。</p>
<a id="more"></a>
<h2 id="ClassFile的structure"><a href="#ClassFile的structure" class="headerlink" title="ClassFile的structure"></a>ClassFile的structure</h2><p>Class文件由一组8位字节为基础的二进制流。在最新的Java虚拟机规范中，Class文件由叫做ClassFile的structure组成。class文件结构在JVM占有重要地位，具体位于第四章，标题是“The class File Format”，总共五百多页的虚拟机规范，类文件结构就写了三百多页，是不是很可怕^_^</p>
<p>那么这个东西长什么样呢？如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">ClassFile &#123;</div><div class="line">    u4 magic;</div><div class="line">    u2 minor_version;</div><div class="line">    u2 major_version;</div><div class="line">    u2 constant_pool_count;</div><div class="line">    cp_info constant_pool[constant_pool_count-1];</div><div class="line">    u2 access_flags;</div><div class="line">    u2 this_class;</div><div class="line">    u2 super_class;</div><div class="line">    u2 interfaces_count;</div><div class="line">    u2 interfaces[interfaces_count];</div><div class="line">    u2 fields_count;</div><div class="line">    field_info fields[fields_count];</div><div class="line">    u2 methods_count;</div><div class="line">    method_info methods[methods_count];</div><div class="line">    u2 attributes_count;</div><div class="line">    attribute_info attributes[attributes_count];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>咦？怎么这么像C语言的结构体呢，说的没错，虚拟机规范这是这么描述的(pseudostructures 伪结构)，刚才说了，它的真实结构是一组以8位字节为基础单位的二进制流，包含多个数据项，各个数据项严格按照顺序紧凑的排列在Class文件中（后面再进行分析）。下面我们来看看这个伪结构包含了什么。</p>
<p>从上面的伪结构来看，u2、u4是什么鬼？后面的看着像是属性，那么u2、u4似乎是类型的样子，呃，，没错，这种东西被称为数据类型，而且在<strong>伪结构中只有两种数据类型，无符号数（unsigned quantity）和表（table）</strong>。</p>
<p>无符号数属于基本的数据类型，u2、u4分别代表2个字节、4个字节的无符号数。无符号数可以用来描述数字、索引引用、数量值或者按照UTF-8编码的字符串。</p>
<p>那么<code>cp_info</code>、<code>field_info</code>、<code>method_info</code>和<code>attribute_info</code>就是所谓的table了，可以看出都是以<code>_info</code>结尾，这些存些什么数据呢？在一个类中，总有字段吧，那么就存到<code>field_info</code>里面，总有些方法吧，存到<code>method_info</code>，或许还会有常量什么的，存到<code>cp_info</code>里面，在Class文件、字段表、方法表都可以携带自己的attribute_info，用于描述某些场景专有的信息。</p>
<p>说完了伪结构的数据类型，uX和*_info后面那些类似字段名称的东西是什么意思呢？在虚拟机规范中，被称作<code>item</code>，原话这么说的：</p>
<blockquote>
<p> the contents of the structures describing the class file format are<br>referred to as items</p>
</blockquote>
<p>好吧，不知道叫啥，就叫item吧，大家知道就行了(￣.￣)。</p>
<p>在介绍上面的<code>items</code>之前，我们先来一个简单的Java类编译后的Class的十六进制文件，源代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">inc</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> i + <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>用<code>javac</code>编译后，我选择Hexpad这个编辑器来打开class文件，如下：</p>
<p><img src="https://github.com/ZZULI-TECH/interview/blob/master/images/class_16.png?raw=true" alt="image"></p>
<h2 id="magic与class文件的版本"><a href="#magic与class文件的版本" class="headerlink" title="magic与class文件的版本"></a>magic与class文件的版本</h2><p><strong>magic</strong></p>
<p>每个Class文件的头四个字节被称为魔数（Magic Number），默认值为<code>0xCAFEBABE</code>，用于确定一个文件是否能被JVM接受。</p>
<p><strong>minor_version, major_version</strong></p>
<p>紧接着四个字节就是<code>minor_version</code>和<code>major_version</code>，看着像是版本号的意思，没错，这四个字节存储的是Class文件的版本号，第5和6个字节存储的是次版本号（Minor Version），第7个和8个字节存储的是主版本号（Major Version）。由上面的图片可知，<code>minor_version</code>为0x0000，<code>major_version</code>为0x0036，转为是十进制为54，即我用JDK10编译的。下面为各个版本JVM能接受Class文件版本号的范围：</p>
<table>
<thead>
<tr>
<th>Java SE</th>
<th>class file format version range</th>
</tr>
</thead>
<tbody>
<tr>
<td>1.0.2</td>
<td>45.0 ≤ v ≤ 45.3</td>
</tr>
<tr>
<td>1.1</td>
<td>45.0 ≤ v ≤ 45.65535</td>
</tr>
<tr>
<td>1.2</td>
<td>45.0 ≤ v ≤ 46.0</td>
</tr>
<tr>
<td>1.3</td>
<td>45.0 ≤ v ≤ 47.0</td>
</tr>
<tr>
<td>1.4</td>
<td>45.0 ≤ v ≤ 48.0</td>
</tr>
<tr>
<td>5.0</td>
<td>45.0 ≤ v ≤ 49.0</td>
</tr>
<tr>
<td>6</td>
<td>45.0 ≤ v ≤ 50.0</td>
</tr>
<tr>
<td>7</td>
<td>45.0 ≤ v ≤ 51.0</td>
</tr>
<tr>
<td>8</td>
<td>45.0 ≤ v ≤ 52.0</td>
</tr>
<tr>
<td>9</td>
<td>45.0 ≤ v ≤ 53.0</td>
</tr>
<tr>
<td>10</td>
<td>45.0 ≤ v ≤ 54.0</td>
</tr>
</tbody>
</table>
<h2 id="constant-pool-count，constant-pool"><a href="#constant-pool-count，constant-pool" class="headerlink" title="constant_pool_count，constant_pool[]"></a>constant_pool_count，constant_pool[]</h2><p><strong>constant_pool_count</strong></p>
<p>接着主版本号之后是常量池容量计数值（constant_pool_count），由于常量池中常量的数量是不固定的，所以需要一个u2类型的数据来统计。注意该值计数从1开始而不是0。如上图所示，constant_pool_count值为0x0013，转为十进制为19，这就代表常量池中有18项常量，索引值范围为1~18（1 ~ constant_pool_count - 1）。</p>
<p>可能此时会有疑问，为啥我一个常量没定义，常量池这么多常量呢？有这个疑问就对了，原因是常量池中不仅存放<code>static final</code>修饰的字段，这个被称作字面量（Literal），还包括符号引用（Symbolic References），在虚拟机规范中是这样写的：</p>
<blockquote>
<p>constants, class and interface names, field names, and other constants that are<br>referred to within the ClassFile structure and its substructures. </p>
</blockquote>
<p>符号引用具体包括哪些呢？如下：</p>
<ul>
<li>类和接口的全限定名</li>
<li>字段的名称和描述符</li>
<li>方法的名称和描述符</li>
</ul>
<h2 id="access-flags"><a href="#access-flags" class="headerlink" title="access_flags"></a>access_flags</h2><p>在常量池结束之后，紧接着2个字节表示访问标志（access_flags），这个标志用于识别一些类和接口层次的访问信息。具体列表如下：</p>
<table>
<thead>
<tr>
<th>Flag Name</th>
<th>Value</th>
<th>Interpretation</th>
</tr>
</thead>
<tbody>
<tr>
<td>ACC_PUBLIC</td>
<td>0x0001</td>
<td>Declared public; may be accessed from outside its package.</td>
</tr>
<tr>
<td>ACC_FINAL</td>
<td>0x0010</td>
<td>Declared final; no subclasses allowed.</td>
</tr>
<tr>
<td>ACC_SUPER</td>
<td>0x0020</td>
<td>Treat superclass methods specially when invoked by the invokespecial instruction.</td>
</tr>
<tr>
<td>ACC_INTERFACE</td>
<td>0x0200</td>
<td>Is an interface, not a class.</td>
</tr>
<tr>
<td>ACC_ABSTRACT</td>
<td>0x0400</td>
<td>Declared abstract; must not be instantiated.</td>
</tr>
<tr>
<td>ACC_SYNTHETIC</td>
<td>0x1000</td>
<td>Declared synthetic; not present in the source code.</td>
</tr>
<tr>
<td>ACC_ANNOTATION</td>
<td>0x2000</td>
<td>Declared as an annotation type.</td>
</tr>
<tr>
<td>ACC_ENUM</td>
<td>0x4000</td>
<td>Declared as an enum type.</td>
</tr>
<tr>
<td>ACC_MODULE</td>
<td>0x8000</td>
<td>Is a module, not a class or interface.</td>
</tr>
</tbody>
</table>
<p><strong>ACC_MODULE</strong></p>
<p>需要注意ACC_MODULE，这个是新增的，ACC_MODULE标志表示这个Class文件定义了一个模块，而不是一个类或接口。</p>
<p><strong>ACC_SUPER</strong></p>
<p>在jdk1.02之前，有个叫invokenonvirtual的指令。在1.02后，这个指令被改名叫做invokespecial。invokenonvirtual的时候没有invokespecial那样只允许调用superclass、private方法或<init>方法。于是在所有的1.02后的class 都必须设置ACC_SUPER这个标志，来表明强加给invokespecial的新的约束必须要被遵守。</init></p>
<h2 id="this-class-super-class-interfaces-count-interfaces"><a href="#this-class-super-class-interfaces-count-interfaces" class="headerlink" title="this_class, super_class, interfaces_count, interfaces[]"></a>this_class, super_class, interfaces_count, interfaces[]</h2><p>this_class（类索引）、super_class（父类索引）都是一个u2类型的数据，而interfaces（接口索引集合）是一组u2类型的数据集合。Class文件由这三项来确定这个类的继承关系。</p>
<p><strong>this_class（类索引）和 super_class（父类索引）</strong></p>
<p>类索引和父类索引表示，它们各自指向一个类型为CONSTANT_Class_info的类描述符常量，通过CONSTANT_Class_info类型的常量中的索引值可以找到定义在CONSTANT_Utf8_info类型的常量的全限定名字符串。大致如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">this_class  -&gt;  CONSTANT_Class_info  -&gt; CONSTANT_Utf8_info</div></pre></td></tr></table></figure>
<p><strong>interfaces_count（接口计数器）</strong></p>
<p>这个项的值表示当前类或接口的直接超接口的数量。</p>
<p><strong>interfaces[] （接口表）</strong></p>
<p>就是这个类所实现的接口。里边同样是常量池的索引值。接口表里边的顺序和源代码的接口顺序是一致的。</p>
<h2 id="fields-count，fields"><a href="#fields-count，fields" class="headerlink" title="fields_count，fields[]"></a>fields_count，fields[]</h2><p>field_info（字段表）用于描述接口或者类中声明的变量。fields表中只包含当前类或接口中的字段，不包含超类或super 接口中的字段，也不包括在方法内部声明的局部变量。</p>
<h2 id="methods-count，methods"><a href="#methods-count，methods" class="headerlink" title="methods_count，methods[]"></a>methods_count，methods[]</h2><p>method_info用来表示当前类或接口中的某个方法的完整描述。</p>
<h2 id="attributes-count-attributes"><a href="#attributes-count-attributes" class="headerlink" title="attributes_count, attributes[]"></a>attributes_count, attributes[]</h2><p>在Class文件、字段表、方法表都可以携带自己的attribute_info，用于描述某些场景专有的信息。</p>
<p>参考：</p>
<ul>
<li><a href="https://docs.oracle.com/javase/specs/jvms/se10/jvms10.pdf" target="_blank" rel="external">The Java® Virtual Machine Specification (Java SE 10 Edition)</a></li>
<li>深入理解Java虚拟机：JVM高级特性与最佳实践（第2版）</li>
<li><a href="https://mp.weixin.qq.com/s/e3_5okrgFTctBTikRuJvhA" target="_blank" rel="external">来自JVM的一封ClassFile介绍信</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;代码编译的结果从本地机器码转变为字节码，是存储格式发展的一小步，却是编程语言的一大步。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在Java平台中，实现语言无关性基础是虚拟机和存储格式。Java虚拟机不和Java等运行在其上的语言绑定，它只是与Class文件这种特殊的字节码文件所关联，每一个类文件包含单个类、接口或模块的定义。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>NIO之Buffers</title>
    <link href="http://yoursite.com/2018/08/29/NIO~Buffers/"/>
    <id>http://yoursite.com/2018/08/29/NIO~Buffers/</id>
    <published>2018-08-28T16:00:00.000Z</published>
    <updated>2018-08-29T14:29:27.880Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Buffer？我们很容易想到缓冲区的概念，在NIO中，它是直接和Channel打交道的缓冲区，通常场景或是从Buffer写入Channel，或是从Channel读入Buffer。Buffer是一个抽象类，Java提供如下图的实现类，我是直接在Eclipse截出来的^_^</p>
<a id="more"></a>
<p><img src="https://github.com/ZZULI-TECH/interview/blob/master/images/buffer_impl.png?raw=true" alt="image"></p>
<p>其实核心是ByteBuffer，除了布尔类型，所有原始类型都有相应的Buffer实现，只是包装了一下ByteBuffer而已，我们使用最多的通常是ByteBuffer。</p>
<p>我们应该将Buffer理解为一个数组，IntBuffer、CharBuffer、DoubleBuffer 等分别对应int[]、char[]、double[]等。</p>
<p>上图没有包括MappedByteBuffer，该类用户内存映射文件，放到最后再说吧。</p>
<p>Buffer有四个重要的属性，分别为：mark、position、limit、capacity，和两个重要方法分别为：flip和clear。Buffer的底层存储结构为数组。这四个属性有以下特点：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mark &lt;= position &lt;= limit &lt;= capacity</div></pre></td></tr></table></figure>
<p>那么这几个属性分别起着什么作用呢？下面的介绍都以ByteBuffer为例，来分析ByteBuffer的使用流程和原理。</p>
<p>下面是这四个属性的简单介绍：</p>
<ul>
<li>capacity ：缓冲区的容量大小</li>
<li>limit ：界限，表示缓冲区可以操作数据的大小。 （limit后数据不能进行读写）</li>
<li>position: 位置，代表下一次的写入位置，初始值是 0，每往 Buffer 中写入一个值，position 就自动加 1</li>
<li>mark : 标记，表示记录当前position 的位置可以通过reset()来恢复到 mark的位置，初始为 -1</li>
</ul>
<p>对ByteBuffer操作主要包括读和写，向缓冲区写入数据和从缓冲区读取数据会影响以上四个属性的值的变化，我们分别对读和写以及之间切换进行分析。</p>
<p><strong>写操作</strong></p>
<p>首先分配1024字节的缓冲区，然后向缓冲区放入5字节的字符串“abcde”，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">String str=&quot;abcde&quot;;</div><div class="line"></div><div class="line">// 分配一个指定大小的缓冲区</div><div class="line">ByteBuffer buffer=ByteBuffer.allocate(1024);</div><div class="line"></div><div class="line">System.out.println(&quot;---------allocate------&quot;);</div><div class="line">System.out.println(buffer.position());</div><div class="line">System.out.println(buffer.limit());</div><div class="line">System.out.println(buffer.capacity());</div><div class="line"></div><div class="line">// 利用put() 向缓冲区放数据</div><div class="line">buffer.put(str.getBytes());</div><div class="line"></div><div class="line">System.out.println(&quot;--------放数据------&quot;);</div><div class="line">System.out.println(buffer.position());</div><div class="line">System.out.println(buffer.limit());</div><div class="line">System.out.println(buffer.capacity());</div></pre></td></tr></table></figure>
<p>初始化position，limit，capacity位置如下图所示</p>
<p><img src="https://github.com/ZZULI-TECH/interview/blob/master/images/bytebuffer_init.png?raw=true" alt="image"></p>
<p>我们发现position为0，而limit和capacity均指向内存区域最大位置，代表此时缓存区内是空的，已放入capacity大小的数据。</p>
<p>当我们向缓冲区放入5个字节的数据，position，limit，capacity位置发生了变化，如下图所示</p>
<p><img src="https://github.com/ZZULI-TECH/interview/blob/master/images/bytebuffer_put.png?raw=true" alt="image"></p>
<p>从上图可以看出，在写入数据后，position会向后移动5个位置，指向第六个位置，代表下次写数据的位置，limit和capacity没有改变。</p>
<p><strong>切换到读操作</strong></p>
<p>由写模式切换到读模式需要调用<code>flip</code>方法，这个方法是什么意思呢？在JDK源码中，此方法的代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">flip</span><span class="params">()</span> </span>&#123;</div><div class="line">    limit = position;</div><div class="line">    position = <span class="number">0</span>;</div><div class="line">    mark = -<span class="number">1</span>;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从代码中我们可以清晰的看出，limit被设置为当前position的大小，position归0，mark还是为默认值-1，我们还是看图比较直观，如下图所示：</p>
<p><img src="https://github.com/ZZULI-TECH/interview/blob/master/images/bytebuffer_flip.png?raw=true" alt="image"></p>
<p>和上一张图片进行对比，我们可以发现limit替换了position的位置，代表当前可以操作的位置，在写的时候，limit的值代表最大的可写位置，在读的时候，limit的值代表最大的可读位置。很明显我们现在是要读数据，就代表最大可读位置。</p>
<p><strong>读操作</strong></p>
<p>通过filp方法切换为读模式后，我们就可以从缓存区里面读取数据，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 从缓冲区读数据</span></div><div class="line"><span class="keyword">byte</span>[] dst=<span class="keyword">new</span> <span class="keyword">byte</span>[buffer.limit()];</div><div class="line">buffer.get(dst);</div><div class="line">System.out.println(<span class="string">"------读取数据-------"</span>);</div><div class="line">System.out.println(<span class="keyword">new</span> String(dst,<span class="number">0</span>,dst.length));</div><div class="line"></div><div class="line">System.out.println(buffer.position());</div><div class="line">System.out.println(buffer.limit());</div><div class="line">System.out.println(buffer.capacity());</div></pre></td></tr></table></figure>
<p>此时position，limit，capacity位置如下图所示</p>
<p><img src="https://github.com/ZZULI-TECH/interview/blob/master/images/bytebuffer_read.png?raw=true" alt="image"></p>
<p>从上图可以看出，position的位置变成了5，由于我们将缓存区里面的数据读完了，就是这个情况，所以读操作的时候，每读一个值，position 就自动加 1。在HeapByteBuffer源码中，就是增加一个offset的偏移量。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">ix</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> i + offset;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>重复读数据</strong></p>
<p>上一步读数据的操作已经将position移动了limit的位置，我们想读数据就读不到了，但能不能重复读取数据呢？肯定可以呀，这时我们就可以用<code>rewind</code>方法来重复读写，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//rewind  可重复读数据</span></div><div class="line">buffer.rewind();</div><div class="line">System.out.println(<span class="string">"------重复读取数据-------"</span>);</div><div class="line">System.out.println(buffer.position());</div><div class="line">System.out.println(buffer.limit());</div><div class="line">System.out.println(buffer.capacity());</div></pre></td></tr></table></figure>
<p>此时position，limit，capacity位置如下图所示</p>
<p><img src="https://github.com/ZZULI-TECH/interview/blob/master/images/bytebuffer_rewind.png?raw=true" alt="image"></p>
<p>有没有发现和flip操作后一致，此时肯定要一样了，这样我们才可以重复读取。</p>
<p><strong>清空缓冲区</strong></p>
<p>此时我们不想要缓冲区的数据了，需要清空掉，可以用<code>clear</code>方法来操作，代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 清空缓冲区，缓冲区的数据仍然存在，但处于被遗忘的状态，不能被读取</span></div><div class="line">buffer.clear();</div><div class="line">System.out.println(<span class="string">"------清空缓冲区-------"</span>);</div><div class="line">System.out.println(buffer.position());</div><div class="line">System.out.println(buffer.limit());</div><div class="line">System.out.println(buffer.capacity());</div></pre></td></tr></table></figure>
<p>此时position，limit，capacity位置如下图所示</p>
<p><img src="https://github.com/ZZULI-TECH/interview/blob/master/images/bytebuffer_clear.png?raw=true" alt="image"></p>
<p>注意缓冲区的数据仍然存在，但处于被遗忘的状态，不能被读取</p>
<p><strong>mark() &amp; reset()</strong></p>
<p>除了 position、limit、capacity 这三个基本的属性外，还有一个常用的属性就是 mark。</p>
<p>mark 用于临时保存 position 的值，每次调用 mark() 方法都会将 mark 设值为当前的 position，便于后续需要的时候使用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">mark</span><span class="params">()</span> </span>&#123;</div><div class="line">    mark = position;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>那到底什么时候用呢？考虑以下场景，我们在 position 为 5 的时候，先 mark() 一下，然后继续往下读，读到第 10 的时候，我想重新回到 position 为 5 的地方重新来一遍，那只要调一下 reset() 方法，position 就回到 5 了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">reset</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> m = mark;</div><div class="line">    <span class="keyword">if</span> (m &lt; <span class="number">0</span>)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InvalidMarkException();</div><div class="line">    position = m;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>rewind() &amp; clear() &amp; compact()</strong></p>
<p>rewind()：会重置 position 为 0，通常用于重新从头读写 Buffer。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">rewind</span><span class="params">()</span> </span>&#123;</div><div class="line">    position = <span class="number">0</span>;</div><div class="line">    mark = -<span class="number">1</span>;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>clear()：有点重置 Buffer 的意思，相当于重新实例化了一样。</p>
<p>通常，我们会先填充 Buffer，然后从 Buffer 读取数据，之后我们再重新往里填充新的数据，我们一般在重新填充之前先调用 clear()。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">clear</span><span class="params">()</span> </span>&#123;</div><div class="line">    position = <span class="number">0</span>;</div><div class="line">    limit = capacity;</div><div class="line">    mark = -<span class="number">1</span>;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>compact()：和 clear() 一样的是，它们都是在准备往 Buffer 填充新的数据之前调用。</p>
<p>前面说的 clear() 方法会重置几个属性，但是我们要看到，clear() 方法并不会将 Buffer 中的数据清空，只不过后续的写入会覆盖掉原来的数据，也就相当于清空了数据了。</p>
<p>而 compact() 方法有点不一样，调用这个方法以后，会先处理还没有读取的数据，也就是 position 到 limit 之间的数据（还没有读过的数据），先将这些数据移到左边，然后在这个基础上再开始写入。很明显，此时 limit 还是等于 capacity，position 指向原来数据的右边。</p>
<p><strong>参考：</strong></p>
<ul>
<li><a href="http://www.importnew.com/28007.html" target="_blank" rel="external">Java NIO：Buffer、Channel 和 Selector</a></li>
<li><a href="https://docs.oracle.com/javase/10/docs/api/java/nio/package-summary.html" target="_blank" rel="external">NIO API</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Buffer？我们很容易想到缓冲区的概念，在NIO中，它是直接和Channel打交道的缓冲区，通常场景或是从Buffer写入Channel，或是从Channel读入Buffer。Buffer是一个抽象类，Java提供如下图的实现类，我是直接在Eclipse截出来的^_^&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="NIO" scheme="http://yoursite.com/tags/NIO/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot应用被系统Kill相关问题分析</title>
    <link href="http://yoursite.com/2018/08/25/SpringBoot%E5%BA%94%E7%94%A8%E8%A2%AB%E7%B3%BB%E7%BB%9FKill%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2018/08/25/SpringBoot应用被系统Kill相关问题分析/</id>
    <published>2018-08-24T16:00:00.000Z</published>
    <updated>2018-09-01T04:31:44.244Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>SpringBoot在启动的时候，有默认的JVM启动参数，在部署到Linux服务器上时，如果Linxus内存不够时，会导致应用被操作系统kill掉，导致部署的服务莫名其妙的挂掉，就我遇到的项目而言，记录SpringBoot的log如下：</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">2018-08-23 07:53:25.231  INFO [demo,,,,] 1 --- [           main] cn.com.superv.provider.Application       : Started Application in 5.655 seconds (JVM running for 6.124)</div><div class="line">2018-08-23 07:55:02.080  INFO [demo,,,,] 1 --- [       Thread-3] ConfigServletWebServerApplicationContext : Closing org.springframework.boot.web.servlet.context.AnnotationConfigServletWebServerApplicationContext@19dfb72a: startup date [Thu Aug 23 07:53:20 GMT 2018]; root of context hierarchy</div><div class="line">2018-08-23 07:55:02.087  INFO [demo,,,,] 1 --- [       Thread-3] o.s.c.support.DefaultLifecycleProcessor  : Stopping beans in phase 2147483647</div><div class="line">2018-08-23 07:55:02.087  INFO [demo,,,,] 1 --- [       Thread-3] o.s.j.e.a.AnnotationMBeanExporter        : Unregistering JMX-exposed beans on shutdown</div><div class="line">2018-08-23 07:55:02.088  INFO [demo,,,,] 1 --- [       Thread-3] o.s.j.e.a.AnnotationMBeanExporter        : Unregistering JMX-exposed beans</div><div class="line">2018-08-23 07:55:02.099  INFO [demo,,,,] 1 --- [       Thread-3] com.alibaba.druid.pool.DruidDataSource   : &#123;dataSource-1&#125; closed</div></pre></td></tr></table></figure>
<p>才开始我以为代码写错了，导致应用启动崩溃，但我这个应用在另一台Linux机器上跑的挺好的，没有出现上面的问题。其中log中有以下日志：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Unregistering JMX-exposed beans on shutdown</div><div class="line">Unregistering JMX-exposed beans</div></pre></td></tr></table></figure>
<p>在网上查的信息说SpringBoot内嵌的Tomcat无法正常启动才导致这个错误，结合这个项目在其他机器上能运行，就排除了Tomcat的问题。后来我想想会不会是跟Linux内存有关系呢？我赶紧用<code>top</code>命令查看了服务器的内存的使用情况，我檫，16G的内存只剩下三百多兆了，看来是我项目运行的时候请求内存导致系统内存不足，被系统kill掉。这时可以用<code>jinfo -flags &lt;pid&gt;</code>命令来查看当前应用的JVM参数。运行 <code>dmesg | grep &quot;(java)&quot;</code>命令看看是不是操作系统把我的应用给干掉了，结果屏幕输入类似如下日志：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Out of memory: Kill process[PID] [process name] score</div></pre></td></tr></table></figure>
<p>这又是什么意思呢？好像是内存溢出被操作系统干掉了，所以一查，还真是Out of memory 问题，这通常是因为某时刻应用程序大量请求内存导致系统内存不足造成的，这通常会触发 Linux 内核里的 Out of Memory (OOM) killer，OOM killer会杀掉某个进程以腾出内存留给系统用，不致于让系统立刻崩溃。详细原因分析参考：<a href="http://www.111cn.net/sys/CentOS/84755.htm" target="_blank" rel="external">linux 终端报错 Out of memory: Kill process[PID] [process name] score问题分析</a></p>
<p>我在网上发现一哥们和我遇到了一样的问题，链接：<a href="https://blog.csdn.net/qq_35981283/article/details/62233725" target="_blank" rel="external">项目连续几天突然挂掉</a>，不过他的比较严重，可能刚开始没有整明白这个问题发生的原因，内心慌乱，其实仔细分析就可以查到问题发生的蛛丝马迹，从而解决问题。</p>
<p>找到问题发生的原因，接下来就要思考如何解决了。既然是内存的问题，那我们来改变下JVM参数，将最大堆内存(<code>-Xmx</code>)调小点，并禁止伸缩，将<code>-Xms</code>和<code>-Xmx</code>设置一样大，项目就可以运行了，<code>-Xmx</code>和<code>-Xms</code>具体值根据服务器内存和项目运行占用内存进行优化设置。</p>
<p>另外这个问题我在用Docker启动SpringBoot应用中也遇到过，利用<code>docker ps</code>命令可以发现该容器正在运行，但外界就是无法通过开放的端口来访问，利用命令<code>docker logs -f container-id</code>来查看容器启动的log，发现日志和上述的一样，所以也需要设置JVM参数, 命令如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker run -e JAVA_OPTS=&apos;-Xmx512m&apos; -p 8080:8080 -t springboot/spring-boot-docker</div></pre></td></tr></table></figure>
<p>最后推荐一个JVM调优相关的网站： <a href="http://xxfox.perfma.com/" target="_blank" rel="external">一只懂JVM参数的狐狸</a>，非常好用，可以查看JVM参数介绍以及变迁，还可以根据机器生成推荐JVM参数，真好用啊^_^</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;SpringBoot在启动的时候，有默认的JVM启动参数，在部署到Linux服务器上时，如果Linxus内存不够时，会导致应用被操作系统kill掉，导致部署的服务莫名其妙的挂掉，就我遇到的项目而言，记录SpringBoot的log如下：&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="SpringBoot" scheme="http://yoursite.com/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>Docker容器传递Spring Profile</title>
    <link href="http://yoursite.com/2018/08/22/Docker%E5%AE%B9%E5%99%A8%E5%90%AF%E7%94%A8Spring%20Profiles/"/>
    <id>http://yoursite.com/2018/08/22/Docker容器启用Spring Profiles/</id>
    <published>2018-08-21T16:00:00.000Z</published>
    <updated>2018-08-22T14:41:07.837Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>我们在利用Docker启动SpringBoot应用时，需要在启动时指定Profile来确定运行环境，如果再需要指定其他参数，参数的传递就十分有必要了。下面是stackoverflow关于这方面的讨论，链接如下：</p>
<a id="more"></a>
<p><a href="https://stackoverflow.com/questions/46715072/passing-env-variables-to-docker-spring-boot" target="_blank" rel="external">Passing env variables to DOCKER Spring Boot</a></p>
<p><strong>通过Dockerfile定义Spring Profile</strong></p>
<p>通常在命令行中我们可以使用<code>java -jar</code> 运行 Spring Boot应用。<br>而Profiles信息可以作为额外参数传递，比如<code>-Dspring.profiles.active=dev</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">java -Djava.security.egd=file:/dev/./urandom -Dspring.profiles.active=dev -jar app.jar</div></pre></td></tr></table></figure>
<p>相似的，我们可以在Dockerfile中将Profile的信息作为参数传递进去，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">FROM openjdk:8-jdk-alpine</div><div class="line">VOLUME /tmp</div><div class="line">ADD spring-boot-docker-0.0.1-SNAPSHOT.jar app.jar</div><div class="line">ENTRYPOINT [&quot;java&quot;, &quot;-Djava.security.egd=file:/dev/./urandom&quot;,&quot;-Dspring.profiles.active=dev&quot;,&quot;-jar&quot;,&quot;/app.jar&quot;]</div></pre></td></tr></table></figure>
<p>需要注意最后的ENTRYPOINT一行，在这行中我们传递java命令以执行jar文件，所有需要的参数和值以逗号方式分隔传递。<br><code>-Dspring.profiles.active=dev</code> 是我们定义dev profile的地方，我们可以替换dev为任何需要的名字。</p>
<p><strong>通过Docker run命令定义Spring Profile</strong></p>
<p>可以将spring profile作为环境变量传递给docker run命令，使用 -e 标记。<br>例如<code>-e “SPRING_PROFILES_ACTIVE=dev”会将dev profile</code>传递给Docker容器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker run -d -p 8080:8080 -e &quot;SPRING_PROFILES_ACTIVE=dev&quot; --name rest-api dockerImage:latest</div></pre></td></tr></table></figure>
<p>Dockerfile中改为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ENTRYPOINT [&quot;java&quot;, &quot;-Djava.security.egd=file:/dev/./urandom&quot;,&quot;-Dspring.profiles.active=$&#123;SPRING_PROFILES_ACTIVE&#125;&quot;,&quot;-jar&quot;,&quot;/app.jar&quot;]</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们在利用Docker启动SpringBoot应用时，需要在启动时指定Profile来确定运行环境，如果再需要指定其他参数，参数的传递就十分有必要了。下面是stackoverflow关于这方面的讨论，链接如下：&lt;/p&gt;
    
    </summary>
    
      <category term="Docker" scheme="http://yoursite.com/categories/Docker/"/>
    
    
      <category term="Docker" scheme="http://yoursite.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>JDK中的反射</title>
    <link href="http://yoursite.com/2018/08/19/JDK%E4%B8%AD%E7%9A%84%E5%8F%8D%E5%B0%84/"/>
    <id>http://yoursite.com/2018/08/19/JDK中的反射/</id>
    <published>2018-08-18T16:00:00.000Z</published>
    <updated>2018-08-19T14:19:33.030Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>反射是Java语言中一个比较重要的特性，它允许对正在运行的Java进行观测，甚至动态修改程序，即在运行态，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性。</p>
<a id="more"></a>
<h2 id="反射API介绍"><a href="#反射API介绍" class="headerlink" title="反射API介绍"></a>反射API介绍</h2><h3 id="获取Class对象"><a href="#获取Class对象" class="headerlink" title="获取Class对象"></a>获取Class对象</h3><p>通常来说，使用反射API的第一步是获取Class对象，在Java中比较常见的有以下几种：</p>
<ol>
<li>已知具体的类，通过类的class属性获取，对于基本类型来说，它们的包装类型（wrapper classes）拥有一个名为“TYPE”的final静态字段，指向该基本类型对应的Class对象</li>
<li>已知某个类的实例，调用对象的getClass()方法获取Class对象</li>
<li>已知一个类的全类名，使用静态方法Class.forName来获取</li>
</ol>
<p>例如，Integer.TYPE 指向 int.class。对于数组类型来说，可以使用类名 +“[ ].class”来访问，如 int[ ].class。</p>
<p>除此之外，Class 类和 java.lang.reflect 包中还提供了许多返回 Class 对象的方法。例如，对于数组类的 Class 对象，调用 Class.getComponentType() 方法可以获得数组元素的类型。</p>
<p>我们还可以利用自定义Classloader来加载我们的类，然后可以获取到该类的Class对象。类似于下面的代码，注意代码可能会抛出异常。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">MyClassLoader classLoader = <span class="keyword">new</span> MyClassLoader(workspace + <span class="string">"/src/me/mingshan"</span>);</div><div class="line">Class&lt;?&gt; proxy0Class = classLoader.findClass(<span class="string">"$Proxy0"</span>);</div></pre></td></tr></table></figure>
<h3 id="其他操作"><a href="#其他操作" class="headerlink" title="其他操作"></a>其他操作</h3><p>拿到Class对象后，我们可以进行很多操作，比如生成该类的实例，访问字段的值，调用方法等。</p>
<h4 id="生成类的实例"><a href="#生成类的实例" class="headerlink" title="生成类的实例"></a>生成类的实例</h4><p>通过类的Class对象可以生成类的实例，有两种方式</p>
<ol>
<li>调用的是无参数的构造函数进行实例化</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">clazz.newInstance();</div></pre></td></tr></table></figure>
<ol>
<li>可以选择调用哪个构造函数进行实例化，获取构造器可以传入参数来选择</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Constructor c = clazz.getConstructor();</div><div class="line">Object obj = c.newInstance();</div></pre></td></tr></table></figure>
<h4 id="访问类的成员"><a href="#访问类的成员" class="headerlink" title="访问类的成员"></a>访问类的成员</h4><p>通过调用<code>getFiles()/getgetConstructors()/getMethods()</code>来访问该类的成员。同时我们会发现有些方法会带上Declared，这表示调用该方法不会返回父类的成员。</p>
<p>当然我们也可以直接获取类的某个成员，比如成员和方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 获取字段</span></div><div class="line">Field field = clazz.getField(<span class="string">"name"</span>);</div><div class="line"></div><div class="line"><span class="comment">// 获取方法</span></div><div class="line">Method method=clazz.getMethod(<span class="string">"studyHard"</span>, <span class="keyword">new</span> Class[]&#123;String.class&#125;);</div></pre></td></tr></table></figure>
<p>还有一点，我们可以获取该类实现的接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 获取该类所实现的所有接口</span></div><div class="line">Class&lt;?&gt; interfaces[] = clazz.getInterfaces();</div></pre></td></tr></table></figure>
<h5 id="对类成员操作"><a href="#对类成员操作" class="headerlink" title="对类成员操作"></a>对类成员操作</h5><p>当获取到类成员后，我们可以进行下一步操作。</p>
<ul>
<li>使用 Constructor/Field/Method.setAccessible(true) 来绕开 Java 语言的访问限制。</li>
<li>使用 Constructor.newInstance(Object[]) 来生成该类的实例。</li>
<li>使用 Field.get/set(Object) 来访问字段的值。</li>
<li>使用 Method.invoke(Object, Object[]) 来调用方法。</li>
</ul>
<h3 id="获取泛型"><a href="#获取泛型" class="headerlink" title="获取泛型"></a>获取泛型</h3><p>在Java中泛型有擦除机制，那么我们在运行时可不可以获取泛型的具体类型呢？答案是可以的。原因是Class类文件结构中有一个叫Signature的属性。它的作用是存储一个方法在字节码层面的特征签名。这个属性中保存的参数参数类型并不是原生类型，而是包括了参数化类型的信息。</p>
<h4 id="获取成员变量的泛型信息"><a href="#获取成员变量的泛型信息" class="headerlink" title="获取成员变量的泛型信息"></a>获取成员变量的泛型信息</h4><p>比如在一个类Test中，有一个成员变量list，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> List&lt;String&gt; list;</div></pre></td></tr></table></figure>
<p>现在我想直接想获取List的泛型，怎么获取呢？实现代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Type t = Test.class.getDeclaredField(<span class="string">"list"</span>).getGenericType();  </div><div class="line"><span class="keyword">if</span> (ParameterizedType.class.isAssignableFrom(t.getClass())) &#123;</div><div class="line">    <span class="keyword">for</span> (Type t1 : ((ParameterizedType) t).getActualTypeArguments()) &#123;</div><div class="line">        System.out.print(t1 + <span class="string">","</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>由于可能会有多个泛型参数，例如Map，所以返回是一个数组。</p>
<h4 id="获取类的泛型信息"><a href="#获取类的泛型信息" class="headerlink" title="获取类的泛型信息"></a>获取类的泛型信息</h4><p>一个类是泛型类，在该类中我们可能需要获取这个泛型到底是啥，然后继续进行下面的逻辑，一个应用是Hibernate动态拼接HQL，需要知道泛型信息。<br>那么如何操作？代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 通过反射获取泛型实例</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Genericity</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"rawtypes"</span>)</div><div class="line">    <span class="keyword">protected</span> Class clazz;</div><div class="line"></div><div class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">    <span class="comment">/**</span></div><div class="line">	 * 把泛型的参数提取出来的过程放入到构造函数中写，因为</div><div class="line">	 * 当子类创建对象的时候，直接调用父类的构造函数</div><div class="line">	 */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Genericity</span><span class="params">()</span> </span>&#123;</div><div class="line">    	<span class="comment">// 通过反射机制获取子类传递过来的实体类的类型信息</span></div><div class="line">        ParameterizedType type = (ParameterizedType) <span class="keyword">this</span>.getClass().getGenericSuperclass();</div><div class="line">        <span class="comment">//得到t的实际类型</span></div><div class="line">        clazz = (Class&lt;T&gt;) type.getActualTypeArguments()[<span class="number">0</span>];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 获取指定实例的所有属性名及对应值的Map实例 </div><div class="line">     * <span class="doctag">@param</span> entity 实例</div><div class="line">     * <span class="doctag">@return</span> 字段名及对应值的Map实例</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">protected</span> Map&lt;String, Object&gt; <span class="title">getFieldValueMap</span><span class="params">(T entity)</span> </span>&#123;</div><div class="line">        <span class="comment">// key是属性名，value是对应值</span></div><div class="line">        Map&lt;String, Object&gt; fieldValueMap = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</div><div class="line"></div><div class="line">        <span class="comment">// 获取当前加载的实体类中所有属性</span></div><div class="line">        Field[] fields = <span class="keyword">this</span>.clazz.getDeclaredFields();</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; fields.length; i++) &#123;</div><div class="line">            Field f = fields[i];</div><div class="line">            <span class="comment">// 属性名 </span></div><div class="line">            String key = f.getName();</div><div class="line">            <span class="comment">//属性值 </span></div><div class="line">            Object value = <span class="keyword">null</span>; </div><div class="line">            <span class="comment">// 忽略序列化版本ID号</span></div><div class="line">            <span class="keyword">if</span> (! <span class="string">"serialVersionUID"</span>.equals(key)) &#123;</div><div class="line">            	<span class="comment">// 取消Java语言访问检查</span></div><div class="line">            	f.setAccessible(<span class="keyword">true</span>);</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    value =f.get(entity);</div><div class="line">                &#125; <span class="keyword">catch</span> (IllegalArgumentException e) &#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125;</div><div class="line">                fieldValueMap.put(key, value);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> fieldValueMap;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在上面的代码中，<code>this.getClass().getGenericSuperclass()</code>返回表示此 Class 所表示的实体（类、接口、基本类型或 void）的直接超类的Type，然后将其转换<code>ParameterizedType</code>。<br><code>getActualTypeArguments()</code>返回表示此类型实际类型参数的 Type 对象的数组。</p>
<h3 id="反射Array相关API"><a href="#反射Array相关API" class="headerlink" title="反射Array相关API"></a>反射Array相关API</h3><p>reflect.Array类位于java.lang.reflect包下,它是个反射工具包，全是静态方法。我们可以利用这个类来对数组进行操作。</p>
<p>调用Class.getComponentType()获取数组元素的类型，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</div><div class="line">Class&lt;?&gt; c = arr.getClass().getComponentType();</div></pre></td></tr></table></figure>
<p>假设我们需要获取数组长度，用Array的静态方法获取：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> len = Array.getLength(arr);</div></pre></td></tr></table></figure>
<p>当然我们可以用Array类来创建数组，向数组添加元素，修改元素等，具体可以参考官方API。</p>
<p>最后推荐一个<a href="https://github.com/Blankj/AndroidUtilCode/blob/4b5d0852f8274583968a7fb36db3b25bf92aaa22/utilcode/src/main/java/com/blankj/utilcode/util/ReflectUtils.java" target="_blank" rel="external">反射工具类</a>，可以参考参考。</p>
<p><strong>反射API参考：</strong></p>
<ul>
<li><p><a href="https://docs.oracle.com/javase/tutorial/reflect/" target="_blank" rel="external">https://docs.oracle.com/javase/tutorial/reflect/</a></p>
</li>
<li><p><a href="http://hg.openjdk.java.net/jdk10/jdk10/jdk/file/777356696811/src/java.base/share/classes/jdk/internal/reflect/ReflectionFactory.java#l80" target="_blank" rel="external">http://hg.openjdk.java.net/jdk10/jdk10/jdk/file/777356696811/src/java.base/share/classes/jdk/internal/reflect/ReflectionFactory.java#l80</a></p>
</li>
<li><p><a href="http://hg.openjdk.java.net/jdk10/jdk10/jdk/file/777356696811/src/java.base/share/classes/jdk/internal/reflect/ReflectionFactory.java#l78" target="_blank" rel="external">http://hg.openjdk.java.net/jdk10/jdk10/jdk/file/777356696811/src/java.base/share/classes/jdk/internal/reflect/ReflectionFactory.java#l78</a></p>
</li>
<li><p><a href="https://docs.oracle.com/javase/tutorial/reflect/class/classMembers.html" target="_blank" rel="external">https://docs.oracle.com/javase/tutorial/reflect/class/classMembers.html</a></p>
</li>
<li><p><a href="https://docs.oracle.com/javase/10/docs/api/java/lang/reflect/package-summary.html" target="_blank" rel="external">https://docs.oracle.com/javase/10/docs/api/java/lang/reflect/package-summary.html</a></p>
</li>
</ul>
<p><strong>文章参考：</strong></p>
<ul>
<li>郑雨迪, JVM是如何实现反射的?</li>
<li>周志明，深入理解Java虚拟机:JVM高级特性与最佳实践（第2版）</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;反射是Java语言中一个比较重要的特性，它允许对正在运行的Java进行观测，甚至动态修改程序，即在运行态，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="反射" scheme="http://yoursite.com/tags/%E5%8F%8D%E5%B0%84/"/>
    
  </entry>
  
  <entry>
    <title>自己如何实现一个简单的动态代理？</title>
    <link href="http://yoursite.com/2018/08/19/%E8%87%AA%E5%B7%B1%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%EF%BC%9F/"/>
    <id>http://yoursite.com/2018/08/19/自己如何实现一个简单的动态代理？/</id>
    <published>2018-08-18T16:00:00.000Z</published>
    <updated>2018-08-19T10:34:11.649Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>经过对JDK动态代理实现原理的解析，我们会对动态代理的实现流程有个根本的认识，具体分析过程参考<a href="http://mingshan.me/2018/07/10/JDK%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/#more" target="_blank" rel="external">JDK动态代理实现原理</a>这篇文章，这里就不多谈了。这篇文章主要思考如何去实现一个简易的动态代理，以便加深对其的理解。</p>
<a id="more"></a>
<p>模仿着JDK动态代理，我们需要一个代理<code>Proxy</code>类，一个<code>InvocationHandler</code>接口，同时实现一个类加载器，下面为定义的类。</p>
<p><img src="https://github.com/ZZULI-TECH/interview/blob/master/images/my-dynamic-proxy-class.png?raw=true" alt="image"></p>
<p>具体实现流程为：</p>
<p>首先定义一个<code>InvocationHandler</code>接口，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyInvocationHandler</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * proxy: 正在返回的代理对象，一般情况下，都不使用该对象</div><div class="line">     * method: 正在被调用的方法</div><div class="line">     * args: 调用方法时传入的参数</div><div class="line">     */</div><div class="line">    <span class="function">Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接口中有一个invoke方法，方法中有三个参数，分别是：</p>
<ul>
<li>proxy: 正在返回的代理对象，一般情况下，都不使用该对象</li>
<li>method: 正在被调用的方法</li>
<li>args: 调用方法时传入的参数</li>
</ul>
<p>下面就需要实现代理类<code>Proxy</code>，动态代理的核心就是在这个类中实现的，主要功能包括如下几点：</p>
<ul>
<li>动态生成代理类，类似<code>$Proxy0.java</code></li>
<li>调用Java编译器，编译生成的代理类</li>
<li>将生成的class文件利用类加载器加载到内存中，然后进行实例化</li>
<li>调用自定义<code>InvocationHandler</code>的invoke方法</li>
</ul>
<p>详细代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> *</div><div class="line"> * 定义自己的 Proxy代理</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyProxy</span> </span>&#123;</div><div class="line">    <span class="keyword">protected</span> MyInvocationHandler h;</div><div class="line"></div><div class="line">    <span class="comment">// 定义回车键</span></div><div class="line">    <span class="keyword">static</span> String rt = <span class="string">"\r\t"</span>;</div><div class="line"></div><div class="line">    <span class="comment">// 用户的当前工作目录,包含项目名</span></div><div class="line">    <span class="keyword">static</span> String workspace = System.getProperty(<span class="string">"user.dir"</span>);</div><div class="line"></div><div class="line">    <span class="comment">// 当前类包名</span></div><div class="line">    <span class="keyword">static</span> String packageName = MyProxy.class.getPackage().getName();</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 私有构造器，该类禁止被实例化</div><div class="line">     */</div><div class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unused"</span>)</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">MyProxy</span><span class="params">()</span> </span>&#123;&#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 由于 MyProxy 内部从不直接调用构造函数，所以 protected 意味着只有子类可以调用</div><div class="line">     * <span class="doctag">@param</span> h</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">MyProxy</span><span class="params">(MyInvocationHandler h)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.h = h;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 在内存中创建$proxy0 的实例</div><div class="line">     * <span class="doctag">@param</span> loader</div><div class="line">     * <span class="doctag">@param</span> interfaces</div><div class="line">     * <span class="doctag">@param</span> h</div><div class="line">     * <span class="doctag">@return</span></div><div class="line">     * <span class="doctag">@throws</span> IllegalArgumentException</div><div class="line">     * <span class="doctag">@throws</span> IOException</div><div class="line">     */</div><div class="line">    <span class="meta">@SuppressWarnings</span>(&#123; <span class="string">"rawtypes"</span>, <span class="string">"resource"</span>, <span class="string">"unchecked"</span> &#125;)</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">createProxyInstance</span><span class="params">(ClassLoader loader,</span></span></div><div class="line">            Class interfaces,</div><div class="line">            MyInvocationHandler h) <span class="keyword">throws</span> IllegalArgumentException, IOException &#123;</div><div class="line"></div><div class="line">        Objects.requireNonNull(h);</div><div class="line"></div><div class="line">        <span class="comment">//实际运行这个动态类构造一个对象</span></div><div class="line">        System.out.println(<span class="string">"=====自定义:类构造一个代理类的java对象"</span>);</div><div class="line">        Method[] methods = interfaces.getMethods();</div><div class="line"></div><div class="line">        String proxyClassString = <span class="string">"package pers.han;"</span> + rt</div><div class="line">                + <span class="string">"import java.lang.reflect.Method;"</span> + rt</div><div class="line">                + <span class="string">"public class $Proxy0 implements "</span> + interfaces.getName() + <span class="string">"&#123;"</span> + rt</div><div class="line">                + <span class="string">"protected MyInvocationHandler h;"</span> + rt</div><div class="line">                + <span class="string">"public $Proxy0(MyInvocationHandler h)&#123;"</span> + rt</div><div class="line">                + <span class="string">"this.h=h;"</span> + rt + <span class="string">"&#125;"</span> + rt + getMethodString(methods,interfaces)</div><div class="line">                + rt + <span class="string">"&#125;"</span>;</div><div class="line"></div><div class="line">        <span class="comment">//我们将自定义的代理类转化为文件</span></div><div class="line">        String fileName = workspace+<span class="string">"/src/pers/han/$Proxy0.java"</span>;</div><div class="line">        File file = <span class="keyword">new</span> File(fileName);</div><div class="line"></div><div class="line">        <span class="comment">//向文件写内容</span></div><div class="line">        FileWriter fw = <span class="keyword">new</span> FileWriter(file);</div><div class="line">        fw.write(proxyClassString);</div><div class="line">        fw.flush();</div><div class="line">        <span class="comment">//编译这个文件</span></div><div class="line">        JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();</div><div class="line">        System.out.println(<span class="string">"comiler-"</span> + compiler);</div><div class="line">        StandardJavaFileManager fileManager = compiler.getStandardFileManager(<span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</div><div class="line">        Iterable units = fileManager.getJavaFileObjects(fileName);</div><div class="line">        <span class="comment">//编译这个任务</span></div><div class="line">        CompilationTask compTask = compiler.getTask(<span class="keyword">null</span>, fileManager, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, units);</div><div class="line">        compTask.call();</div><div class="line">        fileManager.close();</div><div class="line">        <span class="comment">//编译完成后，是不是.java</span></div><div class="line">        file.delete();</div><div class="line">        <span class="comment">//编译后就是class文件，那么接下来就把这个class文件 加到内存</span></div><div class="line">        MyClassLoader classLoader = <span class="keyword">new</span> MyClassLoader(workspace + <span class="string">"/src/pers/han"</span>);</div><div class="line"></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            Class&lt;?&gt; proxy0Class = classLoader.findClass(<span class="string">"$Proxy0"</span>);</div><div class="line">            <span class="comment">//等类加载完之后 ，删除</span></div><div class="line">            File classFile = <span class="keyword">new</span> File(workspace + <span class="string">"/src/pers/han/$Proxy0.class"</span>);</div><div class="line">            <span class="keyword">if</span> (classFile.exists()) &#123;</div><div class="line">                classFile.delete();</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            Constructor&lt;?&gt; m = proxy0Class.getConstructor(MyInvocationHandler.class);</div><div class="line">            Object object = m.newInstance(h);</div><div class="line">            <span class="keyword">return</span> object;</div><div class="line">        &#125; <span class="keyword">catch</span>(Exception e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 实现的方法</div><div class="line">     * <span class="doctag">@param</span> methods</div><div class="line">     * <span class="doctag">@param</span> interfaces</div><div class="line">     * <span class="doctag">@return</span></div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">getMethodString</span><span class="params">(Method[] methods, Class&lt;?&gt; interfaces)</span> </span>&#123;</div><div class="line">        String proxyMe = <span class="string">""</span>;</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (Method m : methods) &#123;</div><div class="line">            proxyMe += <span class="string">"public void "</span> + m.getName() + <span class="string">"() throws Throwable &#123;"</span> + rt</div><div class="line">                    + <span class="string">"Method md="</span> + interfaces.getName() + <span class="string">".class.getMethod(\""</span></div><div class="line">                    + m.getName() + <span class="string">"\", new Class[]&#123;&#125;);"</span> + rt</div><div class="line">                    + <span class="string">"this.h.invoke(this,md,null);"</span> + rt + <span class="string">"&#125;"</span> + rt;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> proxyMe;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>将类加载到内存中需要自定义类加载器，这里继承<code>ClassLoader</code>类，然后重写<code>findClass</code>方法，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 自己的类加载器</div><div class="line"> * <span class="doctag">@author</span> mingshan</div><div class="line"> *</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> File dir;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyClassLoader</span><span class="params">(String path)</span> </span>&#123;</div><div class="line">        dir = <span class="keyword">new</span> File( path );</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (dir != <span class="keyword">null</span>) &#123;</div><div class="line">            File classFile = <span class="keyword">new</span> File(dir, name + <span class="string">".class"</span>);</div><div class="line">            <span class="keyword">if</span> (classFile.exists()) &#123;</div><div class="line">                FileInputStream input = <span class="keyword">null</span>;</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    input = <span class="keyword">new</span> FileInputStream(classFile);</div><div class="line">                    ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();</div><div class="line">                    <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</div><div class="line">                    <span class="keyword">int</span> len;</div><div class="line">                    <span class="keyword">while</span> ((len=input.read(buffer)) != -<span class="number">1</span>) &#123;</div><div class="line">                        baos.write(buffer, <span class="number">0</span>, len);</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">return</span> defineClass(<span class="string">"pers.han."</span> + name, baos.toByteArray(), <span class="number">0</span>, baos.size());</div><div class="line">                &#125; <span class="keyword">catch</span>(Exception e) &#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                    <span class="keyword">if</span> (input != <span class="keyword">null</span>) &#123;</div><div class="line">                        <span class="keyword">try</span> &#123;</div><div class="line">                            input.close();</div><div class="line">                        &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">                            e.printStackTrace();</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>生成的代理类<code>$Proxy0.java</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">package pers.han;</div><div class="line">	import java.lang.reflect.Method;</div><div class="line">	public class $Proxy0 implements pers.han.Person&#123;</div><div class="line">	protected MyInvocationHandler h;</div><div class="line">	public $Proxy0(MyInvocationHandler h)&#123;</div><div class="line">	this.h=h;</div><div class="line">	&#125;</div><div class="line">	public void say() throws Throwable &#123;</div><div class="line">	Method md=pers.han.Person.class.getMethod(&quot;say&quot;, new Class[]&#123;&#125;);</div><div class="line">	this.h.invoke(this,md,null);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;经过对JDK动态代理实现原理的解析，我们会对动态代理的实现流程有个根本的认识，具体分析过程参考&lt;a href=&quot;http://mingshan.me/2018/07/10/JDK%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/#more&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;JDK动态代理实现原理&lt;/a&gt;这篇文章，这里就不多谈了。这篇文章主要思考如何去实现一个简易的动态代理，以便加深对其的理解。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="动态代理" scheme="http://yoursite.com/tags/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Jenkins自动构建SpringBoot应用部署到Docker</title>
    <link href="http://yoursite.com/2018/08/18/Jenkins%E8%87%AA%E5%8A%A8%E6%9E%84%E5%BB%BASpringBoot%E5%BA%94%E7%94%A8%E9%83%A8%E7%BD%B2%E5%88%B0Docker/"/>
    <id>http://yoursite.com/2018/08/18/Jenkins自动构建SpringBoot应用部署到Docker/</id>
    <published>2018-08-17T16:00:00.000Z</published>
    <updated>2018-08-18T09:11:49.317Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在开发SpringCloud微服务时，各个服务需要独立部署，手动部署比较麻烦，所以需要引入持续集成，Jenkins是一个非常好用的持续集成工具，十分好用。在使用Jenkins自动构建源码时，需要按照一定的步骤进行，步骤如下：</p>
<a id="more"></a>
<ol>
<li>从Git获取源代码</li>
<li>代码审查</li>
<li>编译代码</li>
<li>打包文件</li>
<li>部署到Docker</li>
</ol>
<p>以上步骤我们手动也可以完成，但我们都喜欢自动化，自己点一点就能搞定，干嘛还要一步步来呢。</p>
<h2 id="配置Jenkins环境"><a href="#配置Jenkins环境" class="headerlink" title="配置Jenkins环境"></a>配置Jenkins环境</h2><p>我们直接使用Docker安装Jenkins，我是直接安装Jenkins每日更新的镜像，<a href="https://hub.docker.com/r/jenkinsci/jenkins/" target="_blank" rel="external">Jenkins地址</a>，操作如下：</p>
<p>拉取镜像：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker pull jenkinsci/jenkins</div></pre></td></tr></table></figure>
<p>修改文件夹的归属者和组：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">chown -R 1000:1000 jenkins_home/</div></pre></td></tr></table></figure>
<p>启动Jenkins容器：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker run -itd -p 8088:8080 -p 50000:50000 --name jenkins --privileged=true  -v /usr/jenkins_home:/var/jenkins_home docker.io/jenkinsci/jenkins</div></pre></td></tr></table></figure>
<p>然后再配置一些个人信息和插件。</p>
<h2 id="新建任务"><a href="#新建任务" class="headerlink" title="新建任务"></a>新建任务</h2><p>首先我们需要新建Jenkins任务，选择Pipeline类型的任务，如下</p>
<p><img src="/images/jenkins_springbootdemo_start.png" alt="image"></p>
<p>然后配置下git信息和构建参数信息</p>
<p>构建参数主要有以下几个：</p>
<ul>
<li><strong>BRANCH_NAME</strong> 分支名称</li>
<li><strong>ENV</strong> 环境</li>
<li><strong>TARGET_MACHINE_IP</strong> 部署集群IP</li>
<li><strong>SSH_PORT</strong> 部署机器SSH端口</li>
<li><strong>TARGET_PORT</strong> 项目启动端口</li>
</ul>
<p>说到SSH，不要忘了让jenkins服务器能够免密SSH访问目标机器，配置下authorized_key等信息。</p>
<p>接下来就需要编写Jenkinsfile文件了，这个文件需要放在项目主目录下，构建源码时Jenkins会读取该文件，按照该文件配置的步骤进行源码构建。</p>
<h2 id="编写Jenkinsfile文件"><a href="#编写Jenkinsfile文件" class="headerlink" title="编写Jenkinsfile文件"></a>编写Jenkinsfile文件</h2><p>在Jenkinsfile文件中，利用pipeline来编写步骤。pipeline支持将连续输送Pipeline实施和整合到Jenkins，所以我们可以将上面提到的流程写到pipeline中。这里主要分以下五部：</p>
<ul>
<li>git clone</li>
<li>check code</li>
<li>build code</li>
<li>release package</li>
<li>deploy</li>
</ul>
<p>前两步就不提了，编译用Maven构建代码，release package这一步为打包代码，将一些脚本和编译好的jar文件打包成压缩文件，等待部署。deploy需要将打包的压缩文件拷贝到目标机器上，再执行部署脚本。</p>
<p>详细的Jenkinsfile如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div></pre></td><td class="code"><pre><div class="line">pipeline &#123;</div><div class="line">    agent any</div><div class="line"></div><div class="line">    environment &#123;</div><div class="line">        REPOSITORY=&quot;https://github.com/mstao/spring-boot-learning.git&quot;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    stages &#123;</div><div class="line">        stage(&apos;git clone&apos;) &#123;</div><div class="line">            steps &#123;</div><div class="line">                echo &quot;&lt;&lt;&lt; Starting fetch code from git:$&#123;REPOSITORY&#125;&quot;</div><div class="line">                git credentialsId: &quot;bd8b65ce-7fd2-4e57-a9fe-45d4fe2924bf&quot;, url: &quot;$&#123;REPOSITORY&#125;&quot;, branch: &quot;$BRANCH_NAME&quot;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        stage(&apos;check code&apos;) &#123;</div><div class="line">            steps &#123;</div><div class="line">                // chek code</div><div class="line">                // Jenkins 集成 sonar 进行代码审查</div><div class="line">                echo &quot;&lt;&lt;&lt;Starting check and analytic code&quot;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        stage(&apos;build code&apos;) &#123;</div><div class="line">            steps &#123;</div><div class="line">                echo &quot;&lt;&lt;&lt; Starting build code and docker image&quot;</div><div class="line">                withMaven (</div><div class="line">                    maven: &apos;Maven 3.5.4&apos;,</div><div class="line">                    mavenLocalRepo: &apos;.repository&apos;) &#123;</div><div class="line">                        sh &apos;mvn clean package -Dmaven.test.skip=true&apos;</div><div class="line">                    &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        stage(&apos;release package&apos;) &#123;</div><div class="line">            steps &#123;</div><div class="line">                echo &quot;&lt;&lt;&lt; release package to /var/jenkins_home/release/demo/$ENV/$BRANCH_NAME&quot;</div><div class="line">                sh &apos;&apos;&apos;</div><div class="line">                    if [ -d target/demo ]</div><div class="line">                        then</div><div class="line">                        rm -rf target/demo</div><div class="line">                    fi</div><div class="line">                    mkdir -p target/demo</div><div class="line">                &apos;&apos;&apos;</div><div class="line">                sh &apos;&apos;&apos;</div><div class="line">                    cp target/*.jar target/demo/demo-api.jar</div><div class="line">                    cp deploy.sh target/demo/</div><div class="line">                    cp Dockerfile target/demo/</div><div class="line">                    cd target</div><div class="line">                    tar zcvf demo.tar.gz demo</div><div class="line">                    exit</div><div class="line">                &apos;&apos;&apos;</div><div class="line">                sh &apos;&apos;&apos;</div><div class="line">                    if [ ! -d /var/jenkins_home/release/demo/$ENV/$BRANCH_NAME ]</div><div class="line">                        then</div><div class="line">                        mkdir -p /var/jenkins_home/release/demo/$ENV/$BRANCH_NAME</div><div class="line">                    fi</div><div class="line">                &apos;&apos;&apos;</div><div class="line">                sh &apos;cp -f target/*.tar.gz /var/jenkins_home/release/demo/$ENV/$BRANCH_NAME&apos;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        stage(&apos;deploy&apos;) &#123;</div><div class="line">            steps &#123;</div><div class="line">                echo &quot;&lt;&lt;&lt; Starting deploy code to docker&quot;</div><div class="line">                 script &#123;</div><div class="line">                    try &#123;</div><div class="line">                        sh &apos;&apos;&apos;</div><div class="line">                            ssh -p $SSH_PORT -o StrictHostKeyChecking=no mingshan@$TARGET_MACHINE_IP rm -rf /app/tmp/demo/package</div><div class="line">                            ssh -p $SSH_PORT mingshan@$TARGET_MACHINE_IP mkdir -p /app/tmp/demo/package</div><div class="line">                        &apos;&apos;&apos;</div><div class="line">                    &#125;</div><div class="line">                    catch(e) &#123;</div><div class="line">                        echo e</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                sh &apos;&apos;&apos;</div><div class="line">                    scp -P $SSH_PORT /var/jenkins_home/release/demo/$ENV/$BRANCH_NAME/*.tar.gz mingshan@$TARGET_MACHINE_IP:/app/tmp/demo/package/</div><div class="line">                    ssh -p $SSH_PORT mingshan@$TARGET_MACHINE_IP &quot;tar -zxf /app/tmp/demo/package/demo.tar.gz -C /app/tmp/demo/package&quot;</div><div class="line">                    ssh -p $SSH_PORT mingshan@$TARGET_MACHINE_IP &quot;cd /app/tmp/demo/package/demo &amp;&amp; chmod +x * &amp;&amp; sh deploy.sh $TARGET_PORT&quot;</div><div class="line">                    exit</div><div class="line">                &apos;&apos;&apos;</div><div class="line">                echo &quot;deploy done&quot;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="部署到Docker"><a href="#部署到Docker" class="headerlink" title="部署到Docker"></a>部署到Docker</h2><p>由于需要将打包的文件部署到Docker，所以需要将部署脚本和压缩文件发送到目标机器，在目标机器上制作Docker镜像，然后运行Docker 容器。</p>
<p>由于Docker需要root用户进行运行，而对于一些机器而言，拿不到root权限，所以需要进行一些操作，参考：<br><a href="https://blog.csdn.net/baidu_36342103/article/details/69357438" target="_blank" rel="external">免sudo使用docker命令</a></p>
<p>在Jenkinsfile中deploy步骤中，执行了以下命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssh -p $SSH_PORT mingshan@$TARGET_MACHINE_IP "cd /app/tmp/demo/package/demo &amp;&amp; chmod +x * &amp;&amp; sh deploy.sh $TARGET_PORT"</div></pre></td></tr></table></figure>
<p>这是到目标机器上执行deploy.sh脚本，该脚本的内容如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">#!/bin/bash</div><div class="line"></div><div class="line">port=11001</div><div class="line">image=demo</div><div class="line">name=demo-service</div><div class="line"></div><div class="line">if [ -z $1 ]; then</div><div class="line">    echo &quot;&lt;&lt;&lt; Using default port $port&quot;</div><div class="line">else</div><div class="line">    echo &quot;&lt;&lt;&lt; Set port to $1&quot;</div><div class="line">    $port=$1</div><div class="line">fi</div><div class="line"></div><div class="line">echo &quot;&lt;&lt;&lt; Fetch container id of $name&quot;</div><div class="line">CID=$(docker ps | grep &quot;demo-service&quot; | awk &apos;&#123;print $1&#125;&apos;)</div><div class="line"></div><div class="line">if [ &quot;$CID&quot; != &quot;&quot; ];then</div><div class="line">  echo &quot;&lt;&lt;&lt; Stop and remove old container for $name&quot;</div><div class="line">  docker stop $CID</div><div class="line">  docker rm $CID</div><div class="line">fi</div><div class="line"></div><div class="line">echo &quot;&lt;&lt;&lt; Remove old image $image&quot;</div><div class="line">docker rmi $image</div><div class="line"></div><div class="line">echo &quot;&lt;&lt;&lt; Start to build docker image $image&quot;</div><div class="line">docker build -t $image .</div><div class="line"></div><div class="line">echo &quot;&lt;&lt;&lt; Start new container port: $port for $name&quot;</div><div class="line">docker run -d -p $port:8080 --name $name $image</div></pre></td></tr></table></figure>
<p>在<code>deploy.sh</code>脚本中，主要分为以下几步：</p>
<ol>
<li>停止和删除旧容器</li>
<li>删除旧镜像</li>
<li>构建新镜像</li>
<li>运行容器</li>
</ol>
<p>这个脚本比较简单，按照上面的几步编写就行了。</p>
<p>最后附上项目的Dockerfile，也没啥说的。</p>
<p><strong>Dockerfile</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">FROM openjdk:8-jdk-alpine</div><div class="line">VOLUME /tmp</div><div class="line">ADD spring-boot-docker-0.0.1-SNAPSHOT.jar app.jar</div><div class="line">ENTRYPOINT [&quot;java&quot;,&quot;-Djava.security.egd=file:/dev/./urandom&quot;,&quot;-jar&quot;,&quot;/app.jar&quot;]</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在开发SpringCloud微服务时，各个服务需要独立部署，手动部署比较麻烦，所以需要引入持续集成，Jenkins是一个非常好用的持续集成工具，十分好用。在使用Jenkins自动构建源码时，需要按照一定的步骤进行，步骤如下：&lt;/p&gt;
    
    </summary>
    
      <category term="Docker" scheme="http://yoursite.com/categories/Docker/"/>
    
    
      <category term="Docker" scheme="http://yoursite.com/tags/Docker/"/>
    
      <category term="Jenkins" scheme="http://yoursite.com/tags/Jenkins/"/>
    
      <category term="SpringBoot" scheme="http://yoursite.com/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>利用Docker搭建Nexus3私服</title>
    <link href="http://yoursite.com/2018/08/05/%E5%88%A9%E7%94%A8Docker%E6%90%AD%E5%BB%BANexus3%E7%A7%81%E6%9C%8D/"/>
    <id>http://yoursite.com/2018/08/05/利用Docker搭建Nexus3私服/</id>
    <published>2018-08-04T16:00:00.000Z</published>
    <updated>2018-08-05T03:58:23.907Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>搭建私服对于一个团队来说十分有必要，利用Nexus3搭建私服十分方便，结合Docker，那是相当快速。</p>
<a id="more"></a>
<h2 id="安装Nexus3"><a href="#安装Nexus3" class="headerlink" title="安装Nexus3"></a>安装Nexus3</h2><p>拉取Nexus3的镜像</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker pull sonatype/nexus3</div></pre></td></tr></table></figure>
<p>创建文件夹，挂载目录<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mkdir /var/nexus-data &amp;&amp; chown -R 200 /var/nexus-data</div></pre></td></tr></table></figure></p>
<p>启动容器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker run -d -p 8081:8081 --name nexus -v /var/nexus-data:/nexus-data --restart=always sonatype/nexus3</div></pre></td></tr></table></figure>
<p>开启端口</p>
<p>如果让外网访问的话，需要开放8081端口，在CentOS7中，可以利用firewall-cmd来开放端口</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">#开放11001端口  permanent为永久开放</div><div class="line">firewall-cmd --zone=public --add-port=8081/tcp --permanent</div><div class="line">#重新读取配置</div><div class="line">firewall-cmd --reload</div><div class="line">#查看全部开放端口</div><div class="line">firewall-cmd --list-all</div></pre></td></tr></table></figure>
<p>接下来在浏览器中输入以下网址，就可以看到Nexus3界面了如下图所示，用户名和密码默认为admin，admin123</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http://ip:port</div></pre></td></tr></table></figure>
<p><img src="/images/nexus3-dashboard.png" alt="image"></p>
<h2 id="配置阿里云仓库"><a href="#配置阿里云仓库" class="headerlink" title="配置阿里云仓库"></a>配置阿里云仓库</h2><p>启动Nexus后，需要将中央仓库配置为阿里云仓库，提高国内的访问速度。Nexus的仓库如下：</p>
<p><img src="/images/nexus3-repository.png" alt="image"></p>
<p>由上图看出，Nexus的仓库分为这么几类：</p>
<ul>
<li>hosted 宿主仓库：主要用于部署无法从公共仓库获取的包以及自己或第三方的包；</li>
<li>proxy 代理仓库：代理公共的远程仓库；</li>
<li>group 仓库组：Nexus 通过仓库组的概念统一管理多个仓库，这样我们在项目中直接请求仓库组即可请求到仓库组管理的多个仓库。</li>
</ul>
<p>示意图如下：</p>
<p><img src="/images/nexus3-repository-desc.png" alt="image"></p>
<p>现在点击“Create Repository”按钮，来添加阿里云仓库，Recipe选择<code>maven2(proxy)</code>，在具体配置页面取名aliyun-repository，这里建议用a开头(估计按字母排序将它排第一位)，URL输入：<code>http://maven.aliyun.com/nexus/content/groups/public/</code>，其他默认值即可。</p>
<h2 id="配置maven"><a href="#配置maven" class="headerlink" title="配置maven"></a>配置maven</h2><p>接下来我们需要配置maven，打开setting.xml文件，在mirrors节点下加入以下配置（根据自己的配置更改）：</p>
<p>将<code>&lt;mirror&gt;&lt;url&gt;</code>标签内的地址修改成nexus服务的地址。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">mirror</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus<span class="tag">&lt;/<span class="name">id</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>*<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>nexus maven<span class="tag">&lt;/<span class="name">name</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://www.mingzhiwen.cn:8081/repository/maven-public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></div></pre></td></tr></table></figure>
<p>然后在services节点下加入以下配置，<code>&lt;servers&gt;</code>标签内填写nexus服务的账号密码，发布maven项目到nexus时，需要用到。<code>&lt;server&gt;&lt;id&gt;</code>下id需要跟<code>&lt;mirror&gt;&lt;id&gt;</code>一致。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">server</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus<span class="tag">&lt;/<span class="name">id</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">username</span>&gt;</span>admin<span class="tag">&lt;/<span class="name">username</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">password</span>&gt;</span>admin123<span class="tag">&lt;/<span class="name">password</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">server</span>&gt;</span></div></pre></td></tr></table></figure>
<p>最后在项目中的<code>pom.xml</code>文件加入以下配置：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">distributionManagement</span>&gt;</span> </div><div class="line">	<span class="tag">&lt;<span class="name">repository</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus<span class="tag">&lt;/<span class="name">id</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">name</span>&gt;</span>Releases<span class="tag">&lt;/<span class="name">name</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">url</span>&gt;</span>http://&#123;your-nexus-ip&#125;:port/repository/maven-releases/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></div><div class="line">	<span class="tag">&lt;/<span class="name">repository</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">snapshotRepository</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus<span class="tag">&lt;/<span class="name">id</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">name</span>&gt;</span>Snapshot<span class="tag">&lt;/<span class="name">name</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">url</span>&gt;</span>http://&#123;your-nexus-ip&#125;:port/repository/maven-snapshots/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></div><div class="line">	<span class="tag">&lt;/<span class="name">snapshotRepository</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">distributionManagement</span>&gt;</span></div></pre></td></tr></table></figure>
<p>运行maven命令，将编译好的Jar包上传到Nexus私服中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mvn clean deploy</div></pre></td></tr></table></figure>
<p>上传效果如下图所示：</p>
<p><img src="/images/nexus3-upload.png" alt="image"></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://www.jianshu.com/p/dbeae430f29d" target="_blank" rel="external">https://www.jianshu.com/p/dbeae430f29d</a></li>
<li><a href="https://github.com/sonatype/docker-nexus3" target="_blank" rel="external">https://github.com/sonatype/docker-nexus3</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;搭建私服对于一个团队来说十分有必要，利用Nexus3搭建私服十分方便，结合Docker，那是相当快速。&lt;/p&gt;
    
    </summary>
    
      <category term="Docker" scheme="http://yoursite.com/categories/Docker/"/>
    
    
      <category term="Nexus3" scheme="http://yoursite.com/tags/Nexus3/"/>
    
  </entry>
  
  <entry>
    <title>像是昨天</title>
    <link href="http://yoursite.com/2018/08/01/%E5%83%8F%E6%98%AF%E6%98%A8%E5%A4%A9/"/>
    <id>http://yoursite.com/2018/08/01/像是昨天/</id>
    <published>2018-07-31T16:00:00.000Z</published>
    <updated>2018-08-02T16:12:12.213Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>半夜醒来，想起前尘往事，遂成比文。我一写东西大多是唠叨，夹杂着些许不成熟的想法，姑且记录下来吧。</p>
<a id="more"></a>
<p>2016年7月，我的好朋友给我打了个电话让我去武汉玩，从此我真切感受到世界的另一面。本来不想把这些东西写成文章记录下来，但一直在心中憋着，就像一团结在心中缠绕，勒得心中直疼。再加上最近另一个好朋友也遇到此事，自己却没帮上什么忙。虽说自己也不懂什么大道理，说不出让人顿悟警醒的话，但基本的做人做事原则我还是能说上两句。时隔两年，心中除了惆怅和遗憾，还多了些许的无助感。</p>
<p>那么，2016年7月我遇到了什么事情呢？我遇到了所谓被称为传销的东西。传销这个词现在被人说烂了，我们没接触过的人听到这个词不会大惊小怪，新闻经常报道，即使是里面的人，直接会拿这个词给你说道说道，用他们的一套说辞来给你解释这个东西，直到你信以为真。千万不要小看这个让你信以为真的过程，这个过程被称为洗脑，这个词也是很常见，他们用所谓的大道理，所谓的说了一百遍都狗屁不是的话让你确认他们说的是真理，是赚钱迈向成功的一条猛路子，以便达到他们不可告人、见不得光的目地。很多事情在暗地里表面上看起来还是那么一回事，但真正剖析这件事的前因后果，可能发现原来多美好的一件事情，背后指不定有什么道道。虽然结果令人沮丧，但还是要认真面对，因为这是对你人生成长极大的考验，不得不头脑清醒些。</p>
<p>才去的时候挺开心的，毕竟暑假没事在家待着无聊，出去转转散散心也挺好。当我好朋友带我去听人生中第一堂洗脑课时，整个人瞬间一愣，这是在讲什么，这么短时间就能赚这么多钱，不会是传销吧，这时我意识到我朋友可能被人拉进了传销。不过整个过程我十分镇定，依然笑容满面，谈笑风生，一点也没让人看出我内心的慌乱和翻腾。其实我内心早已翻江倒海了，我知道我是清醒的，我在听些什么，但我不确定我朋友内心此时是怎么想的，或者说我已经知道朋友内心是怎么想的，不过这是我最不愿看到的。但事实就是那么残酷，越不想相信的事情，现实就会逼着你去相信。但我看到我朋友坚定的眼神，决心似乎很大，这让我不由得担心起来了。我想劝劝我朋友，早日脱离苦海，但我们终是凡人，谁又能成了佛。</p>
<p>我接触了很多年纪轻轻的从业者，我始终相信他们是善良的，他们是被那些心中怀着鬼胎的垃圾利用了，被那些人操纵着思想，给他们一个光明的目标，他们就以为看到了太阳的曙光。不过他们又有什么错呢？他们只是想赚钱，或许是凭借着自己的“努力”吧，可惜努力用错了地方，光明也不是纯粹的光明。以前我最痛恨的是利用他人的无知来谋取利益，现在呢？把你思想先改变了，再利用你来赚钱，这是最无耻的，也是悄无声息的，所以很多人不知不觉走上了这样的道路，真是可惜可叹。</p>
<p>我不想发那么多的牢骚，因为没什么意思，但我还是愿意不厌其烦地告诫那么不愿意脚踏实地的同学，天下没那么多好事，不要以为自己走了好运而沾沾自喜，那很有可能是别人挖好了坑等着你跳。我们还太年轻，虽说吃点亏不算什么，但不能因为这个坑而改变了自己的所有。人时有穷尽，力所不能及，还是多想想吧。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;半夜醒来，想起前尘往事，遂成比文。我一写东西大多是唠叨，夹杂着些许不成熟的想法，姑且记录下来吧。&lt;/p&gt;
    
    </summary>
    
      <category term="随笔" scheme="http://yoursite.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="随笔" scheme="http://yoursite.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>构建一个Tomcat的Docker镜像</title>
    <link href="http://yoursite.com/2018/07/28/%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AATomcat%E7%9A%84Docker%E9%95%9C%E5%83%8F/"/>
    <id>http://yoursite.com/2018/07/28/构建一个Tomcat的Docker镜像/</id>
    <published>2018-07-27T16:00:00.000Z</published>
    <updated>2018-07-28T15:25:40.938Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>最近在看Docker，对一个事物由陌生到熟悉需要一个过程，而这个过程需要从动手实践开始，下面记录一下我从零开始构建centos7+jdk8+tomcat8.5的docker镜像。</p>
<a id="more"></a>
<p><img src="/images/docker.png" alt="image"></p>
<h2 id="CentOS7-Docker-安装"><a href="#CentOS7-Docker-安装" class="headerlink" title="CentOS7 Docker 安装"></a>CentOS7 Docker 安装</h2><p>Docker 要求 CentOS 系统的内核版本高于 3.10 ，查看本页面的前提条件来验证你的CentOS 版本是否支持 Docker。<br>通过 uname -r 命令查看你当前的内核版本 </p>
<p>利用yum安装docker</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">yum -y install docker-io</div></pre></td></tr></table></figure>
<p>安装完成后，启动docker服务</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">service docker start</div></pre></td></tr></table></figure>
<p>测试一下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker run hello-world</div></pre></td></tr></table></figure>
<h2 id="准备文件和构建环境"><a href="#准备文件和构建环境" class="headerlink" title="准备文件和构建环境"></a>准备文件和构建环境</h2><p>本次需要构建Tomcat的Docker镜像，所以需要Tomcat和JDK安装包，版本分别是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">apache-tomcat-8.5.32.tar.gz</div><div class="line"></div><div class="line">jdk-8u172-linux-x64.tar.gz</div></pre></td></tr></table></figure>
<p>创建<code>/usr/docker-tomcat</code>文件夹，将以上两个文件解压到该文件夹中，分别重命名为tomcat和jdk文件夹。</p>
<p>创建<code>Dockerfile</code>和<code>run.sh</code>两个文件，最终<code>/usr/docker-tomcat</code>文件夹内容如下图所示：</p>
<p><img src="/images/docker-tomcat-folder.png" alt="image"></p>
<p>编辑<code>Dockerfile</code>文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vim Dockerfile</div></pre></td></tr></table></figure>
<p>向该文件添加如下内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"># 设置继承的镜像</div><div class="line">FROM registry.cn-hangzhou.aliyuncs.com/repos_zyl/centos:0.0.1</div><div class="line"></div><div class="line"># 创建者信息</div><div class="line">MAINTAINER mingshan &quot;walkerhan@126.com&quot;</div><div class="line"></div><div class="line"># 设置环境变量，所有操作都是非交互式的</div><div class="line">ENV DEBIAN_FRONTEND noninteractive</div><div class="line"></div><div class="line"># 设置tomcat的环境变量</div><div class="line">ENV CATALINA_HOME /tomcat</div><div class="line">ENV JAVA_HOME /jdk</div><div class="line"></div><div class="line"># 复制tomcat和jdk文件到镜像中</div><div class="line">ADD apache-tomcat /tomcat</div><div class="line">ADD jdk /jdk</div><div class="line"></div><div class="line"># 复制启动脚本至镜像，并赋予脚本可执行权限</div><div class="line">ADD run.sh /run.sh</div><div class="line">RUN chmod +x /*.sh</div><div class="line">RUN chmod +x /tomcat/bin/*.sh</div><div class="line"></div><div class="line"># 暴露接口8080，这是我的tomcat接口，默认为8080</div><div class="line">EXPOSE 8080</div><div class="line"></div><div class="line"># 设置自启动命令</div><div class="line">CMD [&quot;/run.sh&quot;]</div></pre></td></tr></table></figure>
<p>保存后，然后编辑<code>run.sh</code>文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vim run.sh</div></pre></td></tr></table></figure>
<p>添加如下内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">#!/bin/bash</div><div class="line"># 启动tomcat</div><div class="line">exec $&#123;CATALINA_HOME&#125;/bin/catalina.sh run</div></pre></td></tr></table></figure>
<p>保存后接下来就开始构建docker镜像文件</p>
<h2 id="构建docker镜像文件"><a href="#构建docker镜像文件" class="headerlink" title="构建docker镜像文件"></a>构建docker镜像文件</h2><p>我们可以利用<code>docker build</code>来构建Docker镜像，<br>-t 设置tag名称, 命名规则registry/image:tag<br>. 表示使用当前目录下的Dockerfile文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker build -t tomcat:test .</div></pre></td></tr></table></figure>
<p>执行该命令后，Docker就会按照Dockerfile文件顺序执行，会有很多步骤，下面是输出日志：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">Sending build context to Docker daemon 403.1 MB</div><div class="line">Step 1/12 : FROM registry.cn-hangzhou.aliyuncs.com/repos_zyl/centos:0.0.1</div><div class="line"> ---&gt; e1e65df66640</div><div class="line">Step 2/12 : MAINTAINER mingshan &quot;walkerhan@126.com&quot;</div><div class="line"> ---&gt; Using cache</div><div class="line"> ---&gt; f030a7c09868</div><div class="line">Step 3/12 : ENV DEBIAN_FRONTEND noninteractive</div><div class="line"> ---&gt; Using cache</div><div class="line"> ---&gt; ef3f61db3034</div><div class="line">Step 4/12 : ENV CATALINA_HOME /tomcat</div><div class="line"> ---&gt; Running in 5145fe0de0d1</div><div class="line"> ---&gt; 9a4af98c3434</div><div class="line">Removing intermediate container 5145fe0de0d1</div><div class="line">Step 5/12 : ENV JAVA_HOME /jdk</div><div class="line"> ---&gt; Running in 8bac05b87945</div><div class="line"> ---&gt; f5b7eb8d180e</div><div class="line">Removing intermediate container 8bac05b87945</div><div class="line">Step 6/12 : ADD tomcat /tomcat</div><div class="line"> ---&gt; d68a1754c19e</div><div class="line">Removing intermediate container 29f7625a6b95</div><div class="line">Step 7/12 : ADD jdk /jdk</div><div class="line"> ---&gt; df1669bd68de</div><div class="line">Removing intermediate container dc7de6c936fa</div><div class="line">Step 8/12 : ADD run.sh /run.sh</div><div class="line"> ---&gt; 90a13284ec01</div><div class="line">Removing intermediate container 5bf2c6666a03</div><div class="line">Step 9/12 : RUN chmod +x /*.sh</div><div class="line"> ---&gt; Running in 7f22e7927ffb</div><div class="line"></div><div class="line"> ---&gt; 10fff91bfa16</div><div class="line">Removing intermediate container 7f22e7927ffb</div><div class="line">Step 10/12 : RUN chmod +x /tomcat/bin/*.sh</div><div class="line"> ---&gt; Running in 163f103fcc0a</div><div class="line"></div><div class="line"> ---&gt; da593ceeaa49</div><div class="line">Removing intermediate container 163f103fcc0a</div><div class="line">Step 11/12 : EXPOSE 8080</div><div class="line"> ---&gt; Running in d66d686928fe</div><div class="line"> ---&gt; e2d7f915335a</div><div class="line">Removing intermediate container d66d686928fe</div><div class="line">Step 12/12 : CMD /run.sh</div><div class="line"> ---&gt; Running in a7f9d1e9c9a0</div><div class="line"> ---&gt; a21030de3aac</div><div class="line">Removing intermediate container a7f9d1e9c9a0</div><div class="line">Successfully built a21030de3aac</div></pre></td></tr></table></figure>
<p>构建完成后，就可以启动容器啦</p>
<h3 id="启动容器"><a href="#启动容器" class="headerlink" title="启动容器"></a>启动容器</h3><p>我们利用<code>docker run</code>来新建并启动容器，这个命令有很多参数，-d: 后台运行容器，并返回容器ID；-p: 端口映射，格式为：主机(宿主)端口:容器端口</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker run -d -p 11001:8080 tomcat:test</div></pre></td></tr></table></figure>
<p>然后使用 <code>docker ps</code> 命令查看正在运行的容器，如下图所示：</p>
<p><img src="/images/docker-tomcat-ps.png" alt="image"></p>
<h3 id="开启端口"><a href="#开启端口" class="headerlink" title="开启端口"></a>开启端口</h3><p>如果让外网访问的话，需要开放11001端口，在CentOS7中，可以利用firewall-cmd来开放端口</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">#开放11001端口  permanent为永久开放</div><div class="line">firewall-cmd --zone=public --add-port=11001/tcp --permanent</div><div class="line">#重新读取配置</div><div class="line">firewall-cmd --reload</div><div class="line">#查看全部开放端口</div><div class="line">firewall-cmd --list-all</div></pre></td></tr></table></figure>
<p>接下来就可在浏览器中看到Tomcat界面了，大功告成！</p>
<p><img src="/images/docke-tomcat-showpage.png" alt="image"></p>
<h3 id="镜像保存为本地离线文件"><a href="#镜像保存为本地离线文件" class="headerlink" title="镜像保存为本地离线文件"></a>镜像保存为本地离线文件</h3><p>将docker image保存为离线的本地文件，执行<code>docker save image_name &gt; ./save.tar</code>或者 <code>docker save -o filepath image_name</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">[root@VM_0_6_centos docker-tocmat]# docker images</div><div class="line">REPOSITORY                                           TAG                 IMAGE ID            CREATED             SIZE</div><div class="line">tomcat                                               test                a21030de3aac        2 hours ago         593 MB</div><div class="line">registry.cn-hangzhou.aliyuncs.com/repos_zyl/centos   0.0.1               e1e65df66640        19 months ago       192 MB</div><div class="line">[root@VM_0_6_centos docker-tocmat]# docker save a21030de3aac &gt; ./up_tomcat.tar</div><div class="line">[root@VM_0_6_centos docker-tocmat]# ls</div><div class="line">Dockerfile  jdk  run.sh  tomcat  up_tomcat.tar</div></pre></td></tr></table></figure>
<h3 id="其他操作"><a href="#其他操作" class="headerlink" title="其他操作"></a>其他操作</h3><ol>
<li>停止容器</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker stop tomcat:test</div></pre></td></tr></table></figure>
<ol>
<li>启动容器</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker start tomcat:test</div></pre></td></tr></table></figure>
<ol>
<li>删除容器</li>
</ol>
<p>删除一个容器：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker rm 278636f577a6</div></pre></td></tr></table></figure></p>
<p>停用全部运行中的容器:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker stop $(docker ps -q)</div></pre></td></tr></table></figure>
<p>删除全部容器：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker rm $(docker ps -aq)</div></pre></td></tr></table></figure>
<p>一条命令实现停用并删除容器：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker stop $(docker ps -q) &amp; docker rm $(docker ps -aq)</div></pre></td></tr></table></figure>
<ol>
<li>删除镜像</li>
</ol>
<p>删除镜像需要先删除使用该镜像的容器，然后再删除镜像</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker rmi 3ae3626adcfa</div></pre></td></tr></table></figure>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a href="https://www.jianshu.com/p/369e75f6303b" target="_blank" rel="external">https://www.jianshu.com/p/369e75f6303b</a></li>
<li><a href="https://www.cnblogs.com/zhouyalei/p/6390963.html" target="_blank" rel="external">https://www.cnblogs.com/zhouyalei/p/6390963.html</a></li>
<li><a href="http://www.dockerinfo.net/docker%e5%ae%b9%e5%99%a8-2" target="_blank" rel="external">http://www.dockerinfo.net/docker%e5%ae%b9%e5%99%a8-2</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在看Docker，对一个事物由陌生到熟悉需要一个过程，而这个过程需要从动手实践开始，下面记录一下我从零开始构建centos7+jdk8+tomcat8.5的docker镜像。&lt;/p&gt;
    
    </summary>
    
      <category term="Docker" scheme="http://yoursite.com/categories/Docker/"/>
    
    
      <category term="Docker" scheme="http://yoursite.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Hashtable结构分析</title>
    <link href="http://yoursite.com/2018/07/16/Hashtable%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2018/07/16/Hashtable结构分析/</id>
    <published>2018-07-15T16:00:00.000Z</published>
    <updated>2018-07-16T14:50:35.731Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>哈希表（Hash Table，也叫散列表），是存储键值对（key-value）的数据结构，主要利用hash算法将key映射到表中，以便加快查找速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。对于数组而言，查找数据容易，但添加删除数据比较慢；对于链表来说，添加删除数据容易，但查找数据比较慢，所以哈希表结合数据和链表来实现数据快速的存取。</p>
<p>哈希表的实现主要需要解决两个问题，哈希函数和冲突解决。</p>
<a id="more"></a>
<h2 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h2><p>在哈希表内部，使用桶（bucket）来保存键值对，数组索引即为桶号，哈希函数决定了给定的键存于散列表的哪个桶中，例如下面的函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">index = f(key, array_size)</div></pre></td></tr></table></figure>
<p>其中需要先通过key计算hash值，然后再利用算法计算出index，在维基百科中，有如下介绍：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">hash = hashfunc(key)</div><div class="line">index = hash % array_size</div></pre></td></tr></table></figure>
<p>哈希函数和计算index的算法可以有很多种实现，但最终目的是能够均匀并独立地将所有的键散布在数组范围内。</p>
<h2 id="冲突解决"><a href="#冲突解决" class="headerlink" title="冲突解决"></a>冲突解决</h2><p>即使采用的哈希算法能够使键值均匀分布，但避免不了“碰撞”的出现，当两个不同的键值产生了相同值，这时就需要解决冲突。</p>
<p>解决冲突有很多种方法，比如拉链法和开地址法，这里主要分析拉链法的具体实现。</p>
<p>采用拉链法的哈希表，每个桶里都存放了一个链表。初始时所有链表均为空，当一个键被散列到一个桶时，这个键就成为相应桶中链表的首结点，之后若再有一个键被散列到这个桶（即发生碰撞），第二个键就会成为链表的第二个结点，以此类推。采用拉链法解决冲突的哈希表如下图所示：</p>
<p><img src="https://github.com/ZZULI-TECH/interview/blob/master/images/hashtable.png?raw=true" alt="image"></p>
<h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><p>对于哈希表而言，主要有增，删，获取操作，我们先来定义一个接口：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</div><div class="line">      <span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K k,V v)</span></span>;</div><div class="line">      <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(K k)</span></span>;</div><div class="line">      <span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(K k)</span></span>;</div><div class="line"></div><div class="line">      <span class="class"><span class="keyword">interface</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span>&#123;</div><div class="line">          <span class="function"><span class="keyword">public</span> K <span class="title">getKey</span><span class="params">()</span></span>;</div><div class="line">          <span class="function"><span class="keyword">public</span> V <span class="title">getValue</span><span class="params">()</span></span>;</div><div class="line">      &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在Map接口中，定义了三个方法<code>put</code>，<code>get</code>，<code>remove</code>三个方法，同时定义了一个内部接口Entry，用来表示key-value结构。</p>
<p>接下来我们就采用拉链法来实现上面的接口。首先定义一下常量，成员变量以及在类的构造函数初始化一些数据代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 默认大小</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">16</span>;</div><div class="line"><span class="comment">// 默认负载因子</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</div><div class="line"><span class="comment">// 定义数组大小</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">int</span> length;</div><div class="line"><span class="comment">// 扩容标准 所使用的数组数量/数组长度 &gt; 0.75</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">float</span> loadFactor;</div><div class="line"><span class="comment">// 使用数组位置的总量</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">int</span> useSize;</div><div class="line"><span class="comment">// 定义Map 骨架 只要数组</span></div><div class="line"><span class="keyword">private</span> Entry&lt;K, V&gt;[] table = <span class="keyword">null</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMapDemo</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMapDemo</span><span class="params">(<span class="keyword">int</span> length, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (length &lt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"参数不能为负数"</span> + length);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor)) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"扩容标准必须为大于0的数字"</span> + length);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">this</span>.length = length;</div><div class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;</div><div class="line">    <span class="keyword">this</span>.table = (Entry&lt;K, V&gt;[])<span class="keyword">new</span> Entry[length];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接下来下类的内存实现静态内存类Entry，由于采用了拉链法，所以需要用链表来存储具有相同的index的节点。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">static class Entry&lt;K, V&gt; implements Map.Entry&lt;K, V&gt; &#123;</div><div class="line">    K k;</div><div class="line">    V v;</div><div class="line">    Entry&lt;K, V&gt; next;</div><div class="line"></div><div class="line">    public Entry(K k,V v,Entry&lt;K, V&gt; next)&#123;</div><div class="line">        this.k = k;</div><div class="line">        this.v = v;</div><div class="line">        this.next = next;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public K getKey() &#123;</div><div class="line">        return k;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public V getValue() &#123;</div><div class="line">        return v;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="hash算法"><a href="#hash算法" class="headerlink" title="hash算法"></a>hash算法</h3><p>那么如何实现hash算法呢？这个问题有点复杂，还是先看看jdk8中HashMap是如何实现的，下面是部分代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 用来通过自身数组的长度和key来确定存储位置</div><div class="line"> * <span class="doctag">@param</span> k</div><div class="line"> * <span class="doctag">@param</span> length</div><div class="line"> * <span class="doctag">@return</span></div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getIndex</span><span class="params">(K k, <span class="keyword">int</span> length)</span> </span>&#123;</div><div class="line">    <span class="comment">// hashCode 与运算</span></div><div class="line">    <span class="keyword">int</span> m = length - <span class="number">1</span>;</div><div class="line">    <span class="keyword">int</span> index = hash(k.hashCode()) &amp; m;</div><div class="line"></div><div class="line">    <span class="comment">// 三元运算符处理</span></div><div class="line">    <span class="keyword">return</span> index &gt;= <span class="number">0</span> ? index : -index;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * jdk1.8中hashmap的hash算法</div><div class="line"> * <span class="doctag">@param</span> hashCode</div><div class="line"> * <span class="doctag">@return</span></div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> h;</div><div class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从代码中可以看出，要获取索引位置需要以下步骤：</p>
<p>取 key 的 hashCode 值、高位运算、取模运算。</p>
<p>其中，key.hashCode()是Key自带的hashCode()方法，返回一个int类型的散列值。我们知道，32位带符号的int表值范围从-2147483648到2147483648。这样只要hash函数松散的话，一般是很难发生碰撞的，因为HashMap的初始容量只有16。但是这样的散列值我们是不能直接拿来用的。用之前需要对数组的长度取模运算。得到余数才是索引值。具体参看<a href="http://ibat.xyz/2017/02/16/%E6%B5%85%E8%81%8AHashMap%E4%B8%AD%E7%9A%84hash%E7%AE%97%E6%B3%95/" target="_blank" rel="external">浅谈HashMap中的hash算法</a></p>
<h3 id="快存"><a href="#快存" class="headerlink" title="快存"></a>快存</h3><p>将key-value数据存入到哈希表表中，首先需要判断是否需要扩容，这里需要利用负载因子(loadFactor)来判断，默认扩容两倍。然后利用哈希算法来获取索引位置index，判断当前位置是否有结点，如果没有结点，就将当前结点作为这个桶中链表的头结点；如果有节点，那么就将其放在链表的末尾。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 快存</div><div class="line"> */</div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K k, V v)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (useSize &gt; <span class="keyword">this</span>.length * <span class="keyword">this</span>.loadFactor) &#123;</div><div class="line">        <span class="comment">// 需要扩容</span></div><div class="line">        up2Size();</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 通过key来存储位置</span></div><div class="line">    <span class="keyword">int</span> index = getIndex(k, table.length);</div><div class="line">    Entry&lt;K,V&gt; entry = table[index];</div><div class="line">    <span class="keyword">if</span> (entry == <span class="keyword">null</span>) &#123;</div><div class="line">        table[index] = <span class="keyword">new</span> Entry&lt;K, V&gt;(k, v, <span class="keyword">null</span>);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (entry != <span class="keyword">null</span>) &#123;</div><div class="line">        table[index] = <span class="keyword">new</span> Entry&lt;K, V&gt;(k, v, entry);</div><div class="line">    &#125;</div><div class="line">    useSize++;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> table[index].getValue();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>扩容代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 增大容量，这里扩容两倍</div><div class="line"> */</div><div class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">up2Size</span><span class="params">()</span> </span>&#123;</div><div class="line">    Entry&lt;K, V&gt;[] newTable = (Entry&lt;K,V&gt;[])<span class="keyword">new</span> Entry[<span class="number">2</span> * <span class="keyword">this</span>.length];</div><div class="line">    <span class="comment">// 原来数组有非常多的Entry对象，由于Entry对象散列，需要再次散列</span></div><div class="line">    againHash(newTable);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 存储的对象存储到新数组中（再次散列）</div><div class="line"> * <span class="doctag">@param</span> newTable</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">againHash</span><span class="params">(Entry&lt;K, V&gt;[] newTable)</span> </span>&#123;</div><div class="line">    <span class="comment">// 将数组里面的对象封装到List</span></div><div class="line">    List&lt;Entry&lt;K, V&gt;&gt; entryList = <span class="keyword">new</span> ArrayList&lt;Entry&lt;K, V&gt;&gt;();</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; table.length; i++) &#123;</div><div class="line">        <span class="keyword">if</span> (table[i] == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">continue</span>;</div><div class="line">        &#125;</div><div class="line">        foundEntryByNext(table[i], entryList);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (entryList.size() &gt; <span class="number">0</span>) &#123;</div><div class="line">        useSize = <span class="number">0</span>;</div><div class="line">        <span class="keyword">this</span>.length = <span class="number">2</span> * <span class="keyword">this</span>.length;</div><div class="line">        table = newTable;</div><div class="line">        <span class="keyword">for</span> (Entry&lt;K, V&gt; entry : entryList) &#123;</div><div class="line">            <span class="keyword">if</span> (entry.next != <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="comment">//形成链表关系取消掉</span></div><div class="line">                entry.next = <span class="keyword">null</span>;</div><div class="line">            &#125;</div><div class="line">            put(entry.getKey(), entry.getValue());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 寻找entry对象</div><div class="line"> * <span class="doctag">@param</span> entry</div><div class="line"> * <span class="doctag">@param</span> entryList</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">foundEntryByNext</span><span class="params">(Entry&lt;K, V&gt; entry, List&lt;Entry&lt;K, V&gt;&gt; entryList)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (entry != <span class="keyword">null</span> &amp;&amp; entry.next != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="comment">// 说明entry对象已经形成链表结构</span></div><div class="line">        entryList.add(entry);</div><div class="line">        <span class="comment">// 需要递归</span></div><div class="line">        foundEntryByNext(entry.next, entryList);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        entryList.add(entry);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="快取"><a href="#快取" class="headerlink" title="快取"></a>快取</h3><p>从哈希表中根据key来取出元素比较简单，利用哈希算法计算出索引位置index，然后遍历链表即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 快取</div><div class="line"> */</div><div class="line">@Override</div><div class="line">public V get(K k) &#123;</div><div class="line">    int index = getIndex(k, table.length);</div><div class="line">    if (table[index] == null) &#123;</div><div class="line">        throw new NullPointerException();</div><div class="line">    &#125;</div><div class="line">    return findValueByEntryKey(k, table[index]);</div><div class="line">&#125;</div><div class="line"></div><div class="line">private V findValueByEntryKey(K k, Entry&lt;K, V&gt; entry) &#123;</div><div class="line">    Entry&lt;K, V&gt; e = entry;</div><div class="line">    while (e != null) &#123;</div><div class="line">        if (k == e.getKey() || k.equals(e.getKey()))</div><div class="line">            return e.getValue();</div><div class="line">        e = e.next;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return null;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="移除"><a href="#移除" class="headerlink" title="移除"></a>移除</h3><p>根据key将元素从哈希表中移除需要考虑以下几种情况：</p>
<ol>
<li>该节点为链表头结点</li>
<li>该节点为链表中间节点</li>
<li>该节点为链表尾节点</li>
</ol>
<p>然后按照上面的情况分别处理即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 移除</div><div class="line"> * <span class="doctag">@param</span> k</div><div class="line"> */</div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(K k)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> index = getIndex(k, table.length);</div><div class="line">    Entry&lt;K, V&gt; e = table[index];</div><div class="line">    Entry&lt;K, V&gt; prev = <span class="keyword">null</span>;</div><div class="line">    </div><div class="line">    <span class="keyword">while</span> (e != <span class="keyword">null</span> &amp;&amp; (!(k == e.getKey() ||</div><div class="line">            (k != <span class="keyword">null</span> &amp;&amp; k.equals(e.getKey()))))) &#123;</div><div class="line">        prev = e;</div><div class="line">        e = e.next;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    Entry&lt;K, V&gt; next = e.next;</div><div class="line">    <span class="keyword">if</span> (prev != <span class="keyword">null</span> &amp;&amp; next != <span class="keyword">null</span>) &#123;</div><div class="line">        prev.next = next;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (prev != <span class="keyword">null</span> &amp;&amp; next == <span class="keyword">null</span>) &#123;</div><div class="line">        prev.next = <span class="keyword">null</span>;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (prev == <span class="keyword">null</span> &amp;&amp; next != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="comment">// Node is the head</span></div><div class="line">        table[index] = next;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// prev==null &amp;&amp; next==null</span></div><div class="line">        table[index] = <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    useSize--;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> e.v;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://en.wikipedia.org/wiki/Hash_table" target="_blank" rel="external">Hash table维基百科</a><br><br><a href="https://www.cnblogs.com/absfree/p/5508570.html" target="_blank" rel="external">散列表的基本原理与实现</a><br><br><a href="http://ibat.xyz/2017/02/16/%E6%B5%85%E8%81%8AHashMap%E4%B8%AD%E7%9A%84hash%E7%AE%97%E6%B3%95/" target="_blank" rel="external">浅谈HashMap中的hash算法</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;哈希表（Hash Table，也叫散列表），是存储键值对（key-value）的数据结构，主要利用hash算法将key映射到表中，以便加快查找速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。对于数组而言，查找数据容易，但添加删除数据比较慢；对于链表来说，添加删除数据容易，但查找数据比较慢，所以哈希表结合数据和链表来实现数据快速的存取。&lt;/p&gt;
&lt;p&gt;哈希表的实现主要需要解决两个问题，哈希函数和冲突解决。&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="哈希表" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="哈希表" scheme="http://yoursite.com/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>JDK动态代理实现原理</title>
    <link href="http://yoursite.com/2018/07/10/JDK%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2018/07/10/JDK动态代理实现原理/</id>
    <published>2018-07-09T16:00:00.000Z</published>
    <updated>2018-08-22T15:20:13.232Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>平时接触动态代理比较多，例如Spring等框架如何使用了动态代理经常听到，本文主要介绍JDK动态代理的基本实现原理(JDK8版本)，当了解了这些实现细节后，再次使用动态代理就会十分容易和清楚，知其然也知其所以然。</p>
<a id="more"></a>
<h3 id="动态代理Demo"><a href="#动态代理Demo" class="headerlink" title="动态代理Demo"></a>动态代理Demo</h3><p>先来看一下利用JDK动态代理写的Demo，下面会根据这个Demo进行分析</p>
<p>首先定义一个接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Calculator</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sub</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">mul</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">div</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后是上面接口的实现类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CalculatorImpl</span> <span class="keyword">implements</span> <span class="title">Calculator</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</div><div class="line">        System.out.println(a+b);</div><div class="line">        <span class="keyword">return</span> a+b;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sub</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> a-b;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">mul</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> a*b;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">div</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> a/b;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>现在有个需求，就是在每个方法执行前后都实现一段逻辑，这个时候就要用到JDK的动态代理了。</p>
<p>我们首先定义一个类实现<code>InvocationHandler</code>接口，将要代理的对象通过构造方法传入，并实现<code>invoke</code>方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyProxyHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">//要代理的对象</span></div><div class="line">    <span class="keyword">private</span> Calculator target;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyProxyHandler</span><span class="params">(Calculator h)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.target = h;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line">        <span class="comment">//获取参数</span></div><div class="line">        System.out.println(<span class="string">"beginWith---方法的参数是--"</span> + Arrays.asList(args));</div><div class="line"></div><div class="line">        before();</div><div class="line">        Object result = method.invoke(target,args);</div><div class="line">        after();</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 前置</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"before---"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 后置</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"after---"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最后我们利用JDK提供的Proxy类来实现我们想要的功能</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * jdk动态代理测试</div><div class="line"> * <span class="doctag">@author</span> mingshan</div><div class="line"> *</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">       Calculator target = <span class="keyword">new</span> CalculatorImpl();</div><div class="line">       Calculator proxy = (Calculator) Proxy.newProxyInstance(Calculator.class.getClassLoader(),</div><div class="line">               <span class="keyword">new</span> Class&lt;?&gt;[]&#123;Calculator.class&#125;,</div><div class="line">               <span class="keyword">new</span> MyProxyHandler(target));</div><div class="line"></div><div class="line">       proxy.add(<span class="number">1</span>, <span class="number">2</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="具体实现流程"><a href="#具体实现流程" class="headerlink" title="具体实现流程"></a>具体实现流程</h3><p>动态代理之所以被称为动态代理，那是因为代理类是在运行过程中被Java动态生成的，我们可以看到这个被生成的代理类，需要在运行运行配置加上<code>-Dsun.misc.ProxyGenerator.saveGeneratedFiles=true</code>这个虚拟机参数，那么就会在当前项目<code>com.sun.proxy</code>包路径下生成<code>$Proxy0.class</code>这个class文件，其中文件名的数字是可变的。</p>
<p><img src="https://github.com/ZZULI-TECH/interview/blob/master/images/dynamic-proxy-vm-options.png?raw=true" alt="image"></p>
<p>代理类生成的过程主要包括两部分：</p>
<ul>
<li>代理类字节码生成</li>
<li>把字节码通过传入的类加载器加载到虚拟机中</li>
</ul>
<p>我们首先从Proxy类的newProxyInstance方法入手，开始分析实现流程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">newProxyInstance</span><span class="params">(ClassLoader loader,</span></span></div><div class="line">                                      Class&lt;?&gt;[] interfaces,</div><div class="line">                                      InvocationHandler h)</div><div class="line">    <span class="keyword">throws</span> IllegalArgumentException</div><div class="line">&#123;</div><div class="line">   <span class="comment">// 检查空指针异常</span></div><div class="line">    Objects.requireNonNull(h);</div><div class="line"></div><div class="line">    <span class="keyword">final</span> Class&lt;?&gt;[] intfs = interfaces.clone();</div><div class="line">    <span class="comment">// 安全检查</span></div><div class="line">    <span class="keyword">final</span> SecurityManager sm = System.getSecurityManager();</div><div class="line">    <span class="keyword">if</span> (sm != <span class="keyword">null</span>) &#123;</div><div class="line">        checkProxyAccess(Reflection.getCallerClass(), loader, intfs);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 生成代理类</span></div><div class="line">    Class&lt;?&gt; cl = getProxyClass0(loader, intfs);</div><div class="line"></div><div class="line">    <span class="comment">/*</span></div><div class="line">     * Invoke its constructor with the designated invocation handler.</div><div class="line">     */</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">if</span> (sm != <span class="keyword">null</span>) &#123;</div><div class="line">            checkNewProxyPermission(Reflection.getCallerClass(), cl);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">final</span> Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams);</div><div class="line">        <span class="keyword">final</span> InvocationHandler ih = h;</div><div class="line">        <span class="keyword">if</span> (!Modifier.isPublic(cl.getModifiers())) &#123;</div><div class="line">            AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Void&gt;() &#123;</div><div class="line">                <span class="function"><span class="keyword">public</span> Void <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                    cons.setAccessible(<span class="keyword">true</span>);</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> cons.newInstance(<span class="keyword">new</span> Object[]&#123;h&#125;);</div><div class="line">    &#125; <span class="keyword">catch</span> (IllegalAccessException|InstantiationException e) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(e.toString(), e);</div><div class="line">    &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</div><div class="line">        Throwable t = e.getCause();</div><div class="line">        <span class="keyword">if</span> (t <span class="keyword">instanceof</span> RuntimeException) &#123;</div><div class="line">            <span class="keyword">throw</span> (RuntimeException) t;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(t.toString(), t);</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(e.toString(), e);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>newProxyInstance</code>方法需要三个参数，分别是类加载器，接口类型的数组和自定义的InvocationHandler。首选会检测空指针异常和安全检查，然后调用<code>getProxyClass0</code>方法，<code>getProxyClass0</code>源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> Class&lt;?&gt; getProxyClass0(ClassLoader loader,</div><div class="line">                                       Class&lt;?&gt;... interfaces) &#123;</div><div class="line">    <span class="keyword">if</span> (interfaces.length &gt; <span class="number">65535</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"interface limit exceeded"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// If the proxy class defined by the given loader implementing</span></div><div class="line">    <span class="comment">// the given interfaces exists, this will simply return the cached copy;</span></div><div class="line">    <span class="comment">// otherwise, it will create the proxy class via the ProxyClassFactory</span></div><div class="line">    <span class="keyword">return</span> proxyClassCache.get(loader, interfaces);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>代码里面的注释很清楚，如果实现当前接口的代理类存在，直接从缓存中返回，如果不存在，则通过ProxyClassFactory来创建。这里可以明显看到有对interface接口数量的限制，不能超过65535。其中proxyClassCache具体初始化信息如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">proxyClassCache = <span class="keyword">new</span> WeakCache&lt;&gt;(<span class="keyword">new</span> KeyFactory(), <span class="keyword">new</span> ProxyClassFactory());</div></pre></td></tr></table></figure>
<p>其中创建代理类的具体逻辑是通过ProxyClassFactory的apply方法来创建的，ProxyClassFactory类中还包含代理类名称生成相关的两个静态常量，源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// prefix for all proxy class names</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String proxyClassNamePrefix = <span class="string">"$Proxy"</span>;</div><div class="line"></div><div class="line"><span class="comment">// next number to use for generation of unique proxy class names</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicLong nextUniqueNumber = <span class="keyword">new</span> AtomicLong();</div><div class="line"></div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="keyword">public</span> Class&lt;?&gt; apply(ClassLoader loader, Class&lt;?&gt;[] interfaces) &#123;</div><div class="line"></div><div class="line">    Map&lt;Class&lt;?&gt;, Boolean&gt; interfaceSet = <span class="keyword">new</span> IdentityHashMap&lt;&gt;(interfaces.length);</div><div class="line">    <span class="keyword">for</span> (Class&lt;?&gt; intf : interfaces) &#123;</div><div class="line">        <span class="comment">/*</span></div><div class="line">         * Verify that the class loader resolves the name of this</div><div class="line">         * interface to the same Class object.</div><div class="line">         */</div><div class="line">        Class&lt;?&gt; interfaceClass = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            interfaceClass = Class.forName(intf.getName(), <span class="keyword">false</span>, loader);</div><div class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (interfaceClass != intf) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</div><div class="line">                intf + <span class="string">" is not visible from class loader"</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">/*</span></div><div class="line">         * Verify that the Class object actually represents an</div><div class="line">         * interface.</div><div class="line">         */</div><div class="line">        <span class="keyword">if</span> (!interfaceClass.isInterface()) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</div><div class="line">                interfaceClass.getName() + <span class="string">" is not an interface"</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">/*</span></div><div class="line">         * Verify that this interface is not a duplicate.</div><div class="line">         */</div><div class="line">        <span class="keyword">if</span> (interfaceSet.put(interfaceClass, Boolean.TRUE) != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</div><div class="line">                <span class="string">"repeated interface: "</span> + interfaceClass.getName());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    String proxyPkg = <span class="keyword">null</span>;     <span class="comment">// package to define proxy class in</span></div><div class="line">    <span class="keyword">int</span> accessFlags = Modifier.PUBLIC | Modifier.FINAL;</div><div class="line"></div><div class="line">    <span class="comment">/*</span></div><div class="line">     * Record the package of a non-public proxy interface so that the</div><div class="line">     * proxy class will be defined in the same package.  Verify that</div><div class="line">     * all non-public proxy interfaces are in the same package.</div><div class="line">     */</div><div class="line">    <span class="keyword">for</span> (Class&lt;?&gt; intf : interfaces) &#123;</div><div class="line">        <span class="keyword">int</span> flags = intf.getModifiers();</div><div class="line">        <span class="keyword">if</span> (!Modifier.isPublic(flags)) &#123;</div><div class="line">            accessFlags = Modifier.FINAL;</div><div class="line">            String name = intf.getName();</div><div class="line">            <span class="keyword">int</span> n = name.lastIndexOf(<span class="string">'.'</span>);</div><div class="line">            String pkg = ((n == -<span class="number">1</span>) ? <span class="string">""</span> : name.substring(<span class="number">0</span>, n + <span class="number">1</span>));</div><div class="line">            <span class="keyword">if</span> (proxyPkg == <span class="keyword">null</span>) &#123;</div><div class="line">                proxyPkg = pkg;</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!pkg.equals(proxyPkg)) &#123;</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</div><div class="line">                    <span class="string">"non-public interfaces from different packages"</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (proxyPkg == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="comment">// if no non-public proxy interfaces, use com.sun.proxy package</span></div><div class="line">        proxyPkg = ReflectUtil.PROXY_PACKAGE + <span class="string">"."</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/*</span></div><div class="line">     * Choose a name for the proxy class to generate.</div><div class="line">     */</div><div class="line">    <span class="keyword">long</span> num = nextUniqueNumber.getAndIncrement();</div><div class="line">    String proxyName = proxyPkg + proxyClassNamePrefix + num;</div><div class="line"></div><div class="line">    <span class="comment">/*</span></div><div class="line">     * Generate the specified proxy class.</div><div class="line">     */</div><div class="line">    <span class="keyword">byte</span>[] proxyClassFile = ProxyGenerator.generateProxyClass(</div><div class="line">        proxyName, interfaces, accessFlags);</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">return</span> defineClass0(loader, proxyName,</div><div class="line">                            proxyClassFile, <span class="number">0</span>, proxyClassFile.length);</div><div class="line">    &#125; <span class="keyword">catch</span> (ClassFormatError e) &#123;</div><div class="line">        <span class="comment">/*</span></div><div class="line">         * A ClassFormatError here means that (barring bugs in the</div><div class="line">         * proxy class generation code) there was some other</div><div class="line">         * invalid aspect of the arguments supplied to the proxy</div><div class="line">         * class creation (such as virtual machine limitations</div><div class="line">         * exceeded).</div><div class="line">         */</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(e.toString());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>apply方法需要两个参数，类加载器和接口类型的数组。该方法包含验证类加载器和接口相关逻辑，包名的创建逻辑，调用<code>ProxyGenerator. generateProxyClass</code>生成代理类，把代理类字节码加载到JVM。</p>
<ol>
<li>包名默认是<code>com.sun.proxy</code>，如果被代理类是 non-public proxy interface ，则用和被代理类接口一样的包名，类名默认是$Proxy 加上一个自增的整数值，如$Proxy0，$Proxy1。</li>
<li>包名类名准备好后，就是通过<code>ProxyGenerator.generateProxyClass</code>根据具体传入的接口创建代理字节码，<code>-Dsun.misc.ProxyGenerator.saveGeneratedFiles=true</code> 这个VM参数就是在该方法起到作用，如果为true则保存字节码到磁盘。代理类中，所有的代理方法逻辑都一样都是调用invocationHander的invoke方法，这个我们可以看后面具体代理反编译结果。</li>
<li>把字节码通过传入的类加载器加载到JVM中: defineClass0(loader, proxyName,proxyClassFile, 0, proxyClassFile.length);。</li>
</ol>
<p>我们继续来看看<code>generateProxyClass</code>方法是如何实现的，下面是该类的源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] generateProxyClass(<span class="keyword">final</span> String var0, Class&lt;?&gt;[] var1, <span class="keyword">int</span> var2) &#123;</div><div class="line">    ProxyGenerator var3 = <span class="keyword">new</span> ProxyGenerator(var0, var1, var2);</div><div class="line">    <span class="comment">// 生成代理类字节码文件的真正方法</span></div><div class="line">    <span class="keyword">final</span> <span class="keyword">byte</span>[] var4 = var3.generateClassFile();</div><div class="line">    <span class="comment">// 保存文件操作</span></div><div class="line">    <span class="keyword">if</span> (saveGeneratedFiles) &#123;</div><div class="line">        AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Void&gt;() &#123;</div><div class="line">            <span class="function"><span class="keyword">public</span> Void <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    <span class="keyword">int</span> var1 = var0.lastIndexOf(<span class="number">46</span>);</div><div class="line">                    Path var2;</div><div class="line">                    <span class="keyword">if</span> (var1 &gt; <span class="number">0</span>) &#123;</div><div class="line">                        Path var3 = Paths.get(var0.substring(<span class="number">0</span>, var1).replace(<span class="string">'.'</span>, File.separatorChar));</div><div class="line">                        Files.createDirectories(var3);</div><div class="line">                        var2 = var3.resolve(var0.substring(var1 + <span class="number">1</span>, var0.length()) + <span class="string">".class"</span>);</div><div class="line">                    &#125; <span class="keyword">else</span> &#123;</div><div class="line">                        var2 = Paths.get(var0 + <span class="string">".class"</span>);</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    Files.write(var2, var4, <span class="keyword">new</span> OpenOption[<span class="number">0</span>]);</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">                &#125; <span class="keyword">catch</span> (IOException var4x) &#123;</div><div class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(<span class="string">"I/O exception saving generated file: "</span> + var4x);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> var4;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在<code>generateProxyClass</code>方法中，通过调用<code>ProxyGenerator</code>类的<code>generateClassFile</code>方法，来生成代理类字节码文件，然后保存文件。</p>
<p>接下来我们看看<code>generateClassFile</code>方法干了些什么，下面是该方法的源码（方法有点长~）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">byte</span>[] generateClassFile() &#123;</div><div class="line">    <span class="comment">// addProxyMethod系列方法就是将接口的方法和Object的hashCode,equals,toString方法添加到代理方法Map(proxyMethods),</span></div><div class="line">    <span class="comment">// 其中方法签名作为key,proxyMethod作为value</span></div><div class="line">    <span class="comment">// 后面经过反编译生成的代理类看出，hashCode，equals，toString这三个方法相当于从Object拿过来，</span></div><div class="line">    <span class="comment">// m0 = Class.forName("java.lang.Object").getMethod("hashCode", new Class[0]);</span></div><div class="line">    <span class="keyword">this</span>.addProxyMethod(hashCodeMethod, Object.class);</div><div class="line">    <span class="keyword">this</span>.addProxyMethod(equalsMethod, Object.class);</div><div class="line">    <span class="keyword">this</span>.addProxyMethod(toStringMethod, Object.class);</div><div class="line">    Class[] var1 = <span class="keyword">this</span>.interfaces;</div><div class="line">    <span class="keyword">int</span> var2 = var1.length;</div><div class="line"></div><div class="line">    <span class="keyword">int</span> var3;</div><div class="line">    Class var4;</div><div class="line">    <span class="comment">// 获得所有接口中的所有方法，并将方法添加到代理方法中</span></div><div class="line">    <span class="keyword">for</span>(var3 = <span class="number">0</span>; var3 &lt; var2; ++var3) &#123;</div><div class="line">        var4 = var1[var3];</div><div class="line">        Method[] var5 = var4.getMethods();</div><div class="line">        <span class="keyword">int</span> var6 = var5.length;</div><div class="line"></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> var7 = <span class="number">0</span>; var7 &lt; var6; ++var7) &#123;</div><div class="line">            Method var8 = var5[var7];</div><div class="line">            <span class="keyword">this</span>.addProxyMethod(var8, var4);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 迭代存储在map中的ProxyMethod</span></div><div class="line">    Iterator var11 = <span class="keyword">this</span>.proxyMethods.values().iterator();</div><div class="line"></div><div class="line">    List var12;</div><div class="line">    <span class="keyword">while</span>(var11.hasNext()) &#123;</div><div class="line">        var12 = (List)var11.next();</div><div class="line">        checkReturnTypes(var12);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    Iterator var15;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="comment">// 生成代理类的构造函数</span></div><div class="line">        <span class="keyword">this</span>.methods.add(<span class="keyword">this</span>.generateConstructor());</div><div class="line">        var11 = <span class="keyword">this</span>.proxyMethods.values().iterator();</div><div class="line"></div><div class="line">        <span class="keyword">while</span>(var11.hasNext()) &#123;</div><div class="line">            var12 = (List)var11.next();</div><div class="line">            var15 = var12.iterator();</div><div class="line"></div><div class="line">            <span class="keyword">while</span>(var15.hasNext()) &#123;</div><div class="line">                ProxyGenerator.ProxyMethod var16 = (ProxyGenerator.ProxyMethod)var15.next();</div><div class="line">                <span class="comment">// 向代理类添加字段</span></div><div class="line">                <span class="comment">// 将代理字段声明为Method，10为ACC_PRIVATE和ACC_STATAIC的与运算，表示该字段的修饰符为private static</span></div><div class="line">                <span class="comment">// 所以代理类的字段都是private static Method XXX</span></div><div class="line">                <span class="keyword">this</span>.fields.add(<span class="keyword">new</span> ProxyGenerator.FieldInfo(var16.methodFieldName, <span class="string">"Ljava/lang/reflect/Method;"</span>, <span class="number">10</span>));</div><div class="line">                <span class="comment">// 向代理类添加方法</span></div><div class="line">                <span class="keyword">this</span>.methods.add(var16.generateMethod());</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 为代理类生成静态代码块，对一些字段进行初始化</span></div><div class="line">        <span class="keyword">this</span>.methods.add(<span class="keyword">this</span>.generateStaticInitializer());</div><div class="line">    &#125; <span class="keyword">catch</span> (IOException var10) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(<span class="string">"unexpected I/O Exception"</span>, var10);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 限制方法和字段数量</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.methods.size() &gt; <span class="number">65535</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"method limit exceeded"</span>);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.fields.size() &gt; <span class="number">65535</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"field limit exceeded"</span>);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">this</span>.cp.getClass(dotToSlash(<span class="keyword">this</span>.className));</div><div class="line">        <span class="keyword">this</span>.cp.getClass(<span class="string">"java/lang/reflect/Proxy"</span>);</div><div class="line">        var1 = <span class="keyword">this</span>.interfaces;</div><div class="line">        var2 = var1.length;</div><div class="line"></div><div class="line">        <span class="keyword">for</span>(var3 = <span class="number">0</span>; var3 &lt; var2; ++var3) &#123;</div><div class="line">            var4 = var1[var3];</div><div class="line">            <span class="keyword">this</span>.cp.getClass(dotToSlash(var4.getName()));</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">this</span>.cp.setReadOnly();</div><div class="line">        ByteArrayOutputStream var13 = <span class="keyword">new</span> ByteArrayOutputStream();</div><div class="line">        DataOutputStream var14 = <span class="keyword">new</span> DataOutputStream(var13);</div><div class="line"></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            var14.writeInt(-<span class="number">889275714</span>);</div><div class="line">            var14.writeShort(<span class="number">0</span>);</div><div class="line">            var14.writeShort(<span class="number">49</span>);</div><div class="line">            <span class="keyword">this</span>.cp.write(var14);</div><div class="line">            var14.writeShort(<span class="keyword">this</span>.accessFlags);</div><div class="line">            var14.writeShort(<span class="keyword">this</span>.cp.getClass(dotToSlash(<span class="keyword">this</span>.className)));</div><div class="line">            var14.writeShort(<span class="keyword">this</span>.cp.getClass(<span class="string">"java/lang/reflect/Proxy"</span>));</div><div class="line">            var14.writeShort(<span class="keyword">this</span>.interfaces.length);</div><div class="line">            Class[] var17 = <span class="keyword">this</span>.interfaces;</div><div class="line">            <span class="keyword">int</span> var18 = var17.length;</div><div class="line"></div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> var19 = <span class="number">0</span>; var19 &lt; var18; ++var19) &#123;</div><div class="line">                Class var22 = var17[var19];</div><div class="line">                var14.writeShort(<span class="keyword">this</span>.cp.getClass(dotToSlash(var22.getName())));</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            var14.writeShort(<span class="keyword">this</span>.fields.size());</div><div class="line">            var15 = <span class="keyword">this</span>.fields.iterator();</div><div class="line"></div><div class="line">            <span class="keyword">while</span>(var15.hasNext()) &#123;</div><div class="line">                ProxyGenerator.FieldInfo var20 = (ProxyGenerator.FieldInfo)var15.next();</div><div class="line">                var20.write(var14);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            var14.writeShort(<span class="keyword">this</span>.methods.size());</div><div class="line">            var15 = <span class="keyword">this</span>.methods.iterator();</div><div class="line"></div><div class="line">            <span class="keyword">while</span>(var15.hasNext()) &#123;</div><div class="line">                ProxyGenerator.MethodInfo var21 = (ProxyGenerator.MethodInfo)var15.next();</div><div class="line">                var21.write(var14);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            var14.writeShort(<span class="number">0</span>);</div><div class="line">            <span class="keyword">return</span> var13.toByteArray();</div><div class="line">        &#125; <span class="keyword">catch</span> (IOException var9) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(<span class="string">"unexpected I/O Exception"</span>, var9);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>那么自定义的InvocationHandler是如何在代理中使用的呢？ 在上面的方法中向代理类添加方法调用了<code>generateMethod()</code>方法，所以这个添加方法的步骤就是在<code>generateMethod()</code>方法中实现的。<br>由于这个方法太长，这里就不贴全部代码了，方法里面有一段代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var9.writeShort(ProxyGenerator.<span class="keyword">this</span>.cp.getFieldRef(<span class="string">"java/lang/reflect/Proxy"</span>, <span class="string">"h"</span>, <span class="string">"Ljava/lang/reflect/InvocationHandler;"</span>));</div></pre></td></tr></table></figure>
<p>原来在代理方法中通过Proxy类引用了自定义InvocationHandler，由于通过Proxy的newProxyInstance方法将InvocationHandler传入，生成的代理类通过继承Proxy类，拿到InvocationHandler，<br>最后调用invoke方法来实现。</p>
<p>明白了JDK动态代理的大致流程，让我们来反编译下生成的代理类，反编译后的<code>$Proxy0.java</code>的代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div></pre></td><td class="code"><pre><div class="line">package com.sun.proxy;</div><div class="line"></div><div class="line">import java.lang.reflect.InvocationHandler;</div><div class="line">import java.lang.reflect.Method;</div><div class="line">import java.lang.reflect.Proxy;</div><div class="line">import java.lang.reflect.UndeclaredThrowableException;</div><div class="line">import me.mingshan.dy.Calculator;</div><div class="line"></div><div class="line">public final class $Proxy0 extends Proxy implements Calculator &#123;</div><div class="line"></div><div class="line">   private static Method m1;</div><div class="line">   private static Method m2;</div><div class="line">   private static Method m5;</div><div class="line">   private static Method m3;</div><div class="line">   private static Method m4;</div><div class="line">   private static Method m6;</div><div class="line">   private static Method m0;</div><div class="line"></div><div class="line"></div><div class="line">   public $Proxy0(InvocationHandler var1) throws  &#123;</div><div class="line">      super(var1);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public final boolean equals(Object var1) throws  &#123;</div><div class="line">      try &#123;</div><div class="line">         return ((Boolean)super.h.invoke(this, m1, new Object[]&#123;var1&#125;)).booleanValue();</div><div class="line">      &#125; catch (RuntimeException | Error var3) &#123;</div><div class="line">         throw var3;</div><div class="line">      &#125; catch (Throwable var4) &#123;</div><div class="line">         throw new UndeclaredThrowableException(var4);</div><div class="line">      &#125;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public final String toString() throws  &#123;</div><div class="line">      try &#123;</div><div class="line">         return (String)super.h.invoke(this, m2, (Object[])null);</div><div class="line">      &#125; catch (RuntimeException | Error var2) &#123;</div><div class="line">         throw var2;</div><div class="line">      &#125; catch (Throwable var3) &#123;</div><div class="line">         throw new UndeclaredThrowableException(var3);</div><div class="line">      &#125;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public final int mul(int var1, int var2) throws  &#123;</div><div class="line">      try &#123;</div><div class="line">         return ((Integer)super.h.invoke(this, m5, new Object[]&#123;Integer.valueOf(var1), Integer.valueOf(var2)&#125;)).intValue();</div><div class="line">      &#125; catch (RuntimeException | Error var4) &#123;</div><div class="line">         throw var4;</div><div class="line">      &#125; catch (Throwable var5) &#123;</div><div class="line">         throw new UndeclaredThrowableException(var5);</div><div class="line">      &#125;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public final int add(int var1, int var2) throws  &#123;</div><div class="line">      try &#123;</div><div class="line">         return ((Integer)super.h.invoke(this, m3, new Object[]&#123;Integer.valueOf(var1), Integer.valueOf(var2)&#125;)).intValue();</div><div class="line">      &#125; catch (RuntimeException | Error var4) &#123;</div><div class="line">         throw var4;</div><div class="line">      &#125; catch (Throwable var5) &#123;</div><div class="line">         throw new UndeclaredThrowableException(var5);</div><div class="line">      &#125;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public final int sub(int var1, int var2) throws  &#123;</div><div class="line">      try &#123;</div><div class="line">         return ((Integer)super.h.invoke(this, m4, new Object[]&#123;Integer.valueOf(var1), Integer.valueOf(var2)&#125;)).intValue();</div><div class="line">      &#125; catch (RuntimeException | Error var4) &#123;</div><div class="line">         throw var4;</div><div class="line">      &#125; catch (Throwable var5) &#123;</div><div class="line">         throw new UndeclaredThrowableException(var5);</div><div class="line">      &#125;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public final int div(int var1, int var2) throws  &#123;</div><div class="line">      try &#123;</div><div class="line">         return ((Integer)super.h.invoke(this, m6, new Object[]&#123;Integer.valueOf(var1), Integer.valueOf(var2)&#125;)).intValue();</div><div class="line">      &#125; catch (RuntimeException | Error var4) &#123;</div><div class="line">         throw var4;</div><div class="line">      &#125; catch (Throwable var5) &#123;</div><div class="line">         throw new UndeclaredThrowableException(var5);</div><div class="line">      &#125;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public final int hashCode() throws  &#123;</div><div class="line">      try &#123;</div><div class="line">         return ((Integer)super.h.invoke(this, m0, (Object[])null)).intValue();</div><div class="line">      &#125; catch (RuntimeException | Error var2) &#123;</div><div class="line">         throw var2;</div><div class="line">      &#125; catch (Throwable var3) &#123;</div><div class="line">         throw new UndeclaredThrowableException(var3);</div><div class="line">      &#125;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   static &#123;</div><div class="line">      try &#123;</div><div class="line">         m1 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;equals&quot;, new Class[]&#123;Class.forName(&quot;java.lang.Object&quot;)&#125;);</div><div class="line">         m2 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;toString&quot;, new Class[0]);</div><div class="line">         m5 = Class.forName(&quot;me.mingshan.dy.Calculator&quot;).getMethod(&quot;mul&quot;, new Class[]&#123;Integer.TYPE, Integer.TYPE&#125;);</div><div class="line">         m3 = Class.forName(&quot;me.mingshan.dy.Calculator&quot;).getMethod(&quot;add&quot;, new Class[]&#123;Integer.TYPE, Integer.TYPE&#125;);</div><div class="line">         m4 = Class.forName(&quot;me.mingshan.dy.Calculator&quot;).getMethod(&quot;sub&quot;, new Class[]&#123;Integer.TYPE, Integer.TYPE&#125;);</div><div class="line">         m6 = Class.forName(&quot;me.mingshan.dy.Calculator&quot;).getMethod(&quot;div&quot;, new Class[]&#123;Integer.TYPE, Integer.TYPE&#125;);</div><div class="line">         m0 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;hashCode&quot;, new Class[0]);</div><div class="line">      &#125; catch (NoSuchMethodException var2) &#123;</div><div class="line">         throw new NoSuchMethodError(var2.getMessage());</div><div class="line">      &#125; catch (ClassNotFoundException var3) &#123;</div><div class="line">         throw new NoClassDefFoundError(var3.getMessage());</div><div class="line">      &#125;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>代理类的结构大致如下:</p>
<ul>
<li>静态字段：被代理的接口所有方法都有一个对应的静态方法变量；</li>
<li>静态块：主要是通过反射初始化静态方法变量；</li>
<li>具体每个代理方法：逻辑都差不多就是<code>h.invoke</code>，主要是调用我们自定义的InvocatinoHandler逻辑，触发目标对象target上对应的方法;</li>
<li>构造函数：从这里传入我们InvocationHandler逻辑</li>
</ul>
<p>参考：<br><br><a href="http://www.importnew.com/23168.html" target="_blank" rel="external">JDK动态代理详解</a><br><br><a href="https://www.cnblogs.com/MOBIN/p/5597215.html" target="_blank" rel="external">深度剖析JDK动态代理机制</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;平时接触动态代理比较多，例如Spring等框架如何使用了动态代理经常听到，本文主要介绍JDK动态代理的基本实现原理(JDK8版本)，当了解了这些实现细节后，再次使用动态代理就会十分容易和清楚，知其然也知其所以然。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="动态代理" scheme="http://yoursite.com/tags/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>IllegalMonitorStateException异常分析</title>
    <link href="http://yoursite.com/2018/07/03/IllegalMonitorStateException%E5%BC%82%E5%B8%B8%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2018/07/03/IllegalMonitorStateException异常分析/</id>
    <published>2018-07-02T16:00:00.000Z</published>
    <updated>2018-07-03T16:13:20.869Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>当调用wait()， notify()等相关方法时，可能会产生这个异常，那么这个异常是什么意思呢？</p>
<a id="more"></a>
<p>抛出该异常原因:在Java中，每一个对象（Object/Class）都有一个监视器，当在同步代码块中，当前线程不是此监视器的所有者，也就是要在当前线程锁定对象，才能用锁定的对象此行这些方法，需要用到synchronized ，锁定什么对象就用什么对象来执行notify(), notifyAll(),wait(), wait(long), wait(long, int)操作，否则就会报IllegalMonitorStateException异常，原因异常。</p>
<p>下面这段代码就会抛出IllegalMonitorStateException异常，原因就是调用wait需要当前对象的监视器。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            ThreadTest.class.wait();</div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line"> </div><div class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">":"</span> + i);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> ThreadTest()).start();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>所以对于synchronized的使用来说，通常这样使用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">synchronized</span>(x) &#123;</div><div class="line">    x.notify();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>具体对于不同的监视对象而言，可以有以下几种考虑：</p>
<ol>
<li>锁定方法所对应的对象实例</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</div><div class="line">       <span class="keyword">this</span>.notify();</div><div class="line">       <span class="comment">// 或者直接写notify();</span></div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<ol>
<li>类锁</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">synchronized</span>(xx.class) &#123;</div><div class="line">       xx.notify();</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>锁定其他对象</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> Class Test&#123;</div><div class="line">    <span class="keyword">public</span> Object lock = <span class="keyword">new</span> Object();</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> method（）&#123;</div><div class="line">      <span class="keyword">synchronized</span> (lock) &#123;</div><div class="line">         lock.notify();</div><div class="line">      &#125; </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当调用wait()， notify()等相关方法时，可能会产生这个异常，那么这个异常是什么意思呢？&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="IllegalMonitorStateException" scheme="http://yoursite.com/tags/IllegalMonitorStateException/"/>
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>理解ThreadLocal</title>
    <link href="http://yoursite.com/2018/07/01/%E7%90%86%E8%A7%A3ThreadLocal/"/>
    <id>http://yoursite.com/2018/07/01/理解ThreadLocal/</id>
    <published>2018-06-30T16:00:00.000Z</published>
    <updated>2018-07-01T01:45:32.898Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>记得去年学习Spring MVC的时候自己学着写了一个小小的框架，用了一个AppContext来表示应用上下文，每个请求都应该有各自独立的AppContext，里面可以存储一些数据，比如数据库连接Connection等，此时考虑数据库的事务问题，即在一个线程内，一个事务的多个操作拿到的是一个Connection，该如何实现呢？此时就需要使用ThreadLocal来解决。</p>
<a id="more"></a>
<h3 id="ThreadLocal介绍"><a href="#ThreadLocal介绍" class="headerlink" title="ThreadLocal介绍"></a>ThreadLocal介绍</h3><p><strong>ThreadLocal能干啥？</strong></p>
<p>ThreadLocal是基于线程的一个本地变量的支持类，用户可以将对象与线程绑定，每一个线程都拥有一个自己的对象，例如对于上面的需求来说，可以将AppContext存入到ThreadLocal，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">public class AppContext &#123;</div><div class="line">    private static ThreadLocal&lt;AppContext&gt; appContextMap = new ThreadLocal&lt;AppContext&gt;();</div><div class="line">    private Map&lt;String, Object&gt; objects = new HashMap&lt;String, Object&gt;();</div><div class="line"></div><div class="line">    private AppContext() &#123;&#125;;</div><div class="line"></div><div class="line">    // 部分代码省略</div><div class="line">    </div><div class="line">    public void clear() &#123;</div><div class="line">        AppContext context = appContextMap.get();</div><div class="line">        if (context != null) &#123;</div><div class="line">            context.objects.clear();</div><div class="line">        &#125;</div><div class="line">        context = null;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static AppContext getAppContext() &#123;</div><div class="line">        AppContext appContext = appContextMap.get();</div><div class="line">        if (appContext == null) &#123;</div><div class="line">            appContext = new AppContext();</div><div class="line">            appContextMap.set(appContext);</div><div class="line">        &#125;</div><div class="line">        return appContextMap.get();</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对于数据库的Connection，可以有以下实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">public Class ConnectionManager &#123;</div><div class="line"></div><div class="line">   // 创建一个私有静态的并且是与事务相关联的局部线程变量  </div><div class="line">   private static ThreadLocal&lt;Connection&gt; connectionHolder = new ThreadLocal&lt;Connection&gt;;</div><div class="line"></div><div class="line">   public static Connection getConnection() &#123;</div><div class="line">       // 获得线程变量connectionHolder的值conn  </div><div class="line">       Connection conn = connectionHolder.get();</div><div class="line">       if (conn == null)&#123;</div><div class="line">           // 如果连接为空，则创建连接，另一个工具类，创建连接  </div><div class="line">           conn = DbUtil.getConnection();</div><div class="line">           // 将局部变量connectionHolder的值设置为conn  </div><div class="line">           connectionHolder.set(conn);</div><div class="line">       &#125;</div><div class="line">       return conn;</div><div class="line">   &#125;  </div><div class="line">｝</div></pre></td></tr></table></figure>
<h3 id="ThreadLocal原理分析"><a href="#ThreadLocal原理分析" class="headerlink" title="ThreadLocal原理分析"></a>ThreadLocal原理分析</h3><p>ThreadLocal有如下成员变量和方法，如下图所示</p>
<p><img src="/images/threadlocal.png" alt="image"></p>
<p>其中经常用到的是以下几个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123; &#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123; &#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123; &#125;</div><div class="line"><span class="function"><span class="keyword">protected</span> T <span class="title">initialValue</span><span class="params">()</span> </span>&#123; &#125;</div></pre></td></tr></table></figure>
<p>由于ThreadLocal里面需要存值和取值，又需要与线程相关，那么数据存在哪里，用哪种数据结构呢？由于Map可以存储很多类型，这里又不需要对外提供服务，所以这里就用了静态内部类的Map来搞存储，来存储真实的变量实例。</p>
<h4 id="get-流程"><a href="#get-流程" class="headerlink" title="get()流程"></a>get()流程</h4><p>那么， ThreadLocal是如何工作的呢？我们先从get方法看起，下面是get方法的源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</div><div class="line">    Thread t = Thread.currentThread();</div><div class="line">    ThreadLocalMap map = getMap(t);</div><div class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</div><div class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</div><div class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">            T result = (T)e.value;</div><div class="line">            <span class="keyword">return</span> result;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> setInitialValue();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先获得当前线程，然后通过getMap(t)方法获取到一个map，map的类型为ThreadLocalMap。接下来根据<key,value>从map中获取Entry，注意这里获取键值对传进去的是this，而不是当前线程t。如果获取成功，则返回value值。如果map为空，则调用setInitialValue方法返回value。</key,value></p>
<p>getMap()方法是如何获取到ThreadLocalMap的呢？来看看源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> t.threadLocals;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>发现是直接获取当前线程的threadLocals成员变量，那么接下来就到Thread类里面去看一下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* ThreadLocal values pertaining to this thread. This map is maintained</span></div><div class="line"> * by the ThreadLocal class. */</div><div class="line">ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;</div></pre></td></tr></table></figure>
<p>实际上就是ThreadLocalMap，这个类型是ThreadLocal类的一个内部类，我们来看看ThreadLocalMap内部的Entry类，源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</div><div class="line">    <span class="comment">/** The value associated with this ThreadLocal. */</span></div><div class="line">    Object value;</div><div class="line"></div><div class="line">    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</div><div class="line">        <span class="keyword">super</span>(k);</div><div class="line">        value = v;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Entry继承自WeakReference，这里弱引用为Map的key，也就是ThreadLocal，弱引用就是只要JVM垃圾回收器发现了它，就会将之回收。</p>
<p>回到get()方法， 如果通过getMap()方法获取的map为空，就会调用setInitialValue() 方法，下面是该方法的源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> T <span class="title">setInitialValue</span><span class="params">()</span> </span>&#123;</div><div class="line">    T value = initialValue();</div><div class="line">    Thread t = Thread.currentThread();</div><div class="line">    ThreadLocalMap map = getMap(t);</div><div class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</div><div class="line">        map.set(<span class="keyword">this</span>, value);</div><div class="line">    <span class="keyword">else</span></div><div class="line">        createMap(t, value);</div><div class="line">    <span class="keyword">return</span> value;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先调用initialValue() 方法进行初始化value，默认为null，接下来获取当前线程，获取map，判断map是否为空，不为空将ThreadLocal类的对象为key，设定value，为空则创建map，调用createMap(t, value)方法，createMap代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</div><div class="line">    t.threadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="set-T-value-流程"><a href="#set-T-value-流程" class="headerlink" title="set(T value)流程"></a>set(T value)流程</h4><p>接下来看看set方法如何实现的，下面是源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</div><div class="line">    Thread t = Thread.currentThread();</div><div class="line">    ThreadLocalMap map = getMap(t);</div><div class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</div><div class="line">        map.set(<span class="keyword">this</span>, value);</div><div class="line">    <span class="keyword">else</span></div><div class="line">        createMap(t, value);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先获取当前线程，然后获取map，判断map是否为空，不为空将ThreadLocal类的对象为key，设定value，为空则创建map，调用createMap(t, value)方法。</p>
<p>至此，我们就可以知道大致知道ThreadLocal的工作流程：</p>
<ol>
<li><p>Thread类中有一个成员变量属于ThreadLocalMap类(一个定义在ThreadLocal类中的内部类)，它是一个Map，它的key是ThreadLocal实例对象。</p>
</li>
<li><p>当为ThreadLocal类的对象set值时，首先获得当前线程的ThreadLocalMap类属性，然后以ThreadLocal类的对象为key，设定value。get值时则类似。</p>
</li>
</ol>
<h3 id="一个线程多个ThreadLocal，如何区分？"><a href="#一个线程多个ThreadLocal，如何区分？" class="headerlink" title="一个线程多个ThreadLocal，如何区分？"></a>一个线程多个ThreadLocal，如何区分？</h3><p>既然ThreadLocal内部用map存储数据，一个线程可以对应多个ThreadLocal对象，那么这些ThreadLocal对象是如何区分的呢？上面只是大致分析了ThreadLocal的工作原理，并未涉及ThreadLocalMap的存值和取值，接下来我们继续来看源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * ThreadLocals rely on per-thread linear-probe hash maps attached</div><div class="line"> * to each thread (Thread.threadLocals and</div><div class="line"> * inheritableThreadLocals).  The ThreadLocal objects act as keys,</div><div class="line"> * searched via threadLocalHashCode.  This is a custom hash code</div><div class="line"> * (useful only within ThreadLocalMaps) that eliminates collisions</div><div class="line"> * in the common case where consecutively constructed ThreadLocals</div><div class="line"> * are used by the same threads, while remaining well-behaved in</div><div class="line"> * less common cases.</div><div class="line"> */</div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> threadLocalHashCode = nextHashCode();</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * The next hash code to be given out. Updated atomically. Starts at</div><div class="line"> * zero.</div><div class="line"> */</div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> AtomicInteger nextHashCode =</div><div class="line">    <span class="keyword">new</span> AtomicInteger();</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * The difference between successively generated hash codes - turns</div><div class="line"> * implicit sequential thread-local IDs into near-optimally spread</div><div class="line"> * multiplicative hash values for power-of-two-sized tables.</div><div class="line"> */</div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HASH_INCREMENT = <span class="number">0x61c88647</span>;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Returns the next hash code.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nextHashCode</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> nextHashCode.getAndAdd(HASH_INCREMENT);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在ThreadLocal类内部定义了一个final的变量threadLocalHashCode，这个变量是干什么的？看注释，在ThreadLocalMap存储数据时，ThreadLocal对象作为key，通过threadLocalHashCode进行搜索，threadLocalHashCode通过原子类AtomicInteger，提供原子操作，由于nextHashCode为类变量，保证每次生成的hashCode都不一致，每次生成hashCode都会有HASH_INCREMENT的差值。threadLocalHashCode会在ThreadLocalMap中用到，下面继续分析。</p>
<p>前面分析get()流程，对于如何从ThreadLocalMap取数据并未提及，现在看看源码如何实现的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> Entry <span class="title">getEntry</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (table.length - <span class="number">1</span>);</div><div class="line">    Entry e = table[i];</div><div class="line">    <span class="keyword">if</span> (e != <span class="keyword">null</span> &amp;&amp; e.get() == key)</div><div class="line">        <span class="keyword">return</span> e;</div><div class="line">    <span class="keyword">else</span></div><div class="line">        <span class="keyword">return</span> getEntryAfterMiss(key, i, e);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过调用ThreadLocalMap的getEntry方法，传入当前ThreadLocal对象，然后获取ThreadLocal的threadLocalHashCode， 然后通过位运算与(&amp;) 将 threadLocalHashCode和ThreadLocal内部存储数据的table的长度减一进行位运算得到i，利用i在table中直接进行搜索。</p>
<p>在ThreadLocalMap如何存值？下面看ThreadLocalMap.set()源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value)</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">// We don't use a fast path as with get() because it is at</span></div><div class="line">    <span class="comment">// least as common to use set() to create new entries as</span></div><div class="line">    <span class="comment">// it is to replace existing ones, in which case, a fast</span></div><div class="line">    <span class="comment">// path would fail more often than not.</span></div><div class="line"></div><div class="line">    Entry[] tab = table;</div><div class="line">    <span class="keyword">int</span> len = tab.length;</div><div class="line">    <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (Entry e = tab[i];</div><div class="line">         e != <span class="keyword">null</span>;</div><div class="line">         e = tab[i = nextIndex(i, len)]) &#123;</div><div class="line">        ThreadLocal&lt;?&gt; k = e.get();</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (k == key) &#123;</div><div class="line">            e.value = value;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</div><div class="line">            replaceStaleEntry(key, value, i);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    tab[i] = <span class="keyword">new</span> Entry(key, value);</div><div class="line">    <span class="keyword">int</span> sz = ++size;</div><div class="line">    <span class="keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</div><div class="line">        rehash();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在ThreadLocalMap.set()方法中，传入当前ThreadLocal对象和要存的值，然后通过位运算与(&amp;) 将 threadLocalHashCode和ThreadLocal内部存储数据的table的长度减一进行位运算得到i，这个i在get()方法已经见过了，完全一样（不一样就出问题啦），接下来开始遍历table，判断有没有相同的key等处理，其实最核心的就是你得去new 一个entry然后设置到table数组中，就是下面这句：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tab[i] = <span class="keyword">new</span> Entry(key, value);</div></pre></td></tr></table></figure>
<h3 id="ThreadLocal会有内存泄露？"><a href="#ThreadLocal会有内存泄露？" class="headerlink" title="ThreadLocal会有内存泄露？"></a>ThreadLocal会有内存泄露？</h3><p>看了好多博客，里面提到ThreadLocal会有内存泄露问题，因为从ThreadLocalMap的设计来看，如下图，key被设计成弱引用，一旦JVM进行GC时，这个key就没了，那么与key对应的value还存在ThreadLocalMap，ThreadLocalMap与Entry存在着强引用，GC无法回收，造成内存泄露。</p>
<p><img src="/images/threadlocal_weak.png" alt="image"></p>
<p>当然，这些都是分析出来的，既然我们考虑到了，那么Josh Bloch 和 Doug Lea肯定也为我们考虑过了，所以这个问题在源码中已经解决了，下面来看看相关源码</p>
<p>在ThreadLocalMap.set()方法中，如果key为null，此时会调用 replaceStaleEntry()方法，在这个方法中进行处理</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">replaceStaleEntry</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value,</span></span></div><div class="line">                               <span class="keyword">int</span> staleSlot) &#123;</div><div class="line">    Entry[] tab = table;</div><div class="line">    <span class="keyword">int</span> len = tab.length;</div><div class="line">    Entry e;</div><div class="line"></div><div class="line">    <span class="comment">// Back up to check for prior stale entry in current run.</span></div><div class="line">    <span class="comment">// We clean out whole runs at a time to avoid continual</span></div><div class="line">    <span class="comment">// incremental rehashing due to garbage collector freeing</span></div><div class="line">    <span class="comment">// up refs in bunches (i.e., whenever the collector runs).</span></div><div class="line">    <span class="keyword">int</span> slotToExpunge = staleSlot;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = prevIndex(staleSlot, len);</div><div class="line">         (e = tab[i]) != <span class="keyword">null</span>;</div><div class="line">         i = prevIndex(i, len))</div><div class="line">        <span class="keyword">if</span> (e.get() == <span class="keyword">null</span>)</div><div class="line">            slotToExpunge = i;</div><div class="line"></div><div class="line">    <span class="comment">// Find either the key or trailing null slot of run, whichever</span></div><div class="line">    <span class="comment">// occurs first</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = nextIndex(staleSlot, len);</div><div class="line">         (e = tab[i]) != <span class="keyword">null</span>;</div><div class="line">         i = nextIndex(i, len)) &#123;</div><div class="line">        ThreadLocal&lt;?&gt; k = e.get();</div><div class="line"></div><div class="line">        <span class="comment">// If we find key, then we need to swap it</span></div><div class="line">        <span class="comment">// with the stale entry to maintain hash table order.</span></div><div class="line">        <span class="comment">// The newly stale slot, or any other stale slot</span></div><div class="line">        <span class="comment">// encountered above it, can then be sent to expungeStaleEntry</span></div><div class="line">        <span class="comment">// to remove or rehash all of the other entries in run.</span></div><div class="line">        <span class="keyword">if</span> (k == key) &#123;</div><div class="line">            e.value = value;</div><div class="line"></div><div class="line">            tab[i] = tab[staleSlot];</div><div class="line">            tab[staleSlot] = e;</div><div class="line"></div><div class="line">            <span class="comment">// Start expunge at preceding stale entry if it exists</span></div><div class="line">            <span class="keyword">if</span> (slotToExpunge == staleSlot)</div><div class="line">                slotToExpunge = i;</div><div class="line">            cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// If we didn't find stale entry on backward scan, the</span></div><div class="line">        <span class="comment">// first stale entry seen while scanning for key is the</span></div><div class="line">        <span class="comment">// first still present in the run.</span></div><div class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span> &amp;&amp; slotToExpunge == staleSlot)</div><div class="line">            slotToExpunge = i;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// If key not found, put new entry in stale slot</span></div><div class="line">    tab[staleSlot].value = <span class="keyword">null</span>;</div><div class="line">    tab[staleSlot] = <span class="keyword">new</span> Entry(key, value);</div><div class="line"></div><div class="line">    <span class="comment">// If there are any other stale entries in run, expunge them</span></div><div class="line">    <span class="keyword">if</span> (slotToExpunge != staleSlot)</div><div class="line">        cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中我们可以看到这段代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// If key not found, put new entry in stale slot</span></div><div class="line">tab[staleSlot].value = <span class="keyword">null</span>;</div></pre></td></tr></table></figure>
<p>如果key找不到，那么就将value置为null，help GC。这样问题解决。</p>
<p>当然在resize()方法中也有同样的操作，总之都会进行处理的。</p>
<p>最后，我们可以调用remove()方法将相关数据移除，这个肯定就不会有内存泄露啦。</p>
<h3 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h3><p><a href="https://www.cnblogs.com/xzwblog/p/7227509.html#_label0" target="_blank" rel="external">https://www.cnblogs.com/xzwblog/p/7227509.html#_label0</a></p>
<p><a href="https://www.jianshu.com/p/ee8c9dccc953" target="_blank" rel="external">https://www.jianshu.com/p/ee8c9dccc953</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzA5MzQ2NTY0OA==&amp;mid=2650796401&amp;idx=1&amp;sn=61f2d19bfb0e34c08206c6b31a1c2dd1&amp;chksm=88562c2ebf21a5383ace3f52f336db9b53a714bb37d5f97a9d5746b43b6a3d30be113aca082a&amp;mpshare=1&amp;scene=23&amp;srcid=1212TdJMnkHNCPTwVsPKSuao#rd" target="_blank" rel="external">https://mp.weixin.qq.com/s?__biz=MzA5MzQ2NTY0OA==&amp;mid=2650796401&amp;idx=1&amp;sn=61f2d19bfb0e34c08206c6b31a1c2dd1&amp;chksm=88562c2ebf21a5383ace3f52f336db9b53a714bb37d5f97a9d5746b43b6a3d30be113aca082a&amp;mpshare=1&amp;scene=23&amp;srcid=1212TdJMnkHNCPTwVsPKSuao#rd</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记得去年学习Spring MVC的时候自己学着写了一个小小的框架，用了一个AppContext来表示应用上下文，每个请求都应该有各自独立的AppContext，里面可以存储一些数据，比如数据库连接Connection等，此时考虑数据库的事务问题，即在一个线程内，一个事务的多个操作拿到的是一个Connection，该如何实现呢？此时就需要使用ThreadLocal来解决。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="ThreadLocal" scheme="http://yoursite.com/tags/ThreadLocal/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之装饰模式</title>
    <link href="http://yoursite.com/2018/06/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2018/06/27/设计模式之装饰模式/</id>
    <published>2018-06-26T16:00:00.000Z</published>
    <updated>2018-06-29T04:02:53.035Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>装饰模式作为常用的设计模式用到很多，比如在Java中，io包下的很多类就是典型的装饰者模式的体现，如下代码：</p>
<a id="more"></a>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> BufferedOutputStream(OutputStream out)</div><div class="line"><span class="keyword">new</span> BufferedInputStream(InputStream in);</div><div class="line"><span class="keyword">new</span> PrintWriter(OutputStream out)</div><div class="line"><span class="keyword">new</span> FilterReader(Reader in);</div></pre></td></tr></table></figure>
<p>那么，什么是装饰模式呢？</p>
<p>在实际应用中我们可能会有这样的需求，需要动态地为一个类增加一些功能，这些功能动态地撤销，继承虽然也可以对类进行功能扩展，但是静态的，为了扩展性和动态性，就需要引入装饰模式。</p>
<p>装饰模式的定义是： 动态地给一些对象添加一些额外的职责。就增加功能来说，装饰模式相比生成子类更加灵活。</p>
<p>装饰模式的通用类图如下图所示：</p>
<p><img src="/images/decorator.png" alt="image"></p>
<p>在类图中，有四个角色需要说明：</p>
<ul>
<li><p>抽象构件（Component） </p>
<p>  给出一个抽象的接口，用以规范准备接收附加责任的对象。</p>
</li>
<li><p>具体构件（ConcreteComponent） </p>
<p>  ConcreteComponent是最核心、最原始、最基本的接口或抽象类的实现，要装饰的就是它。</p>
</li>
<li><p>装饰角色（Decorator） </p>
<p>  有一个构件（Conponent）对象的实例，并定义一个和抽象构件一致的接口。</p>
</li>
<li><p>具体装饰角色（ConcreteDecorator） </p>
<p>  具体的装饰类，要增加的功能当然要在这里写啦。</p>
</li>
</ul>
<p><strong>具体代码实现:</strong></p>
<p>抽象构件:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 抽象构建</div><div class="line"> * </div><div class="line"> * <span class="doctag">@author</span> mingshan</div><div class="line"> *</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Component</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">operate</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>具体构件:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 具体构件</div><div class="line"> * </div><div class="line"> * <span class="doctag">@author</span> mingshan</div><div class="line"> *</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteComponent</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operate</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"do something"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>装饰角色, 持有一个抽象构件的引用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 抽象装饰者</div><div class="line"> * </div><div class="line"> * <span class="doctag">@author</span> mingshan</div><div class="line"> *</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Decorator</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> Component component;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Decorator</span><span class="params">(Component component)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>();</div><div class="line">        <span class="keyword">this</span>.component = component;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operate</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.component.operate();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>具体装饰角色</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 装饰者1</div><div class="line"> * </div><div class="line"> * <span class="doctag">@author</span> mingshan</div><div class="line"> *</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteDecorator1</span> <span class="keyword">extends</span> <span class="title">Decorator</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 定义被修饰者</div><div class="line">     * <span class="doctag">@param</span> component</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteDecorator1</span><span class="params">(Component component)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(component);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 定义自己的修饰方法</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"decorator A"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 重写父类的方法</div><div class="line">     */</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operate</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.method1();</div><div class="line">        <span class="keyword">super</span>.operate();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>测试一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 测试</div><div class="line"> * </div><div class="line"> * <span class="doctag">@author</span> mingshan</div><div class="line"> *</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Component component = <span class="keyword">new</span> ConcreteComponent();</div><div class="line">        <span class="comment">// 第一次装饰</span></div><div class="line">        component = <span class="keyword">new</span> ConcreteDecorator1(component);</div><div class="line">        <span class="comment">// 第二次装饰</span></div><div class="line">        component = <span class="keyword">new</span> ConcreteDecorator2(component);</div><div class="line">        component.operate();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>代码参考：</strong></p>
<p><a href="https://github.com/mstao/java-explore/tree/master/DesignPattern/src/pers/han/decorator" target="_blank" rel="external">https://github.com/mstao/java-explore/tree/master/DesignPattern/src/pers/han/decorator</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;装饰模式作为常用的设计模式用到很多，比如在Java中，io包下的很多类就是典型的装饰者模式的体现，如下代码：&lt;/p&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="装饰模式" scheme="http://yoursite.com/tags/%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之适配器模式</title>
    <link href="http://yoursite.com/2018/06/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2018/06/25/设计模式之适配器模式/</id>
    <published>2018-06-24T16:00:00.000Z</published>
    <updated>2018-06-27T14:49:30.268Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在我们日常生活中可以看到许多例子，例如我们的手机需要用充电器来充电，因为220v电压手机是承受不住的；笔记本电脑连接投影仪可以是HDMI，需要转接头等等例子，从这些例子中我们可以发现目标对象与源对象无法直接交互，需要一个中间层来作为一个桥梁达到让两者完美交互的效果，从这种就可以看到适配器模式的影子了。</p>
<a id="more"></a>
<p>那么什么是适配器模式呢? 将一个类的接口转换成客户希望的另外一个接口。Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。</p>
<p>适配器包含类适配器和对象适配器，类适配器是类间继承，对象适配器是类的关联关系，这是两者的区别。</p>
<p>我们先来看看适配器模式的角色</p>
<ol>
<li><p>Target目标角色</p>
<p> 该角色定义把其他类转化为何种接口，也就是我们最终期望的接口，需要Adapter实现该接口</p>
</li>
<li><p>Adaptee源角色</p>
<p> 想把谁转换为目标角色，此时就是源角色</p>
</li>
<li><p>Adapter适配器角色</p>
<p> 适配器模式的核心角色，它的职责非常简单，将源角色转化为目标角色</p>
</li>
</ol>
<h3 id="类适配器模式"><a href="#类适配器模式" class="headerlink" title="类适配器模式"></a>类适配器模式</h3><p>通过继承来实现适配器模式，由于Java是属于单继承，所以这个使用限制很大。</p>
<p>Adaptee源角色，里面包含原来的业务逻辑</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 适配器源角色</div><div class="line"> * </div><div class="line"> * <span class="doctag">@author</span> mingshan</div><div class="line"> *</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adaptee</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 原有的业务逻辑</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"源角色 do something。。。"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Target目标角色， 包含现有的业务逻辑</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 适配器目标角色</div><div class="line"> * </div><div class="line"> * <span class="doctag">@author</span> mingshan</div><div class="line"> *</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Target</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     *  目标角色有自己的方法</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">request</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 目标角色实现类， 现有的业务逻辑</div><div class="line"> * </div><div class="line"> * <span class="doctag">@author</span> mingshan</div><div class="line"> *</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteTarget</span> <span class="keyword">implements</span> <span class="title">Target</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"xxxxxxxxxxxxxxxxxx"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>适配器角色，需要继承源角色，拿到其里面的方法，然后实现目标角色接口，让源角色与目标角色进行交互</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 适配器角色</div><div class="line"> * </div><div class="line"> * <span class="doctag">@author</span> mingshan</div><div class="line"> *</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adapter</span> <span class="keyword">extends</span> <span class="title">Adaptee</span> <span class="keyword">implements</span> <span class="title">Target</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.doSomething();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>测试一下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 类适配器 Test</div><div class="line"> * </div><div class="line"> * <span class="doctag">@author</span> mingshan</div><div class="line"> *</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="comment">// 原有的业务逻辑</span></div><div class="line">        Target target = <span class="keyword">new</span> ConcreteTarget();</div><div class="line">        target.request();</div><div class="line">        <span class="comment">// 现在增加了适配器角色后的业务逻辑</span></div><div class="line">        Target target2 = <span class="keyword">new</span> Adapter();</div><div class="line">        target2.request();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="对象适配器模式"><a href="#对象适配器模式" class="headerlink" title="对象适配器模式"></a>对象适配器模式</h3><p>对象适配器是通过类的关联关系来进行的，是为了解决类适配器模式的问题而出现的，它比类适配器模式灵活，扩展性强，实际运用的比较多。</p>
<p>这里只解释一些Adapter适配器角色的实现，其他的和类适配器模式一致。</p>
<p>通过构造器将两个源角色传递进来，实现Target接口，然后就可以进行交互啦</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 适配器角色</div><div class="line"> * </div><div class="line"> * <span class="doctag">@author</span> mingshan</div><div class="line"> *</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adapter</span> <span class="keyword">implements</span> <span class="title">Target</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> Adaptee1 adaptee1;</div><div class="line">    <span class="keyword">private</span> Adaptee2 adaptee2;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Adapter</span><span class="params">(Adaptee1 adaptee1, Adaptee2 adaptee2)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.adaptee1 = adaptee1;</div><div class="line">        <span class="keyword">this</span>.adaptee2 = adaptee2;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span> </span>&#123;</div><div class="line">        adaptee1.doSomething();</div><div class="line">        adaptee2.doSomething();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="代码参考"><a href="#代码参考" class="headerlink" title="代码参考"></a>代码参考</h3><p><a href="https://github.com/mstao/java-explore/tree/master/DesignPattern/src/pers/han/adapter" target="_blank" rel="external">https://github.com/mstao/java-explore/tree/master/DesignPattern/src/pers/han/adapter</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在我们日常生活中可以看到许多例子，例如我们的手机需要用充电器来充电，因为220v电压手机是承受不住的；笔记本电脑连接投影仪可以是HDMI，需要转接头等等例子，从这些例子中我们可以发现目标对象与源对象无法直接交互，需要一个中间层来作为一个桥梁达到让两者完美交互的效果，从这种就可以看到适配器模式的影子了。&lt;/p&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="适配器模式" scheme="http://yoursite.com/tags/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>离人</title>
    <link href="http://yoursite.com/2018/06/22/%E7%A6%BB%E4%BA%BA/"/>
    <id>http://yoursite.com/2018/06/22/离人/</id>
    <published>2018-06-21T16:00:00.000Z</published>
    <updated>2018-06-24T02:47:14.538Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>好久不写文章，只因这段时间太忙了，忙到忘记离别的日子已经逼在眼前，倒让人措手不及。当这些繁琐的流程到了末尾，离别的日子真是要到来了。</p>
<a id="more"></a>
<p>大学是我目前人生中最充实的时光，回想以前的上学时代，也真让人怀念。十年回首，可喜可悲可叹其实现在也没有多深的记忆了，也或许都释怀了吧。释怀这个词不怎么靠谱，哪里有什么释怀不释怀的，只不过心里能够接受事情的好与坏，不需要过多纠结；明白人总是聚少离多，那些离开的人，可能一辈子也不会再见了。人因为情感变得复杂，也变得有趣。</p>
<p>最近一直在看梁晓声的《中国人的日常》，印象十分深刻。他谈及自己的初恋，感觉充满一种令人羡慕的稚气与甜蜜，或许是那个时代特有的那种情感，也或许是每个人在经历初恋时都会有的这种感觉。稚气地认为，各自的心灵从此有了依靠，被自己感动，亦被对方感动。在那个年代，爱不可声张，甚至不敢承认，这对于热恋中的人来说是有多么压抑和煎熬。我们都向往纯真，向往无邪，当你向往这些的时候，说明这些早已远离于你，这些也只是虚幻想象的样子，真实早已消失。</p>
<p>他在谈及在他年幼时遇到改变其一生的启蒙恩师，这是何等幸运。在人生启蒙时代能遇到为他们人生指明道路之人，没有因为一时错念而浪费自己的人生。普通人千千万万，并不是每个人都会遇到指点迷津之人，在混沌的日子里，在无可奈何的岁月中，怎么做到顿悟自我，不浪费自己的生命呢？对于年轻人来说，最浪费时间的事情就是给其讲经验、大道理，讲一万句不如自己去摔一跤，不如自己去尝试一下，眼泪教你做人，后悔帮你成长，疼痛才是人生之师。人生该走的弯路，其实一米也少不了。</p>
<p>大学让人成长不少，遇到了这么多有趣的人，十分不寂寞。人生遇到了每一个人，其实都有缘分，缘分大也罢，小也罢，都不怎么重要。毕竟在人生漫漫长河中，他们都是那一朵朵的浪花，这是多么的有趣和富有生气，倘若平静死水般，该是多么的无聊与苍白。人生不如意之事七八九，苦事。终归还能与人言一二三，幸事。感谢能遇到一群能一起喝酒玩乐、酒后畅谈之舍友们，共同成长，希望再见如故。</p>
<p>感慨这么多，还是说句俗话，希望各位万事大吉，天天吃鸡(￣▽￣)／</p>
<p>放两张照片吧，以此纪念我的大学。</p>
<p><img src="/images/0731.JPG" alt="image"></p>
<p><img src="/images/0984.JPG" alt="image"></p>
<p><img src="/images/0932.JPG" alt="image"></p>
<p>记于2018/6/22</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;好久不写文章，只因这段时间太忙了，忙到忘记离别的日子已经逼在眼前，倒让人措手不及。当这些繁琐的流程到了末尾，离别的日子真是要到来了。&lt;/p&gt;
    
    </summary>
    
      <category term="随笔" scheme="http://yoursite.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="大学" scheme="http://yoursite.com/tags/%E5%A4%A7%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>CentOS7安裝Redis遇到问题及解决</title>
    <link href="http://yoursite.com/2018/05/23/CentOS7%E5%AE%89%E8%A3%9DRedis%E9%81%87%E5%88%B0%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3/"/>
    <id>http://yoursite.com/2018/05/23/CentOS7安裝Redis遇到问题及解决/</id>
    <published>2018-05-22T16:00:00.000Z</published>
    <updated>2018-05-28T04:09:15.185Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>前段时间我在我的CentOS7服务器上安装了Redis，遇到了一些问题忘记记录下来了ヽ(￣▽￣)ﾉ，而且我参考网上的教程配置一些脚本的时候发现有错误，根据我对shell的简单理解会介绍一下，毕竟这个东西很常用。</p>
<a id="more"></a>
<h2 id="安装Redis"><a href="#安装Redis" class="headerlink" title="安装Redis"></a>安装Redis</h2><p>首先在<strong>/usr/local</strong>目录下创建services 文件夹和其子文件redis,然后进入该文件夹。</p>
<p>下载redis可以通过wget，我这里下载的是<strong>redis-4.0.2</strong>版本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">wget http://download.redis.io/releases/redis-4.0.2.tar.gz</div></pre></td></tr></table></figure>
<p>将Redis下载到该文件夹下后，将压缩文件解压</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">cd /usr/local/services/redis</div><div class="line"></div><div class="line">tar -xzvf redis-4.0.2.tar.gz</div></pre></td></tr></table></figure>
<p>进入到解压后的文件夹，进行编译即可</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">cd /usr/local/services/redis/redis-4.0.2</div><div class="line"></div><div class="line">make</div></pre></td></tr></table></figure>
<p>编译完后，我们需要将<strong>redis-cli</strong>，<strong>redis-server</strong>，<strong>redis.conf</strong>拷贝到一个单独的文件夹，这里我们在<strong>/usr/local/services/redis</strong> 文件夹下新建一个文件夹<br><strong>redisroot</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mkdir -p /usr/local/services/redis/redisroot</div></pre></td></tr></table></figure>
<p>然后将编译后的<strong>redis-cli</strong>，<strong>redis-server</strong>，<strong>redis.conf</strong>拷贝到<strong>redisroot</strong>文件夹下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">cp /usr/local/services/redis/redis-4.0.2/src/redis-server /usr/local/services/redis/redisroot</div><div class="line"></div><div class="line">cp /usr/local/services/redis/redis-4.0.2/src/redis-cli /usr/local/services/redis/redisroot</div><div class="line"></div><div class="line">cp /usr/local/services/redis/redis-4.0.2/redis.conf /usr/local/services/redis/redisroot</div></pre></td></tr></table></figure>
<p>拷贝完后的文件夹结构如下：</p>
<p><img src="/images/redisroot-folder.png" alt="image"></p>
<h2 id="编辑配置文件"><a href="#编辑配置文件" class="headerlink" title="编辑配置文件"></a>编辑配置文件</h2><p>编辑Redis配置文件</p>
<p>进入到<strong>redisroot</strong>文件夹，输入下列命令进入编辑模式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vim redis.conf</div></pre></td></tr></table></figure>
<p>然后修改以下配置：</p>
<ol>
<li>在bind 127.0.0.1前加“#”将其注释掉</li>
<li>默认为保护模式，把 protected-mode yes 改为 protected-mode no</li>
<li>默认为不守护进程模式，把daemonize no 改为daemonize yes</li>
<li>将 requirepass foobared前的“#”去掉，密码改为你想要设置的密码</li>
</ol>
<p>设置完后，<strong>ESC</strong>切换模式后输入<strong>:wq!</strong>保存退出</p>
<h2 id="编辑Redis开机启动脚本"><a href="#编辑Redis开机启动脚本" class="headerlink" title="编辑Redis开机启动脚本"></a>编辑Redis开机启动脚本</h2><p>输入以下命令编辑脚本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vim /etc/init.d/redis</div></pre></td></tr></table></figure>
<p>打开后在这个文件里添加如下脚本</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/sh</div><div class="line"><span class="meta">#</span> chkconfig: 2345 80 90</div><div class="line"><span class="meta">#</span> description: Start and Stop redis</div><div class="line"><span class="meta">#</span>PATH=/usr/local/bin:/sbin:/usr/bin:/bin</div><div class="line">REDISPORT=6379</div><div class="line">EXEC=/usr/local/services/redis/redisroot/redis-server     </div><div class="line">REDIS_CLI=/usr/local/services/redis/redisroot/redis-cli     </div><div class="line">PIDFILE=/var/run/redis_6379.pid</div><div class="line">CONF="/usr/local/services/redis/redisroot/redis.conf"     </div><div class="line">RESDISPASSWORD=123456</div><div class="line"></div><div class="line">case "$1" in</div><div class="line">    start)</div><div class="line">        if [ -f $PIDFILE ]</div><div class="line">        then</div><div class="line">                echo "$PIDFILE exists, process is already running or crashed"</div><div class="line">        else</div><div class="line">                echo "Starting Redis server..."</div><div class="line">                $EXEC $CONF</div><div class="line">        fi</div><div class="line">        if [ "$?"="0" ]</div><div class="line">        then</div><div class="line">              echo "Redis is running..."</div><div class="line">        fi</div><div class="line">        ;;</div><div class="line">    stop)</div><div class="line">        if [ ! -f $PIDFILE ]</div><div class="line">        then</div><div class="line">                echo "$PIDFILE does not exist, process is not running"</div><div class="line">        else</div><div class="line">                PID=$(cat $PIDFILE)</div><div class="line">                echo "Stopping ..."</div><div class="line">                $CLIEXEC -a $RESDISPASSWORD -p$REDISPORT shutdown</div><div class="line">                while [ -x $&#123;PIDFILE&#125; ]</div><div class="line">               do</div><div class="line">                    echo "Waiting for Redis to shutdown ..."</div><div class="line">                    sleep 1</div><div class="line">                done</div><div class="line">                echo "Redis stopped"</div><div class="line">        fi</div><div class="line">        ;;</div><div class="line">   restart|force-reload)</div><div class="line">        $&#123;0&#125; stop</div><div class="line">        $&#123;0&#125; start</div><div class="line">        ;;</div><div class="line">  *)</div><div class="line">    echo "Usage: /etc/init.d/redis &#123;start|stop|restart|force-reload&#125;" &gt;&amp;2</div><div class="line">        exit 1</div><div class="line">esac</div></pre></td></tr></table></figure>
<p>脚本中声明的路径常量需要根据自己的安装路径进行配置。</p>
<p>上面这个脚本是我参考网上的，但网上的有错误，比如我设置了Redis的密码，那么在执行停止命令时是需要验证密码的，所以要这样写<strong>$CLIEXEC -a $RESDISPASSWORD -p$REDISPORT shutdown</strong>。</p>
<h2 id="后续配置"><a href="#后续配置" class="headerlink" title="后续配置"></a>后续配置</h2><p>下面的一些操作是从网上拷贝的，为后续配置Redis，基本相同</p>
<h3 id="添加开机启动服务"><a href="#添加开机启动服务" class="headerlink" title="添加开机启动服务"></a>添加开机启动服务</h3><p>编辑<strong>/etc/rc.local</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vim /etc/rc.local</div></pre></td></tr></table></figure>
<p>增加启动代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">service redis start</div></pre></td></tr></table></figure>
<p>编辑后的配置文件如下：</p>
<p><img src="/images/service-redis-start.png" alt="image"></p>
<h3 id="设置权限"><a href="#设置权限" class="headerlink" title="设置权限"></a>设置权限</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">chmod 755 /etc/init.d/redis</div></pre></td></tr></table></figure>
<h3 id="注册系统服务"><a href="#注册系统服务" class="headerlink" title="注册系统服务"></a>注册系统服务</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">chkconfig --add redis</div></pre></td></tr></table></figure>
<h3 id="测试redis服务"><a href="#测试redis服务" class="headerlink" title="测试redis服务"></a>测试redis服务</h3><p>启动服务</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">service redis start</div></pre></td></tr></table></figure>
<p>启动日志如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[root@VM_37_72_centos redisroot]# service redis start</div><div class="line">Starting Redis server...</div><div class="line">21416:C 23 May 00:24:19.666 # oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo</div><div class="line">21416:C 23 May 00:24:19.666 # Redis version=4.0.2, bits=64, commit=00000000, modified=0, pid=21416, just started</div><div class="line">21416:C 23 May 00:24:19.666 # Configuration loaded</div><div class="line">Redis is running...</div></pre></td></tr></table></figure>
<p>停止服务</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">service redis stop</div></pre></td></tr></table></figure>
<p>停止日志如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[root@VM_37_72_centos redisroot]#  service redis stop</div><div class="line">Stopping ...</div><div class="line">Redis stopped</div></pre></td></tr></table></figure>
<h3 id="创建redis命令软连接"><a href="#创建redis命令软连接" class="headerlink" title="创建redis命令软连接"></a>创建redis命令软连接</h3><p>在linux下很多地方都需要软连接，软连接其实就是windows的快捷方式。 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ln -s /usr/local/services/redis/redisroot/redis-cli /usr/bin/redis</div></pre></td></tr></table></figure>
<h3 id="测试Redis"><a href="#测试Redis" class="headerlink" title="测试Redis"></a>测试Redis</h3><p>最后可以直接进行测试了</p>
<p><img src="/images/redis-test.png" alt="image"></p>
<p>OK, 大功告成。</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>其实这些命令教程啊网上都有，不过有些是错误的，只有自己完完全全测试过一遍后才知道哪些有问题，同时会对Redis有个基本的了解吧，平时都在用Windows，相对来说有些傻瓜式，多敲些Linux命令还是有益处的，哈哈(～￣▽￣)～ </p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/lc1010078424/article/details/78295482" target="_blank" rel="external">https://blog.csdn.net/lc1010078424/article/details/78295482</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前段时间我在我的CentOS7服务器上安装了Redis，遇到了一些问题忘记记录下来了ヽ(￣▽￣)ﾉ，而且我参考网上的教程配置一些脚本的时候发现有错误，根据我对shell的简单理解会介绍一下，毕竟这个东西很常用。&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
      <category term="Redis" scheme="http://yoursite.com/tags/Redis/"/>
    
  </entry>
  
</feed>
