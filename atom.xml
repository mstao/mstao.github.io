<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Mingshan&#39;s Blog</title>
  
  <subtitle>一念开明，反身而诚</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://mingshan.me/"/>
  <updated>2018-10-21T15:51:31.693Z</updated>
  <id>http://mingshan.me/</id>
  
  <author>
    <name>Mingshan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java虚拟机的监控及诊断工具（命令行）</title>
    <link href="http://mingshan.me/2018/10/21/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7%EF%BC%88%E5%91%BD%E4%BB%A4%E8%A1%8C%EF%BC%89/"/>
    <id>http://mingshan.me/2018/10/21/Java虚拟机的监控及诊断工具（命令行）/</id>
    <published>2018-10-20T16:00:00.000Z</published>
    <updated>2018-10-21T15:51:31.693Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>对于普通的开发人员来说，可以阅读帮助文档或者源码来对JDK的设计以及JVM的内存管理获取一定的了解，但对于线上运行的程序，如何对程序进行监控和诊断呢？比如一个程序挂了，怎么通过分析堆栈信息、GC日志、线程快照等信息来快速定位问题？JDK的大佬早就为我们考虑到这一点，所以在JDK中包含了许多用于监控及诊断的工具，主要分为两类，<strong>命令行工具</strong>和<strong>GUI工具</strong>，这些工具在平时的开发中用到的频率非常高，我们一起来总结了解下。</p><a id="more"></a><p>常用的命令行工具以及作用：</p><table><thead><tr><th>名称</th><th>主要作用</th></tr></thead><tbody><tr><td>jps</td><td>JVM Process Status Tool,  列出指定系统内正在运行的虚拟机进程</td></tr><tr><td>jstat</td><td>JVM Statistics Monitoring Tool，允许用户查看目标 Java 进程的类加载、即时编译以及垃圾回收相关信息。常用来检测垃圾回收及内存泄露问题。</td></tr><tr><td>jinfo</td><td>打印目标 Java 进程的配置参数，并能够改动其中 manageabe 的参数。</td></tr><tr><td>jmap</td><td>统计用户统计目标 Java 进程的堆中存放的 Java 对象，生成堆转储快照（heapdump文件）</td></tr><tr><td>jstack</td><td>打印目标 Java 进程中各个线程的栈轨迹、线程状态、锁状况等信息，它还将自动检测死锁。</td></tr><tr><td>jcmd</td><td>实现前面除了jstat之外所有命令的功能</td></tr></tbody></table><h2 id="jps"><a href="#jps" class="headerlink" title="jps"></a>jps</h2><p>jps命令（<a href="https://docs.oracle.com/en/java/javase/11/tools/jps.html#GUID-6EB65B96-F9DD-4356-B825-6146E9EEC81E" target="_blank" rel="noopener">帮助文档</a>）用于列出正在运行的虚拟机进程信息，它的命令格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jps [ -q ] [ -mlvV ][hostid ]</span><br><span class="line">jps [ -help ]</span><br></pre></td></tr></table></figure><p>在默认情况下，jps的输出信息包括 Java 进程的进程ID以及主类名。jps还提供一些参数用于打印详细的信息。</p><p>其中 <code>-q</code>仅显示虚拟机的进程id， <code>-mlvV</code> 的意义如下：</p><ul><li><code>-m</code> 将打印传递给主类的参数</li><li><code>-l</code> 将打印模块名以及包名</li><li><code>-v</code> 将打印传递给虚拟机的参数</li><li><code>-V</code> 将打印传递给主类的参数、jar文件名等</li></ul><p>具体jps示例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ jps -l</span><br><span class="line">11988</span><br><span class="line">48932</span><br><span class="line">32696 org.jetbrains.idea.maven.server.RemoteMavenServer</span><br><span class="line">26140 jdk.jcmd/sun.tools.jps.Jps</span><br></pre></td></tr></table></figure><p>添加<code>-mlvV</code>打印更加详细的信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ jps -mlvV</span><br><span class="line">32696 org.jetbrains.idea.maven.server.RemoteMavenServer -Djava.awt.headless=true -Didea.version==2018.2.5 -Xmx768m -Didea.maven.embedder.version=3.5.4 -Dfile.encoding=GBK</span><br><span class="line">26924 jdk.jcmd/sun.tools.jps.Jps -mlvV -Dapplication.home=F:\develope\Java\Java11 -Xms8m -Djdk.module.main=jdk.jcmd</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure><h2 id="jstat"><a href="#jstat" class="headerlink" title="jstat"></a>jstat</h2><p><code>jstat</code>（<a href="https://docs.oracle.com/en/java/javase/11/tools/jstat.html#GUID-5F72A7F9-5D5A-4486-8201-E1D1BA8ACCB5" target="_blank" rel="noopener">帮助文档</a>）是用于监视虚拟机各种运行状态信息的命令行工具，它可以显示本地或者远程虚拟机进程中的类加载、内存、垃圾回收等信息，它的命令格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jstat generalOptions</span><br><span class="line">jstat -outputOptions [ -t] [-hlines] vmid [interval [count] ]</span><br></pre></td></tr></table></figure><p>其中<code>vmid</code>全称是Virtual Machine Identifier，就是<code>jps</code>命令显示的进程id，如果是远程虚拟机进程，<code>vmid</code>的格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[protocol:][//]lvmid[@hostname[:port]/servername]</span><br></pre></td></tr></table></figure><p><code>jstat</code>命令包含很多的子命令，主要分为3类：</p><ul><li>类加载（<code>-class</code>）</li><li>即时编译（<code>-compiler</code>和<code>-printcompilation</code>）</li><li>垃圾回收（<code>-gc*</code>）</li></ul><p>输入<code>jstat -options</code>显示如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ jstat -options</span><br><span class="line">-class</span><br><span class="line">-compiler</span><br><span class="line">-gc</span><br><span class="line">-gccapacity</span><br><span class="line">-gccause</span><br><span class="line">-gcmetacapacity</span><br><span class="line">-gcnew</span><br><span class="line">-gcnewcapacity</span><br><span class="line">-gcold</span><br><span class="line">-gcoldcapacity</span><br><span class="line">-gcutil</span><br><span class="line">-printcompilation</span><br></pre></td></tr></table></figure><p>参数<code>interval</code>和<code>count</code>代表查询间隔和次数，如果省略，默认查询一次。</p><p>现在我们要查询进程id 为26792的垃圾收集情况，并且是每隔2秒打印一次，共打印2次，命令和输出示例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ jstat -gc 26792 2s 2</span><br><span class="line"> S0C    S1C    S0U    S1U      EC       EU        OC         OU       MC     MU    CCSC   CCSU   YGC     YGCT    FGC    FGCT    CGC    CGCT     GCT</span><br><span class="line">5120.0 5120.0  0.0   5095.1 33280.0  30033.1   87552.0     2573.4   15232.0 14724.4 1920.0 1782.4      3    0.027   1      0.032   -          -    0.059</span><br><span class="line">5120.0 5120.0  0.0   5095.1 33280.0  30033.1   87552.0     2573.4   15232.0 14724.4 1920.0 1782.4      3    0.027   1      0.032   -          -    0.059</span><br></pre></td></tr></table></figure><p>在上面的示例中，输出了一大堆东西，那么这些是什么意思呢？前面说了，<code>jstat</code>有很多的关于垃圾回收的子命令，每个子命令的输出结果也不一样，具体可参考（<a href="https://docs.oracle.com/en/java/javase/11/tools/jstat.html#GUID-5F72A7F9-5D5A-4486-8201-E1D1BA8ACCB5" target="_blank" rel="noopener">帮助文档</a>）。我们知道JVM堆是分代的，前四个 表示Survivor 区的容量（Capacity）和已使用量（Utilization），EC表示当前Eden的容量，剩下的就不说了。</p><p>在翻阅文档的时候，发现没有CGC 和 CGCT的解释，它们分别代表并发 GC Stop-The-World 的次数和时间。</p><p><code>-t</code> 参数会显示时间戳列作为输出的第一列，它将在每行数据之前打印目标 Java 进程的启动以来的时间，示例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ jstat -gc -t 26792 2s 2</span><br><span class="line">Timestamp        S0C    S1C    S0U    S1U      EC       EU        OC         OU       MC     MU    CCSC   CCSU   YGC     YGCT    FGC    FGCT    CGC    CGCT     GCT</span><br><span class="line">         1949.1 5120.0 5120.0  0.0   5095.1 33280.0  31206.1   87552.0     2573.4   15232.0 14724.4 1920.0 1782.4      3    0.027   1      0.032   -          -   0.059</span><br><span class="line">         1951.1 5120.0 5120.0  0.0   5095.1 33280.0  31206.1   87552.0     2573.4   15232.0 14724.4 1920.0 1782.4      3    0.027   1      0.032   -          -   0.059</span><br></pre></td></tr></table></figure><h2 id="jmap"><a href="#jmap" class="headerlink" title="jmap"></a>jmap</h2><p><code>jmap</code>命令（<a href="https://docs.oracle.com/en/java/javase/11/tools/jmap.html#GUID-D2340719-82BA-4077-B0F3-2803269B7F41" target="_blank" rel="noopener">帮助文档</a>）用于生成堆转储快照，用于分析Java虚拟机堆中的对象。</p><p>它的命令格式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmap [options] pid</span><br></pre></td></tr></table></figure><p><code>jmap</code>命令的参数选项也包括很多种，具体如下：</p><p><strong>1. -clstats</strong></p><p>连接到正在运行的进程并打印Java堆被加载类的统计信息</p><p><strong>2. -finalizerinfo</strong></p><p>连接到正在运行的进程并打印所有待 finalize 的对象。</p><p><strong>3. -histo[:live]</strong></p><p>连接到正在运行的进程并统计各个类的实例数目以及占用内存，并按照内存使用量从多至少的顺序排列。此外，-histo:live只统计堆中还在存活的对象。</p><p><strong>4. -dump</strong></p><p>连接到正在运行的进程并导出Java虚拟机堆内存的快照。该子命令该包含如下参数：</p><ul><li>live  只保存堆中存活的对象</li><li>format=b 将使jmap导出与hprof（在 Java 9 中已被移除）-XX:+HeapDumpAfterFullGC、-XX:+HeapDumpOnOutOfMemoryError格式一样的文件</li><li>file=filename 指定导出堆内存快照的位置</li></ul><p>综合以上参数，示例命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmap -dump:live,format=b,file=heap.bin pid</span><br></pre></td></tr></table></figure><h2 id="jinfo"><a href="#jinfo" class="headerlink" title="jinfo"></a>jinfo</h2><p><code>jinfo</code>命令（<a href="https://docs.oracle.com/en/java/javase/11/tools/jinfo.html#GUID-69246B58-28C4-477D-B375-278F5F9830A5" target="_blank" rel="noopener">帮助文档</a>）用来实时地查看和调整虚拟机的各项参数。我们可以使用<code>jps -v</code>来查看传递给虚拟机的参数，即<code>System.getProperty</code>获取的<code>-D</code>参数，现在我们可以利用<code>jinfo</code>命令来获取了。</p><p>它的命令格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jinfo [option] pid</span><br></pre></td></tr></table></figure><p>它也包括了许多子命令，具体如下：</p><p><strong>1. -flag name</strong></p><p>打印指定的虚拟机参数的名称和值</p><p><strong>2. -flag [+|-]name</strong></p><p>用来修改目标 Java 进程的“manageable”虚拟机参数。其中<code>+</code>代表开启，<code>-</code>代表关闭。</p><p>输入<code>java -XX:+PrintFlagsFinal -version | grep manageable</code>来查看“manageable”虚拟机参数，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ java -XX:+PrintFlagsFinal -version | grep manageable</span><br><span class="line">     intx CMSAbortablePrecleanWaitMillis           = 100                                    &#123;manageable&#125; &#123;default&#125;</span><br><span class="line">     intx CMSTriggerInterval                       = -1                                     &#123;manageable&#125; &#123;default&#125;</span><br><span class="line">     intx CMSWaitDuration                          = 2000                                   &#123;manageable&#125; &#123;default&#125;</span><br><span class="line">     bool HeapDumpAfterFullGC                      = false                                  &#123;manageable&#125; &#123;default&#125;</span><br><span class="line">     bool HeapDumpBeforeFullGC                     = false                                  &#123;manageable&#125; &#123;default&#125;</span><br><span class="line">     bool HeapDumpOnOutOfMemoryError               = false                                  &#123;manageable&#125; &#123;default&#125;</span><br><span class="line">    ccstr HeapDumpPath                             =                                        &#123;manageable&#125; &#123;default&#125;</span><br><span class="line">    uintx MaxHeapFreeRatio                         = 70                                     &#123;manageable&#125; &#123;default&#125;</span><br><span class="line">    uintx MinHeapFreeRatio                         = 40                                     &#123;manageable&#125; &#123;default&#125;</span><br><span class="line">     bool PrintClassHistogram                      = false                                  &#123;manageable&#125; &#123;default&#125;</span><br><span class="line">     bool PrintConcurrentLocks                     = false                                  &#123;manageable&#125; &#123;default&#125;</span><br><span class="line">java version &quot;11&quot; 2018-09-25</span><br><span class="line">Java(TM) SE Runtime Environment 18.9 (build 11+28)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM 18.9 (build 11+28, mixed mode)</span><br></pre></td></tr></table></figure><p><strong>3. -flag name=value</strong></p><p>设置指定的虚拟机参数的值</p><p><strong>4. -flags</strong></p><p>打印全部的虚拟机参数，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ jinfo -flags 26792</span><br><span class="line">VM Flags:</span><br><span class="line">-XX:CICompilerCount=3 -XX:InitialHeapSize=134217728 -XX:MaxHeapSize=805306368 -XX:MaxNewSize=268435456 -XX:MinHeapDeltaBytes=524288 -XX:NewSize=44564480 -XX:OldSize=89653248 -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:-UseLargePagesIndividualAllocation -XX:+UseParallelGC</span><br></pre></td></tr></table></figure><p><strong>5. -sysprops</strong></p><p>打印java系统参数（Java System Properties）</p><h2 id="jstack"><a href="#jstack" class="headerlink" title="jstack"></a>jstack</h2><p><code>jstack</code>命令（<a href="https://docs.oracle.com/en/java/javase/11/tools/jstack.html#GUID-721096FC-237B-473C-A461-DBBBB79E4F6A" target="_blank" rel="noopener">帮助文档</a>）可以用来打印目标 Java 进程中各个线程的栈轨迹，以及这些线程所持有的锁。通过线程的栈轨迹可以定位线程长时间停顿的原因，如线程间死锁、死循环、请求外部资源导致长时间等待等。</p><p>它的命令格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jstack [options] pid</span><br></pre></td></tr></table></figure><p>它也有子命令：</p><p><strong>-l</strong></p><p>输出关于锁的附加信息，例如属于java.util.concurrent的ownable synchronizers列表</p><p>下面是一个示例，如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$ jstack -l 42680</span><br><span class="line">2018-10-21 23:09:17</span><br><span class="line">Full thread dump OpenJDK 64-Bit Server VM (25.152-b19 mixed mode):</span><br><span class="line"></span><br><span class="line">&quot;ApplicationImpl pooled thread 35&quot; #142 daemon prio=4 os_prio=-1 tid=0x0000000018422000 nid=0xafe8 waiting on condition [0x00000000458bf000]</span><br><span class="line">   java.lang.Thread.State: TIMED_WAITING (parking)</span><br><span class="line">        at sun.misc.Unsafe.park(Native Method)</span><br><span class="line">        - parking to wait for  &lt;0x00000000e1506488&gt; (a java.util.concurrent.SynchronousQueue$TransferStack)</span><br><span class="line">        at java.util.concurrent.locks.LockSupport.parkNanos(LockSupport.java:215)</span><br><span class="line">        at java.util.concurrent.SynchronousQueue$TransferStack.awaitFulfill(SynchronousQueue.java:460)</span><br><span class="line">        at java.util.concurrent.SynchronousQueue$TransferStack.transfer(SynchronousQueue.java:362)</span><br><span class="line">        at java.util.concurrent.SynchronousQueue.poll(SynchronousQueue.java:941)</span><br><span class="line">        at java.util.concurrent.ThreadPoolExecutor.getTask(ThreadPoolExecutor.java:1066)</span><br><span class="line">        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1127)</span><br><span class="line">        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)</span><br><span class="line">        at java.lang.Thread.run(Thread.java:745)</span><br><span class="line"></span><br><span class="line">   Locked ownable synchronizers:</span><br><span class="line">        - None</span><br></pre></td></tr></table></figure><p>在输出的信息中，会包含线程的状态，下面是常见的线程状态：</p><ol><li>RUNNABLE，线程处于执行中</li><li>BLOCKED，线程被阻塞</li><li>WAITING，线程正在等待</li><li>TIMED_WAITING 超时等待</li></ol><h2 id="jcmd"><a href="#jcmd" class="headerlink" title="jcmd"></a>jcmd</h2><p><code>jcmd</code>命令（<a href="https://docs.oracle.com/en/java/javase/11/tools/jcmd.html#GUID-59153599-875E-447D-8D98-0078A5778F05" target="_blank" rel="noopener">帮助文档</a>）可以向运行中的Java虚拟机(JVM)发送诊断命令。</p><p>它的命令格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jcmd &lt;pid | main class&gt; &lt;command ... | PerfCounter.print | -f  file&gt;</span><br><span class="line">jcmd -l</span><br><span class="line">jcmd -h</span><br></pre></td></tr></table></figure><p><strong>pid</strong></p><p>虚拟机的进程id</p><p><strong>main class</strong></p><p>接收诊断命令请求的进程的main类。</p><p><strong>command</strong></p><p>该命令必须是针对所选JVM的有效jcmd命令。jcmd的可用命令列表是通过运行help命令(jcmd pid help)获得的，其中pid是运行Java进程的进程ID。如果pid为0，命令将被发送到所有的Java进程。main class参数将用于部分或完全匹配用于启动Java的类。如果没有提供任何选项，它会列出正在运行的Java进程标识符以及用于启动进程的主类和命令行参数(与使用-l相同)。</p><p><strong>Perfcounter.print</strong></p><p>打印目标Java进程上可用的性能计数器。性能计数器的列表可能会随着Java进程的不同而产生变化。</p><p><strong>-f file</strong></p><p>从文件file中读取命令，然后在目标Java进程上调用这些命令。</p><p><strong>-l</strong></p><p>查看所有的进程列表信息。</p><p><strong>-h</strong><br>查看帮助信息。（同 -help）</p><p>jcmd的可用命令列表如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">$ jcmd 26792 help</span><br><span class="line">26792:</span><br><span class="line">The following commands are available:</span><br><span class="line">VM.native_memory</span><br><span class="line">ManagementAgent.stop</span><br><span class="line">ManagementAgent.start_local</span><br><span class="line">ManagementAgent.start</span><br><span class="line">GC.rotate_log</span><br><span class="line">Thread.print</span><br><span class="line">GC.class_stats</span><br><span class="line">GC.class_histogram</span><br><span class="line">GC.heap_dump</span><br><span class="line">GC.run_finalization</span><br><span class="line">GC.run</span><br><span class="line">VM.uptime</span><br><span class="line">VM.flags</span><br><span class="line">VM.system_properties</span><br><span class="line">VM.command_line</span><br><span class="line">VM.version</span><br><span class="line">help</span><br><span class="line"></span><br><span class="line">For more information about a specific command use &apos;help &lt;command&gt;&apos;.</span><br></pre></td></tr></table></figure><p>PS: 以后用到了再详细补充。。</p><p>参考：</p><ul><li><a href="https://docs.oracle.com/en/java/javase/11/tools/monitoring-tools-and-commands.html" target="_blank" rel="noopener">Monitoring Tools and Commands</a></li><li><a href="https://docs.oracle.com/en/java/javase/11/tools/troubleshooting-tools-and-commands.html" target="_blank" rel="noopener">Troubleshooting Tools and Commands</a></li><li><a href="https://time.geekbang.org/column/article/40520" target="_blank" rel="noopener">Java虚拟机的监控及诊断工具（命令行篇）</a></li><li>周志明，深入理解Java虚拟机:JVM高级特性与最佳实践（第二版）</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对于普通的开发人员来说，可以阅读帮助文档或者源码来对JDK的设计以及JVM的内存管理获取一定的了解，但对于线上运行的程序，如何对程序进行监控和诊断呢？比如一个程序挂了，怎么通过分析堆栈信息、GC日志、线程快照等信息来快速定位问题？JDK的大佬早就为我们考虑到这一点，所以在JDK中包含了许多用于监控及诊断的工具，主要分为两类，&lt;strong&gt;命令行工具&lt;/strong&gt;和&lt;strong&gt;GUI工具&lt;/strong&gt;，这些工具在平时的开发中用到的频率非常高，我们一起来总结了解下。&lt;/p&gt;
    
    </summary>
    
      <category term="JVM" scheme="http://mingshan.me/categories/JVM/"/>
    
    
      <category term="JVM" scheme="http://mingshan.me/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>ForkJoin实践及JMH基准测试其性能</title>
    <link href="http://mingshan.me/2018/10/19/ForkJoin%E5%AE%9E%E8%B7%B5%E5%8F%8AJMH%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95%E5%85%B6%E6%80%A7%E8%83%BD/"/>
    <id>http://mingshan.me/2018/10/19/ForkJoin实践及JMH基准测试其性能/</id>
    <published>2018-10-18T16:00:00.000Z</published>
    <updated>2018-10-19T16:18:41.068Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>熟悉Java Stream API的同学可能知道可以利用<code>parallelStream</code>来实现并行操作，而Stream的并行操作依赖JDK1.7引入的Fork/Join框架，提供实现并行编程的一种方案。下面是Doug Lea对并行编程的描述：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(recursively) splitting them into subtasks that are solved in</span><br><span class="line">parallel, waiting for them to complete, and then composing</span><br><span class="line">results.</span><br></pre></td></tr></table></figure><a id="more"></a><p>Fork/Join框架的主要设计思想是采用了类似分治算法（ divide−<br>and−conquer algorithms），将任务分割成许多小任务并行执行，最后合并计算结果，这比串行化执行效率提高不少。伪代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Result <span class="title">solve</span><span class="params">(Problem problem)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">if</span> (problem is small)</span><br><span class="line"> directly solve problem</span><br><span class="line"> <span class="keyword">else</span> &#123;</span><br><span class="line"> split problem into independent parts</span><br><span class="line"> fork <span class="keyword">new</span> subtasks to solve each part</span><br><span class="line"> join all subtasks</span><br><span class="line"> compose result from subresults</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里涉及到两个词，fork和join，在Doug Lea的论文中，有以下描述：</p><p>Fork：开启一个新的子任务进行计算</p><blockquote><p>The fork operation starts a new parallel fork/join subtask. </p></blockquote><p>Join: 导致当前任务等待直至被fork的线程计算完成</p><blockquote><p>The join operation causes the current task not to proceed until the<br>forked subtask has completed.</p></blockquote><p>从fork/join的描述来看，就是利用递归不断的划分子任务，直至任务被划分的足够小，直接串行执行足够简单，没有问题。</p><h2 id="测试和性能对比"><a href="#测试和性能对比" class="headerlink" title="测试和性能对比"></a>测试和性能对比</h2><p>我们通过计算1 ~ 100000000相加求和问题，来模拟fork/join并行执行，并通过与串行化for循环执行，利用线程池多线程并发执行 的时间对比，来推测fork/join的计算效率。</p><h3 id="FOR串行"><a href="#FOR串行" class="headerlink" title="FOR串行"></a>FOR串行</h3><p>先考虑最简单的情况，直接利用for循环执行上面的计算任务，这是在单线程情况下来执行的，也就是串行执行，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForLoopCalculatorImpl</span> <span class="keyword">implements</span> <span class="title">Calculator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">sum</span><span class="params">(<span class="keyword">long</span>[] numbers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> result = <span class="number">0L</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numbers.length; i++) &#123;</span><br><span class="line">            result += numbers[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码相当简单，无需多言。</p><h3 id="线程池并发"><a href="#线程池并发" class="headerlink" title="线程池并发"></a>线程池并发</h3><p>For循环执行时利用单线程来执行的，当计算任务较大时，我们可能会考虑使用多线程来处理计算任务，并且计算过程是异步的。首先考虑CPU核心数，将任务分割成与CPU核心数一样数量的子任务，避免CPU时间片的过度切换引起资源浪费。获取CPU核心数和初始化线程池的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> parallism = Runtime.getRuntime().availableProcessors();</span><br><span class="line"><span class="keyword">private</span> ExecutorService pool;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ExecutorServiceCalculatorImpl</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> corePoolSize = Math.max(<span class="number">2</span>, Math.min(parallism - <span class="number">1</span>, <span class="number">4</span>));</span><br><span class="line">    <span class="keyword">int</span> maximumPoolSize = parallism * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> keepAliveTime = <span class="number">30</span>;</span><br><span class="line">    System.out.println(String.format(<span class="string">"corePoolSize = %s, maximumPoolSize = %s"</span>, corePoolSize, maximumPoolSize));</span><br><span class="line">    BlockingQueue&lt;Runnable&gt; workQueue = <span class="keyword">new</span> LinkedBlockingDeque&lt;&gt;();</span><br><span class="line">    <span class="comment">// 线程的创建工厂</span></span><br><span class="line">    ThreadFactory threadFactory = <span class="keyword">new</span> ThreadFactory() &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger mCount = <span class="keyword">new</span> AtomicInteger(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Thread(r, <span class="string">"AdvacnedAsyncTask #"</span> + mCount.getAndIncrement());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线程池任务满载后采取的任务拒绝策略</span></span><br><span class="line">    RejectedExecutionHandler rejectHandler = <span class="keyword">new</span> ThreadPoolExecutor.DiscardOldestPolicy();</span><br><span class="line"></span><br><span class="line">    pool = <span class="keyword">new</span> ThreadPoolExecutor(corePoolSize,</span><br><span class="line">            maximumPoolSize,</span><br><span class="line">            keepAliveTime,</span><br><span class="line">            TimeUnit.SECONDS,</span><br><span class="line">            workQueue,</span><br><span class="line">            threadFactory,</span><br><span class="line">            rejectHandler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码是使用ThreadPoolExecutor来创建线程池的，这样会更加了解线程池使用的各种细节。</p><p>接下来我们就需要使用线程池，根据CPU核心数来划分一定数量的子任务，然后将这些子任务交给线程池里面的线程去执行。此时注意任务的划分不一定是均匀的，因为最后一份任务可能比其他的多或者少，需要特别处理一下，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">sum</span><span class="params">(<span class="keyword">long</span>[] numbers)</span> </span>&#123;</span><br><span class="line">    List&lt;Future&lt;Long&gt;&gt; futures = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把任务分解为 n 份，交给 n 个线程处理，</span></span><br><span class="line">    <span class="comment">// 此时由于int类型丢失精度</span></span><br><span class="line">    <span class="keyword">int</span> part = numbers.length / parallism;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; parallism; i++) &#123;</span><br><span class="line">        <span class="comment">// 进行任务分配</span></span><br><span class="line">        <span class="keyword">int</span> from = i * part;</span><br><span class="line">        <span class="comment">// 最后一份任务可能不均匀，直接分配给最后一个线程</span></span><br><span class="line">        <span class="keyword">int</span> to = (i == parallism - <span class="number">1</span>) ? numbers.length - <span class="number">1</span> : (i + <span class="number">1</span>) * part - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 提交计算任务</span></span><br><span class="line">        futures.add(pool.submit(<span class="keyword">new</span> SumTask(numbers, from, to)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把每个线程的结果相加，得到最终结果</span></span><br><span class="line">    <span class="keyword">long</span> total = <span class="number">0L</span>;</span><br><span class="line">    <span class="keyword">for</span> (Future&lt;Long&gt; future : futures) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            total += future.get();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ignore) &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    pool.shutdown();</span><br><span class="line">    <span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中涉及到一个计算任务<code>SumTask</code>，抽象出来用来计算从<code>from</code> 到 <code>to</code> 之间的数相加之和，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SumTask</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span>[] numbers;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> from;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> to;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SumTask</span><span class="params">(<span class="keyword">long</span>[] numbers, <span class="keyword">int</span> from, <span class="keyword">int</span> to)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.numbers = numbers;</span><br><span class="line">        <span class="keyword">this</span>.from = from;</span><br><span class="line">        <span class="keyword">this</span>.to = to;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> total = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = from; i &lt;= to; i++) &#123;</span><br><span class="line">            total += numbers[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> total;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看过上面的代码，我们主要是利用了线程池来并发来执行计算任务，同时利用了线程池异步的特性，从设计上来说比for循环串行执行要好，但由于涉及到CPU的时间片切换，执行耗时上可能会比串行执行要高。</p><h3 id="Fokr-Join"><a href="#Fokr-Join" class="headerlink" title="Fokr/Join"></a>Fokr/Join</h3><p>写完线程池并发执行计算任务，如果让我们来设计并行执行任务的框架，可能会想到用线程池来做，既然Doug Lea写出了Fork/Join框架，肯定不是利用我们现在的方式来做，那么他是如何实现的呢？</p><p>Fork/Join框架抽象出了<code>ForkJoinTask</code>来代表要执行的计算任务，该类实现了<code>Future</code>接口，比<code>Thread</code>更加轻量级。不过我们通常不需要直接继承该类，Fork/Join框架给我们提供了两个抽象类供我们继承：</p><ul><li><code>RecursiveTask</code> ：代表有返回值的计算任务 </li><li><code>RecursiveAction</code>：代表没有返回值的任务</li></ul><p>我们的计算任务有返回值，所以我们直接继承<code>RecursiveTask</code>就好了，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SumTask</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THRESHOLD = <span class="number">2000000</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span>[] numbers;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> start;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> end;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SumTask</span><span class="params">(<span class="keyword">long</span>[] numbers, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.numbers = numbers;</span><br><span class="line">        <span class="keyword">this</span>.start = start;</span><br><span class="line">        <span class="keyword">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Long <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断问题规模</span></span><br><span class="line">        <span class="keyword">if</span> ((end - start) &lt;= THRESHOLD) &#123;</span><br><span class="line">            <span class="keyword">long</span> result = <span class="number">0L</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt;= end; i++) &#123;</span><br><span class="line">                result += numbers[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将任务分割为多个小任务</span></span><br><span class="line">        <span class="keyword">int</span> middle = (start + end) / <span class="number">2</span>;</span><br><span class="line">        SumTask taskLeft = <span class="keyword">new</span> SumTask(numbers, start, middle);</span><br><span class="line">        SumTask taskRight = <span class="keyword">new</span> SumTask(numbers, middle + <span class="number">1</span>, end);</span><br><span class="line">        invokeAll(taskLeft, taskRight);</span><br><span class="line">        <span class="keyword">long</span> result = taskLeft.join() + taskRight.join();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们需要重写<code>RecursiveTask</code>类的<code>compute()</code>方法，在该方法中进行任务的分割操作。和开始我们见到的伪代码类似，先判断任务规模（其实也是递归终止条件），相当于一个阈值，任务规模小于这个阈值，直接进行计算；大于这个阈值，将任务一份为二，这样递归下去，直至任务不可再分。注意这里我们采用<code>invokeAll</code>来进行任务分割，不过很多网上的例子采用的是如下写法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 分别对子任务调用fork():</span><br><span class="line">subTask1.fork();</span><br><span class="line">subTask2.fork();</span><br></pre></td></tr></table></figure><p>在JDK官方例子中，这种写法是没有出现过的，也是不正确的，原因后面再分析。</p><p>Fork/Join框架提供了<code>ForkJoinPool</code>来执行我们分割好的任务，<code>pool.invoke(task)</code>来提交一个Fork/Join任务并发执行，然后获得异步执行的结果。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForkJoinCalculatorImpl</span> <span class="keyword">implements</span> <span class="title">Calculator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ForkJoinPool pool;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">sum</span><span class="params">(<span class="keyword">long</span>[] source)</span> </span>&#123;</span><br><span class="line">        pool = <span class="keyword">new</span> ForkJoinPool();</span><br><span class="line">        SumTask task = <span class="keyword">new</span> SumTask(source, <span class="number">0</span>, source.length - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> pool.invoke(task);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在利用Fork/Join计算任务时，可能会出现<code>StackOverflowError</code>，这是由于递归层数太深，导致超出JDK的设置，需要重新评估任务分割的程度或者调整大小。</p><p>如果任务分割不正确，还会抛出以下异常，需要关注：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.lang.NoClassDefFoundError: Could not initialize class java.util.concurrent.locks.AbstractQueuedSynchronizer$Node</span><br></pre></td></tr></table></figure><h3 id="计算耗时（基础测试）"><a href="#计算耗时（基础测试）" class="headerlink" title="计算耗时（基础测试）"></a>计算耗时（基础测试）</h3><p>上面三种计算方式究竟计算效率怎么样呢？我们来写个测试类测试一把，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">long[] numbers = LongStream.rangeClosed(1L, 100000000L).toArray();</span><br><span class="line"></span><br><span class="line">// 1 直接for循环</span><br><span class="line">Calculator calculator = new ForLoopCalculatorImpl();</span><br><span class="line">long currentTime1 = System.currentTimeMillis();</span><br><span class="line">long result1 = calculator.sum(numbers);</span><br><span class="line">long executedTime = System.currentTimeMillis() - currentTime1;</span><br><span class="line">System.out.println(&quot;直接循环计算结果：&quot; + result1 + &quot;, 耗时：&quot; + executedTime);</span><br><span class="line"></span><br><span class="line">// 2 利用线程池</span><br><span class="line">Calculator calculator2 = new ExecutorServiceCalculatorImpl();</span><br><span class="line">long currentTime2 = System.currentTimeMillis();</span><br><span class="line">long result2 = calculator2.sum(numbers);</span><br><span class="line">long executedTime2 = System.currentTimeMillis() - currentTime2;</span><br><span class="line">System.out.println(&quot;线程池计算结果：&quot; + result2 + &quot;, 耗时：&quot; + executedTime2);</span><br><span class="line"></span><br><span class="line">// 3 fork/join</span><br><span class="line">Calculator calculator3 = new ForkJoinCalculatorImpl();</span><br><span class="line">long currentTime3 = System.currentTimeMillis();</span><br><span class="line">long result3 = calculator3.sum(numbers);</span><br><span class="line">long executedTime3 = System.currentTimeMillis() - currentTime3;</span><br><span class="line">System.out.println(&quot;Fork/Join计算结果：&quot; + result3 + &quot;, 耗时：&quot; + executedTime3);</span><br></pre></td></tr></table></figure><p>计算结果如下：</p><p><img src="https://github.com/ZZULI-TECH/interview/blob/master/images/concurrency/fj_calculator_result.png?raw=true" alt="image"></p><p>我用的是Window10操作系统，CPU i5 7代、4核心，跑的时候CPU飙到了100%，由于是计算密集型任务，需要CPU的全力参与，也无可厚非。。如下：</p><p><img src="https://github.com/ZZULI-TECH/interview/blob/master/images/concurrency/fj_cpu.png?raw=true" alt="image"></p><p>从上面的计算结果来看，Fork/Join耗时最少，线程池次之，直接For循环是耗时最多的，简直是难以置信啊，不过这个结果可能不稳定，至少也说明了Fork/Join在某些场景下比较优秀的事实（结论未必正确）。</p><h3 id="基准测试（JMH）"><a href="#基准测试（JMH）" class="headerlink" title="基准测试（JMH）"></a>基准测试（JMH）</h3><p>上面我们是利用方法执行的开始与结束时间的差值来评估方法的执行性能，利用这种方式得出的结论往往是站不住脚的（不严谨），因为没有考虑到程序在运行时JVM所带来的影响，所以得出的结论未必可靠，我们也不能乱下结论。</p><p>那么有没有一个比较靠谱的性能测试框架呢？JMH（Java Microbenchmark Harness）是一个面向Java语言或JVM平台语言的性能基准测试框架，它针对的是纳秒级别、微秒级别、毫秒级别以及秒级别的性能测试。听上去是不是很叼？我们就用它来测试上面写的三个计算任务吧。</p><p>首先我们需要用<code>@Benchmark</code>来标识JMH基准测试的测试方法，用法和Junit的<code>@Test</code>类似，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span>[] numbers = LongStream.rangeClosed(<span class="number">1L</span>, <span class="number">100_000_000L</span>).toArray();</span><br><span class="line"></span><br><span class="line"><span class="meta">@Benchmark</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1 直接for循环</span></span><br><span class="line">    Calculator calculator = <span class="keyword">new</span> ForLoopCalculatorImpl();</span><br><span class="line">    calculator.sum(numbers);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Benchmark</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 2 利用线程池</span></span><br><span class="line">    Calculator calculator2 = <span class="keyword">new</span> ExecutorServiceCalculatorImpl();</span><br><span class="line">    calculator2.sum(numbers);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Benchmark</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 3 fork/join</span></span><br><span class="line">    Calculator calculator3 = <span class="keyword">new</span> ForkJoinCalculatorImpl();</span><br><span class="line">    calculator3.sum(numbers);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>别忘了添加相关依赖哦，目前最新版本已是<code>1.21</code>，由于JMH性能测试是运行其提供的Main方法，需要添加maven相关插件配置运行Main方法，如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.openjdk.jmh&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;jmh-core&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;$&#123;jmh.version&#125;&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.openjdk.jmh&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;jmh-generator-annprocess&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;$&#123;jmh.version&#125;&lt;/version&gt;</span><br><span class="line">  &lt;scope&gt;provided&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>maven插件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-shade-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">phase</span>&gt;</span>package<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">goal</span>&gt;</span>shade<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">finalName</span>&gt;</span>java11-tutorial<span class="tag">&lt;/<span class="name">finalName</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">transformers</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transformer</span> <span class="attr">implementation</span>=<span class="string">"org.apache.maven.plugins.shade.resource.ManifestResourceTransformer"</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">mainClass</span>&gt;</span>org.openjdk.jmh.Main<span class="tag">&lt;/<span class="name">mainClass</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">transformer</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">transformers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure><p>接下来在该项目主目录下运行<code>maven clean package</code>进行编译打包，然后运行<code>java -jar target/java11-tutorial.jar</code> 直接执行测试，它的输出如下（重复的省略）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"># JMH version: 1.21</span><br><span class="line"># VM version: JDK 11, Java HotSpot(TM) 64-Bit Server VM, 11+28</span><br><span class="line"># VM invoker: F:\develope\Java\Java11\bin\java.exe</span><br><span class="line"># VM options: &lt;none&gt;</span><br><span class="line"># Warmup: 5 iterations, 10 s each</span><br><span class="line"># Measurement: 5 iterations, 10 s each</span><br><span class="line"># Timeout: 10 min per iteration</span><br><span class="line"># Threads: 1 thread, will synchronize iterations</span><br><span class="line"># Benchmark mode: Throughput, ops/time</span><br><span class="line"># Benchmark: me.mingshan.demo.fj.Test.test1</span><br><span class="line"></span><br><span class="line"># Run progress: 0.00% complete, ETA 00:25:00</span><br><span class="line"># Fork: 1 of 5</span><br><span class="line"># Warmup Iteration   1: 11.702 ops/s</span><br><span class="line"># Warmup Iteration   2: 11.902 ops/s</span><br><span class="line"># Warmup Iteration   3: 11.014 ops/s</span><br><span class="line"># Warmup Iteration   4: 10.663 ops/s</span><br><span class="line"># Warmup Iteration   5: 11.611 ops/s</span><br><span class="line">Iteration   1: 11.615 ops/s</span><br><span class="line">Iteration   2: 11.981 ops/s</span><br><span class="line">Iteration   3: 13.429 ops/s</span><br><span class="line">Iteration   4: 12.363 ops/s</span><br><span class="line">Iteration   5: 10.350 ops/s</span><br><span class="line"></span><br><span class="line">...运行五次</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Result &quot;me.mingshan.demo.fj.Test.test1&quot;:</span><br><span class="line">  11.492 ±(99.9%) 0.864 ops/s [Average]</span><br><span class="line">  (min, avg, max) = (9.804, 11.492, 14.808), stdev = 1.154</span><br><span class="line">  CI (99.9%): [10.628, 12.356] (assumes normal distribution)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># JMH version: 1.21</span><br><span class="line"># VM version: JDK 11, Java HotSpot(TM) 64-Bit Server VM, 11+28</span><br><span class="line"># VM invoker: F:\develope\Java\Java11\bin\java.exe</span><br><span class="line"># VM options: &lt;none&gt;</span><br><span class="line"># Warmup: 5 iterations, 10 s each</span><br><span class="line"># Measurement: 5 iterations, 10 s each</span><br><span class="line"># Timeout: 10 min per iteration</span><br><span class="line"># Threads: 1 thread, will synchronize iterations</span><br><span class="line"># Benchmark mode: Throughput, ops/time</span><br><span class="line"># Benchmark: me.mingshan.demo.fj.Test.test2</span><br><span class="line"></span><br><span class="line"># Run progress: 33.33% complete, ETA 00:16:59</span><br><span class="line"># Fork: 1 of 5</span><br><span class="line"># Warmup Iteration   1: 17.420 ops/s</span><br><span class="line"># Warmup Iteration   2: 15.220 ops/s</span><br><span class="line"># Warmup Iteration   3: 15.497 ops/s</span><br><span class="line"># Warmup Iteration   4: 14.617 ops/s</span><br><span class="line"># Warmup Iteration   5: 17.724 ops/s</span><br><span class="line">Iteration   1: 18.410 ops/s</span><br><span class="line">Iteration   2: 18.326 ops/s</span><br><span class="line">Iteration   3: 16.326 ops/s</span><br><span class="line">Iteration   4: 15.471 ops/s</span><br><span class="line">Iteration   5: 15.603 ops/s</span><br><span class="line"></span><br><span class="line">...运行五次</span><br><span class="line"></span><br><span class="line">Result &quot;me.mingshan.demo.fj.Test.test2&quot;:</span><br><span class="line">  16.358 ±(99.9%) 1.549 ops/s [Average]</span><br><span class="line">  (min, avg, max) = (11.898, 16.358, 18.918), stdev = 2.068</span><br><span class="line">  CI (99.9%): [14.809, 17.907] (assumes normal distribution)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># JMH version: 1.21</span><br><span class="line"># VM version: JDK 11, Java HotSpot(TM) 64-Bit Server VM, 11+28</span><br><span class="line"># VM invoker: F:\develope\Java\Java11\bin\java.exe</span><br><span class="line"># VM options: &lt;none&gt;</span><br><span class="line"># Warmup: 5 iterations, 10 s each</span><br><span class="line"># Measurement: 5 iterations, 10 s each</span><br><span class="line"># Timeout: 10 min per iteration</span><br><span class="line"># Threads: 1 thread, will synchronize iterations</span><br><span class="line"># Benchmark mode: Throughput, ops/time</span><br><span class="line"># Benchmark: me.mingshan.demo.fj.Test.test3</span><br><span class="line"></span><br><span class="line"># Run progress: 66.67% complete, ETA 00:08:29</span><br><span class="line"># Fork: 1 of 5</span><br><span class="line"># Warmup Iteration   1: 14.169 ops/s</span><br><span class="line"># Warmup Iteration   2: 14.925 ops/s</span><br><span class="line"># Warmup Iteration   3: 14.652 ops/s</span><br><span class="line"># Warmup Iteration   4: 14.448 ops/s</span><br><span class="line"># Warmup Iteration   5: 14.090 ops/s</span><br><span class="line">Iteration   1: 14.948 ops/s</span><br><span class="line">Iteration   2: 15.234 ops/s</span><br><span class="line">Iteration   3: 15.371 ops/s</span><br><span class="line">Iteration   4: 15.451 ops/s</span><br><span class="line">Iteration   5: 18.772 ops/s</span><br><span class="line"></span><br><span class="line">...运行五次</span><br><span class="line"></span><br><span class="line">Result &quot;me.mingshan.demo.fj.Test.test3&quot;:</span><br><span class="line">  17.366 ±(99.9%) 0.902 ops/s [Average]</span><br><span class="line">  (min, avg, max) = (14.948, 17.366, 19.462), stdev = 1.204</span><br><span class="line">  CI (99.9%): [16.465, 18.268] (assumes normal distribution)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Run complete. Total time: 00:25:27</span><br><span class="line"></span><br><span class="line">REMEMBER: The numbers below are just data. To gain reusable insights, you need to follow up on</span><br><span class="line">why the numbers are the way they are. Use profilers (see -prof, -lprof), design factorial</span><br><span class="line">experiments, perform baseline and negative tests that provide experimental control, make sure</span><br><span class="line">the benchmarking environment is safe on JVM/OS/HW level, ask for reviews from the domain experts.</span><br><span class="line">Do not assume the numbers tell you what you want them to tell.</span><br><span class="line"></span><br><span class="line">Benchmark    Mode  Cnt   Score   Error  Units</span><br><span class="line">Test.test1  thrpt   25  11.492 ± 0.864  ops/s</span><br><span class="line">Test.test2  thrpt   25  16.358 ± 1.549  ops/s</span><br><span class="line">Test.test3  thrpt   25  17.366 ± 0.902  ops/s</span><br></pre></td></tr></table></figure><p>其中<code>Fork：1 of 5</code>指的是JMH会Fork出一个新的虚拟机，来运行基准测试，目的是获得一个相对干净的运行环境，每个 Fork 包含了 5 个预热迭代（warmup iteration，如# Warmup Iteration   1: 14.169 ops/s）和5个测试迭代（measurement iteration，如Iteration   5: 18.772 ops/s）。</p><p>每次迭代后面的数据代表本次迭代的吞吐量，即每秒运行的次数（ops/s），也就是一次操作调用了一次测试方法。</p><p>好了，我们直接来看性能测试结果吧，如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Benchmark    Mode  Cnt   Score   Error  Units</span><br><span class="line">Test.test1  thrpt   25  11.492 ± 0.864  ops/s</span><br><span class="line">Test.test2  thrpt   25  16.358 ± 1.549  ops/s</span><br><span class="line">Test.test3  thrpt   25  17.366 ± 0.902  ops/s</span><br></pre></td></tr></table></figure><p>上面的输出便是本次基准测试的结果，主要关注Score和Error，Socre代表本次基准测试的平均吞吐量（每秒运行test*的次数），Error代表误差范围，所以。。。test1代表For循环串性执行，test2代表线程池并发执行，test3代表Fork/Join执行，结果很明显，Fork/Join每秒执行次数最多，线程池并发执行次之，For循环串性执行最少。</p><p>综合以上，我们可以小心翼翼地得出结论（怕被打。。），Fork/Join在计算密集型任务执行效率上是很好的，推荐大家使用。（完毕）</p><h2 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h2><p>目前先不分析，后面再写一遍文章。</p><p>参考：</p><ul><li><a href="http://gee.cs.oswego.edu/dl/papers/fj.pdf" target="_blank" rel="noopener">A Java Fork/Join Framework</a></li><li><a href="https://www.oracle.com/technetwork/cn/articles/java/fork-join-422606-zhs.html" target="_blank" rel="noopener">分解和合并：Java 也擅长轻松的并行编程！</a></li><li><a href="https://docs.oracle.com/javase/tutorial/essential/concurrency/forkjoin.html" target="_blank" rel="noopener">Fork/Join tutorial</a></li><li><a href="https://www.jianshu.com/p/f777abb7b251" target="_blank" rel="noopener">jdk1.8-ForkJoin框架剖析</a></li><li><a href="http://blog.dyngr.com/blog/2016/09/15/java-forkjoinpool-internals/" target="_blank" rel="noopener">Java 并发编程笔记：如何使用 ForkJoinPool 以及原理</a></li><li><a href="http://openjdk.java.net/projects/code-tools/jmh/" target="_blank" rel="noopener">Code Tools: jmh</a></li><li><a href="https://time.geekbang.org/column/article/40275" target="_blank" rel="noopener">基准测试框架JMH（上）</a></li><li><a href="https://time.geekbang.org/column/article/40281" target="_blank" rel="noopener">基准测试框架JMH（下）</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;熟悉Java Stream API的同学可能知道可以利用&lt;code&gt;parallelStream&lt;/code&gt;来实现并行操作，而Stream的并行操作依赖JDK1.7引入的Fork/Join框架，提供实现并行编程的一种方案。下面是Doug Lea对并行编程的描述：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;(recursively) splitting them into subtasks that are solved in&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;parallel, waiting for them to complete, and then composing&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;results.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Java" scheme="http://mingshan.me/categories/Java/"/>
    
      <category term="JUC" scheme="http://mingshan.me/categories/Java/JUC/"/>
    
    
      <category term="java" scheme="http://mingshan.me/tags/java/"/>
    
      <category term="JUC" scheme="http://mingshan.me/tags/JUC/"/>
    
  </entry>
  
  <entry>
    <title>IDEA中Maven配置JDK11进行编译</title>
    <link href="http://mingshan.me/2018/10/13/IDEA%E4%B8%ADMaven%E9%85%8D%E7%BD%AEJDK11%E8%BF%9B%E8%A1%8C%E7%BC%96%E8%AF%91/"/>
    <id>http://mingshan.me/2018/10/13/IDEA中Maven配置JDK11进行编译/</id>
    <published>2018-10-12T16:00:00.000Z</published>
    <updated>2018-10-13T08:13:12.036Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>前几天JDK11发布了不是，所以赶紧下载体验一番，我用的是IDEA编辑器(IntelliJ IDEA 2018.2.4 x64)，注意IDEA也要更新到最新版，用Maven编译的话需要进行相关配置，在此记录一下。</p><a id="more"></a><p>首先需要配置JDK的环境变量，配置好了显示如下：</p><p><img src="https://github.com/ZZULI-TECH/interview/blob/master/images/jdk11-version.png?raw=true" alt="image"></p><p>然后进入到IDEA中，配置项目使用的JDK版本，依次点击<code>File -&gt; Project Structure</code>，然后找到<code>Project SDK</code>选项，配置如下：</p><p><img src="https://github.com/ZZULI-TECH/interview/blob/master/images/jdk11-project-structure.png?raw=true" alt="image"></p><p>接下来配置Maven的JDK版本，点击<code>File -&gt; Settings -&gt; Build, Execution, Deployment -&gt; Build Tools -&gt; Maven</code>，然后选择<code>Runner</code>，配置Maven使用的JDK版本，配置页面如下：</p><p><img src="https://github.com/ZZULI-TECH/interview/blob/master/images/jdk11-maven-settings.png?raw=true" alt="image"></p><p>最后配置下maven的pom.xml文件，将目标编译版本改为JDK11，配置如下</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>11<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>11<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">finalName</span>&gt;</span>java11-tutorial<span class="tag">&lt;/<span class="name">finalName</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">source</span>&gt;</span>11<span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">target</span>&gt;</span>11<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><p>刷新maven项目，试着编译下，可以看到已经使用JDK11编译了：</p><p><img src="https://github.com/ZZULI-TECH/interview/blob/master/images/jdk11-build-output.png?raw=true" alt="image"></p><p>看下编译后的字节码的大小版本号，利用HexPad编辑器打开class文件，如下。可以看到minor_version为 0x0000, major_version为0x0037，而0x0037的十进制表示为55，即用jdk11编译的，准确无误。</p><p><img src="https://github.com/ZZULI-TECH/interview/blob/master/images/jdk11-class-version.png?raw=true" alt="image"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前几天JDK11发布了不是，所以赶紧下载体验一番，我用的是IDEA编辑器(IntelliJ IDEA 2018.2.4 x64)，注意IDEA也要更新到最新版，用Maven编译的话需要进行相关配置，在此记录一下。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://mingshan.me/categories/Java/"/>
    
    
      <category term="java" scheme="http://mingshan.me/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Callable&amp;Future及FutureTask实现分析(JDK11)</title>
    <link href="http://mingshan.me/2018/10/13/Callable&amp;Future%E5%8F%8AFutureTask%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90(JDK11)/"/>
    <id>http://mingshan.me/2018/10/13/Callable&amp;Future及FutureTask实现分析(JDK11)/</id>
    <published>2018-10-12T16:00:00.000Z</published>
    <updated>2018-10-22T14:05:22.233Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Callable"><a href="#Callable" class="headerlink" title="Callable"></a>Callable</h2><p>在Java中我们知道创建一个线程可以继承<code>Thread</code>类或者实现<code>Runnable</code>接口，JDK1.5之后在<code>java.util.concurrent</code>提供了<code>Callable</code>接口，该接口设计类似<code>Runnable</code>接口，不过<code>Callable</code>接口可以返回任务执行的结果，并且在执行任务过程中可能会抛出异常，而<code>Runnable</code>却不会。下面是<code>Callable</code>接口的定义：</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callable</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Computes a result, or throws an exception if unable to do so.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> computed result</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception if unable to compute a result</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">V <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Callable</code>接口中只定义了一个<code>call()</code>方法，该方法会返回一个计算结果，类型与传入的泛型一致。既然是接口，那么在哪里用到呢？下面是一个与<code>FutureTask</code>结合的例子，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallableTest</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException,</span></span><br><span class="line"><span class="function">        ExecutionException </span>&#123;</span><br><span class="line">        FutureTask&lt;String&gt; future = <span class="keyword">new</span> FutureTask&lt;&gt;(<span class="keyword">new</span> CallableTest());</span><br><span class="line">        <span class="keyword">new</span> Thread(future).start();</span><br><span class="line">        System.out.println(future.get());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以发现将 <code>Callable</code>的实现类传给<code>FutureTask</code>，然后利用线程来运行<code>FutureTask</code>，最终调用<code>get()</code>方法获取计算结果。</p><h2 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h2><p><code>FutureTask</code>是一个可取消的异步计算，该类提供了<code>Future</code>的基本实现，那么<code>Future</code>是怎么回事呢？<code>Future</code>接口提供了如下方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Future</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 试图取消此任务的执行。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> mayInterruptIfRunning)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果此任务在正常完成之前被取消，则返回true。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isCancelled</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果任务完成，返回true。完成可能是由于正常终止、异常或取消——在所有这些情况下，该方法将返回true。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isDone</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 等待计算完成，返回计算结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在给定的时间内等待计算完成，然后返回计算结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">V <span class="title">get</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Future</code>表示异步计算的结果，同时提供了用于检查计算是否完成、等待其完成以及检索计算结果的方法。下面是对这些方面的具体描述：</p><ul><li><code>cancel(boolean mayInterruptIfRunning)</code>：试图取消任务的执行。如果任务已经完成、已被取消或由于其他原因无法取消，则此尝试将失败。如果成功，并且在调用cancel时该任务尚未启动，则该任务永远不会运行。参数mayInterruptIfRunning表示是否允许取消正在执行却没有执行完毕的任务。在此方法返回后，对<code>isDone</code>的后续调用将始终返回<code>true</code>。如果该方法返回<code>true</code>，则对<code>isCancelled</code>的后续调用将始终返回<code>true</code>。</li><li><code>isCancelled</code> : 如果此任务在正常完成之前被取消，则返回true。</li><li><code>isDone</code>：如果任务完成，返回true。在正常终止、异常或取消情况下导致任务完成，该方法将返回true。</li><li><code>get</code>：等待计算完成，返回计算结果，期间会被阻塞。注意该方法会抛出异常，<ul><li>CancellationException - 如果计算被取消</li><li>ExecutionException - 如果在计算抛出异常</li><li>InterruptedException - 如果当前线程在等待时被中断</li></ul></li><li><code>get(long timeout, TimeUnit unit)</code>：在给定的时间内等待计算完成，然后返回计算结果。注意该方法也会抛出异常：<ul><li>CancellationException - 如果计算被取消</li><li>ExecutionException - 如果在计算抛出异常</li><li>InterruptedException - 如果当前线程在等待时被中断</li><li>TimeoutException - 等待超时</li></ul></li></ul><p>感觉<code>Future</code>的API设计的十分简洁明了，定义了对异步计算的常用操作，由于<code>Future</code>只是接口，刚才提到的<code>FutureTask</code>是JDK提供的一种实现，所以我们需要了解一下<code>Future</code>接口的方法是如何实现异步计算并拿到结果的。</p><h2 id="FutureTask"><a href="#FutureTask" class="headerlink" title="FutureTask"></a>FutureTask</h2><p><code>FutureTask</code>的类图如下所示，该类实现了<code>RunnableFuture</code><br>接口，<code>RunnableFuture</code>接口继承自<code>Runnable</code>和<code>Future</code>，所以该类既可以交给Thread去执行，又可以作为<code>Future</code>来获取计算结果。</p><p><img src="https://github.com/ZZULI-TECH/interview/blob/master/images/FutureTask_class.png?raw=true" alt="image"></p><h3 id="构造函数及state"><a href="#构造函数及state" class="headerlink" title="构造函数及state"></a>构造函数及state</h3><p>打开<code>FutureTask</code>类的源码，我们首先来看看其构造函数的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FutureTask</span><span class="params">(Callable&lt;V&gt; callable)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (callable == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">this</span>.callable = callable;</span><br><span class="line">    <span class="keyword">this</span>.state = NEW;       <span class="comment">// ensure visibility of callable</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FutureTask</span><span class="params">(Runnable runnable, V result)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.callable = Executors.callable(runnable, result);</span><br><span class="line">    <span class="keyword">this</span>.state = NEW;       <span class="comment">// ensure visibility of callable</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于第一个构造函数，传入Callable的实现类，将其赋给FutureTask成员变量<code>callable</code>，同时设置state为<code>NEW</code>，state字段用来保存FutureTask内部的任务执行状态，一共有7中状态，每种状态及其对应的值如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NEW          = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COMPLETING   = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NORMAL       = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EXCEPTIONAL  = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED    = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INTERRUPTING = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INTERRUPTED  = <span class="number">6</span>;</span><br></pre></td></tr></table></figure><p>注意state是用<code>volatile</code>修饰，保证其在线程之间的可见性。在源码注释中，我们可以发现state所代表状态转换如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NEW -&gt; COMPLETING -&gt; NORMAL</span><br><span class="line">NEW -&gt; COMPLETING -&gt; EXCEPTIONAL</span><br><span class="line">NEW -&gt; CANCELLED</span><br><span class="line">NEW -&gt; INTERRUPTING -&gt; INTERRUPTED</span><br></pre></td></tr></table></figure><p>用图表示如下：<br><img src="https://github.com/ZZULI-TECH/interview/blob/master/images/FutureTask_state_transitions.png?raw=true" alt="image"></p><p>从图中仿佛可以看出该类通过改变state的状态来反映最后计算的结果。</p><h3 id="run"><a href="#run" class="headerlink" title="run"></a>run</h3><p>在创建了一个FutureTask实例之后，接下来就是在另一个线程中执行此Task，无论是直接创建Thead还是通过线程池，执行的都是<code>run()</code>方法，该方法代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (state != NEW ||</span><br><span class="line">        !RUNNER.compareAndSet(<span class="keyword">this</span>, <span class="keyword">null</span>, Thread.currentThread()))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Callable&lt;V&gt; c = callable;</span><br><span class="line">        <span class="keyword">if</span> (c != <span class="keyword">null</span> &amp;&amp; state == NEW) &#123;</span><br><span class="line">            V result;</span><br><span class="line">            <span class="keyword">boolean</span> ran;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                result = c.call();</span><br><span class="line">                ran = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                result = <span class="keyword">null</span>;</span><br><span class="line">                ran = <span class="keyword">false</span>;</span><br><span class="line">                setException(ex);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (ran)</span><br><span class="line">                set(result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// runner must be non-null until state is settled to</span></span><br><span class="line">        <span class="comment">// prevent concurrent calls to run()</span></span><br><span class="line">        runner = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// state must be re-read after nulling runner to prevent</span></span><br><span class="line">        <span class="comment">// leaked interrupts</span></span><br><span class="line">        <span class="keyword">int</span> s = state;</span><br><span class="line">        <span class="keyword">if</span> (s &gt;= INTERRUPTING)</span><br><span class="line">            handlePossibleCancellationInterrupt(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在run方法中，首先会判断state是否等于<code>NEW</code>，如果不等于<code>NEW</code>，说明此任务已经被执行过，或者由于其他原因被取消了，直接返回；</p><p>接下来会利用CAS将该类<code>volatile</code>修饰的<code>runner</code>成员变量设置为当前线程，注意在设置之前<code>runner</code>必须为null，设置失败也直接返回。由于我看的版本是JDK11，所以这里的CAS操作用的是JDK9引入的<code>VarHandle</code>(方法句柄)，用来代替<code>UnSafe</code>类，详情参考：<a href="http://mingshan.me/2018/10/05/%E7%94%A8Variable%20Handles%E6%9D%A5%E6%9B%BF%E6%8D%A2Unsafe/">用Variable Handles来替换Unsafe</a>，在FutureTask类中实现代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// VarHandle mechanics</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> VarHandle STATE;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> VarHandle RUNNER;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> VarHandle WAITERS;</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        MethodHandles.Lookup l = MethodHandles.lookup();</span><br><span class="line">        STATE = l.findVarHandle(FutureTask.class, <span class="string">"state"</span>, <span class="keyword">int</span>.class);</span><br><span class="line">        RUNNER = l.findVarHandle(FutureTask.class, <span class="string">"runner"</span>, Thread.class);</span><br><span class="line">        WAITERS = l.findVarHandle(FutureTask.class, <span class="string">"waiters"</span>, WaitNode.class);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ReflectiveOperationException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ExceptionInInitializerError(e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Reduce the risk of rare disastrous classloading in first call to</span></span><br><span class="line">    <span class="comment">// LockSupport.park: https://bugs.openjdk.java.net/browse/JDK-8074773</span></span><br><span class="line">    Class&lt;?&gt; ensureLoaded = LockSupport.class;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>检测过<code>state</code>和<code>runner</code>后，接着会调用传入的callable的<code>call()</code>方法，执行任务。如果抛出异常，将结果设置为<code>null</code>，调用<code>setException()</code>方法保存异常信息，下面是代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">setException</span><span class="params">(Throwable t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (STATE.compareAndSet(<span class="keyword">this</span>, NEW, COMPLETING)) &#123;</span><br><span class="line">        outcome = t;</span><br><span class="line">        STATE.setRelease(<span class="keyword">this</span>, EXCEPTIONAL); <span class="comment">// final state</span></span><br><span class="line">        finishCompletion();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>setException</code>方法中，有以下流程：</p><ul><li>利用CAS操作将state状态由<code>NEW</code>改为<code>COMPLETING</code>，如果操作成功；</li><li>把异常原因保存在<code>outcome</code>字段中，<code>outcome</code>字段用来保存任务执行结果或者异常原因；</li><li>利用CAS把当前任务状态从<code>COMPLETING</code>变更为<code>EXCEPTIONAL</code>，可以参考上面转换的图；</li><li>调用<code>finishCompletion()</code>通知和移除等待线程</li></ul><p>如果没发生异常，任务执行结束，调用<code>set(result)</code>方法设置计算结果，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(V v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (STATE.compareAndSet(<span class="keyword">this</span>, NEW, COMPLETING)) &#123;</span><br><span class="line">        outcome = v;</span><br><span class="line">        STATE.setRelease(<span class="keyword">this</span>, NORMAL); <span class="comment">// final state</span></span><br><span class="line">        finishCompletion();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们发现<code>set()</code>方法实现流程和<code>setException()</code>真像，只不过是state状态变化的差异，流程如下：</p><ul><li>利用CAS操作将state状态由<code>NEW</code>改为<code>COMPLETING</code>，如果操作成功；</li><li>把计算结果保存在outcome字段中，outcome字段用来保存任务执行结果或者异常原因；</li><li>利用CAS把当前任务状态从<code>COMPLETING</code>变更为<code>NORMAL</code>，可以参考上面转换的图；</li><li>调用<code>finishCompletion()</code>通知和移除等待线程</li></ul><p>计算完后，无论是否发生异常，都要执行finally语句块的方法，首先将runner设置为<code>null</code>，释放值等待gc回收，同时判断state的状态是否为<code>INTERRUPTING</code>，如果任务被中断，执行中断处理。</p><p>看完了run方法的实现，总结来说，利用CAS根据任务的执行情况更改state的值，其他方法再根据state的值做出相应的处理。</p><h3 id="get"><a href="#get" class="headerlink" title="get"></a>get</h3><p>由于FutureTask是Future的一个实现，所以它提供了获取计算结果的<code>get()</code>方法，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> CancellationException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = state;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * state小于等于COMPLETING，表示计算任务还未完成，</span></span><br><span class="line"><span class="comment">     * 所以调用awaitDone方法，让当前线程等待</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (s &lt;= COMPLETING)</span><br><span class="line">        s = awaitDone(<span class="keyword">false</span>, <span class="number">0L</span>);</span><br><span class="line">    <span class="comment">// 返回计算结果或抛出异常</span></span><br><span class="line">    <span class="keyword">return</span> report(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>FutureTask运行在一个线程里来执行计算任务，由于Future设计的是异步计算模式，那么当然应该考虑其他线程获取计算的结果，从get方法看到，如果state的值如果小于等于<code>COMPLETING</code>，说明计算任务还没完成，那么获取计算结果的线程必须等待，也就是被阻塞，具体的实现在<code>awaitDone</code>方法里，该方法有两个参数，第一个参数为是否有超时限制timed，第二个为等待时间nanos，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">awaitDone</span><span class="params">(<span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// The code below is very delicate, to achieve these goals:</span></span><br><span class="line">    <span class="comment">// - call nanoTime exactly once for each call to park</span></span><br><span class="line">    <span class="comment">// - if nanos &lt;= 0L, return promptly without allocation or nanoTime</span></span><br><span class="line">    <span class="comment">// - if nanos == Long.MIN_VALUE, don't underflow</span></span><br><span class="line">    <span class="comment">// - if nanos == Long.MAX_VALUE, and nanoTime is non-monotonic</span></span><br><span class="line">    <span class="comment">//   and we suffer a spurious wakeup, we will do no worse than</span></span><br><span class="line">    <span class="comment">//   to park-spin for a while</span></span><br><span class="line">    <span class="keyword">long</span> startTime = <span class="number">0L</span>;    <span class="comment">// Special value 0L means not yet parked</span></span><br><span class="line">    WaitNode q = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">boolean</span> queued = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> s = state;</span><br><span class="line">        <span class="comment">// 计算已完成，直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (s &gt; COMPLETING) &#123;</span><br><span class="line">            <span class="keyword">if</span> (q != <span class="keyword">null</span>)</span><br><span class="line">                q.thread = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;<span class="comment">// 正在计算，让出时间片等待计算完成</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s == COMPLETING)</span><br><span class="line">            <span class="comment">// We may have already promised (via isDone) that we are done</span></span><br><span class="line">            <span class="comment">// so never return empty-handed or throw InterruptedException</span></span><br><span class="line">            Thread.yield();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">            <span class="comment">//  当前线程被中断（中断标志位为true），</span></span><br><span class="line">            <span class="comment">//  那么从列表中移除节点q，并抛出InterruptedException异常</span></span><br><span class="line">            removeWaiter(q);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125; <span class="comment">// 判断当前线程包装的等待节点是否为空</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (q == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果设置等待，但等待时间为0，直接返回</span></span><br><span class="line">            <span class="keyword">if</span> (timed &amp;&amp; nanos &lt;= <span class="number">0L</span>)</span><br><span class="line">                <span class="keyword">return</span> s;</span><br><span class="line">            <span class="comment">// 新建等待节点</span></span><br><span class="line">            q = <span class="keyword">new</span> WaitNode();</span><br><span class="line">        &#125;<span class="comment">// 判断是否入队</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!queued)</span><br><span class="line">            <span class="comment">//未入队时，使用CAS将新节点添加到链表中，如果添加失败，那么queued为false</span></span><br><span class="line">            queued = WAITERS.weakCompareAndSet(<span class="keyword">this</span>, q.next = waiters, q);</span><br><span class="line">        <span class="comment">// 判断是否设置超时</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (timed) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> parkNanos;</span><br><span class="line">            <span class="comment">// 第一次执行，初始化 startTime</span></span><br><span class="line">            <span class="keyword">if</span> (startTime == <span class="number">0L</span>) &#123; <span class="comment">// first time</span></span><br><span class="line">                startTime = System.nanoTime();</span><br><span class="line">                <span class="keyword">if</span> (startTime == <span class="number">0L</span>)</span><br><span class="line">                    startTime = <span class="number">1L</span>;</span><br><span class="line">                parkNanos = nanos;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 计算当前已用时间</span></span><br><span class="line">                <span class="keyword">long</span> elapsed = System.nanoTime() - startTime;</span><br><span class="line">                <span class="comment">// 如果当前已用时间大于设置的超时时间，移除队列中的结点，直接返回</span></span><br><span class="line">                <span class="keyword">if</span> (elapsed &gt;= nanos) &#123;</span><br><span class="line">                    removeWaiter(q);</span><br><span class="line">                    <span class="keyword">return</span> state;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 计算剩余时间</span></span><br><span class="line">                parkNanos = nanos - elapsed;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// nanoTime may be slow; recheck before parking</span></span><br><span class="line">            <span class="comment">// 挂起当前线程，让当前线程等待nanos时间</span></span><br><span class="line">            <span class="keyword">if</span> (state &lt; COMPLETING)</span><br><span class="line">                LockSupport.parkNanos(<span class="keyword">this</span>, parkNanos);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">// 未设置等待时间，那就等着吧</span></span><br><span class="line">            LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在FutureTask类中有一个成员变量<code>waiters</code>，声明如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Treiber stack of waiting threads */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> WaitNode waiters;</span><br></pre></td></tr></table></figure><p><code>WaitNode</code>是一个静态内部类，数据结构为单链表，用来记录等待的线程，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Simple linked list nodes to record waiting threads in a Treiber</span></span><br><span class="line"><span class="comment"> * stack.  See other classes such as Phaser and SynchronousQueue</span></span><br><span class="line"><span class="comment"> * for more detailed explanation.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">WaitNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">volatile</span> Thread thread;</span><br><span class="line">    <span class="keyword">volatile</span> WaitNode next;</span><br><span class="line">    WaitNode() &#123; thread = Thread.currentThread(); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的代码来看，在<code>awaitDone</code>方法内部存在着一个死循环，死循环内部流程如下：</p><ol><li>首先判断state的值，<ul><li>如果值大于<code>COMPLETING</code>，代表计算已完成（包括抛出异常等），直接返回；</li><li>如果值等于<code>COMPLETING</code>，代表正在执行计算，调用<code>Thread.yield()</code>让出时间片等待计算完成</li></ul></li><li>如果当前线程被中断（中断标志位为true），那么从列表中移除节点q，并抛出<code>InterruptedException</code>；</li><li>如果当前线程包装的等待节点为空，判断是否设置等待，并且等待时间为0，直接返回，否则创建等待节点；</li><li>如果没有入队，使用CAS将新节点添加到链表中，如果添加失败，那么queued为false</li><li>如果设置超时，判断当前计算任务是否在超时时间内，<ul><li>如果不在，移除队列中的结点，直接返回</li><li>如果在，计算剩余时间，挂起当前线程，让当前线程等待剩下的时间</li></ul></li><li>未设置等待时间，直接进行线程挂起操作，线程状态变为等待。</li></ol><p>当线程被解除挂起，或计算已经完成后，在<code>get</code>方法中将会调用<code>report</code>方法返回结果，其实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns result or throws exception for completed task.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> s completed state value</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="function"><span class="keyword">private</span> V <span class="title">report</span><span class="params">(<span class="keyword">int</span> s)</span> <span class="keyword">throws</span> ExecutionException </span>&#123;</span><br><span class="line">    Object x = outcome;</span><br><span class="line">    <span class="keyword">if</span> (s == NORMAL)</span><br><span class="line">        <span class="keyword">return</span> (V)x;</span><br><span class="line">    <span class="keyword">if</span> (s &gt;= CANCELLED)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> CancellationException();</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ExecutionException((Throwable)x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>如果state等于<code>NORMAL</code>，代表计算正常结束，返回结果；</li><li>如果state等于<code>CANCELLED</code>，代表计算被取消，抛出<code>CancellationException</code>；</li><li>如果计算以异常结束，即状态是<code>EXCEPTIONAL</code>，那么抛出<code>ExecutionException</code>。</li></ol><h3 id="finishCompletion"><a href="#finishCompletion" class="headerlink" title="finishCompletion"></a>finishCompletion</h3><p>在<code>run</code>方法中调用<code>set</code>和<code>setException</code>时最后一步是执行<code>finishCompletion</code>方法，那么这个方法是来干什么的呢？我们来看看它的实现吧：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Removes and signals all waiting threads, invokes done(), and</span></span><br><span class="line"><span class="comment"> * nulls out callable.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">finishCompletion</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert state &gt; COMPLETING;</span></span><br><span class="line">    <span class="keyword">for</span> (WaitNode q; (q = waiters) != <span class="keyword">null</span>;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (WAITERS.weakCompareAndSet(<span class="keyword">this</span>, q, <span class="keyword">null</span>)) &#123;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                Thread t = q.thread;</span><br><span class="line">                <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    q.thread = <span class="keyword">null</span>;</span><br><span class="line">                    LockSupport.unpark(t);</span><br><span class="line">                &#125;</span><br><span class="line">                WaitNode next = q.next;</span><br><span class="line">                <span class="keyword">if</span> (next == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                q.next = <span class="keyword">null</span>; <span class="comment">// unlink to help gc</span></span><br><span class="line">                q = next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    done();</span><br><span class="line"></span><br><span class="line">    callable = <span class="keyword">null</span>;        <span class="comment">// to reduce footprint</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>刚才我们看<code>get</code>方法的实现时，发现有一个<code>WaitNode</code>的单链表结构，里面存储着等待着的线程，所以在计算完成时，需要唤醒那些还在等待着的线程，毕竟计算任务都做完了（异常也算结束），总不能让那些阻塞的线程干等着吧，所以在<code>finishCompletion</code>方法中就遍历单链表，利用CAS将FutureTask中的waiters设置为<code>null</code>，调用<code>LockSupport.unpark</code>唤醒线程，当线程被释放后，那么在awaitDone的死循环中就会进入下一个循环，由于状态已经变成了<code>NORMAL</code>或者<code>EXCEPTIONAL</code>，将会直接跳出循环。</p><p>当所有等待线程都唤醒后，直接调用<code>done</code>方法，<code>done</code>方法是个<code>protected</code>修饰的方法，FutureTask没有做相关实现，所以如果在计算完成后需要特殊处理，子类可以重写<code>done</code>方法。</p><h3 id="cancel"><a href="#cancel" class="headerlink" title="cancel"></a>cancel</h3><p>从Future接口的描述来看，它提供了<code>cancel</code>方法来取消正在执行的任务，FutureTask实现了<code>cancel</code>方法，我们来看看它的代码吧：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> mayInterruptIfRunning)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!(state == NEW &amp;&amp; STATE.compareAndSet</span><br><span class="line">          (<span class="keyword">this</span>, NEW, mayInterruptIfRunning ? INTERRUPTING : CANCELLED)))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;    <span class="comment">// in case call to interrupt throws exception</span></span><br><span class="line">        <span class="keyword">if</span> (mayInterruptIfRunning) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread t = runner;</span><br><span class="line">                <span class="keyword">if</span> (t != <span class="keyword">null</span>)</span><br><span class="line">                    t.interrupt();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123; <span class="comment">// final state</span></span><br><span class="line">                STATE.setRelease(<span class="keyword">this</span>, INTERRUPTED);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        finishCompletion();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参数<code>mayInterruptIfRunning</code>指明是否应该中断正在运行的任务，</p><ul><li>如果参数为false，代表不需要中断，那么state的转换过程由<code>NEW-&gt;CANCELLED</code></li><li>如果参数为true，代表需要中断，那么state的转换过程将为<code>NEW-&gt;INTERRPUTING-&gt;INTERRUPTED</code>，并给当前线程设中断标志。</li></ul><p>无论是否中断，最终都会调用<code>finishCompletion()</code>方法来释放等待线程。</p><p>参考：</p><ul><li><a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/concurrent/Callable.html" target="_blank" rel="noopener">Callable DOC</a></li><li><a href="http://www.importnew.com/25286.html" target="_blank" rel="noopener">深入学习 FutureTask</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Callable&quot;&gt;&lt;a href=&quot;#Callable&quot; class=&quot;headerlink&quot; title=&quot;Callable&quot;&gt;&lt;/a&gt;Callable&lt;/h2&gt;&lt;p&gt;在Java中我们知道创建一个线程可以继承&lt;code&gt;Thread&lt;/code&gt;类或者实现&lt;code&gt;Runnable&lt;/code&gt;接口，JDK1.5之后在&lt;code&gt;java.util.concurrent&lt;/code&gt;提供了&lt;code&gt;Callable&lt;/code&gt;接口，该接口设计类似&lt;code&gt;Runnable&lt;/code&gt;接口，不过&lt;code&gt;Callable&lt;/code&gt;接口可以返回任务执行的结果，并且在执行任务过程中可能会抛出异常，而&lt;code&gt;Runnable&lt;/code&gt;却不会。下面是&lt;code&gt;Callable&lt;/code&gt;接口的定义：&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://mingshan.me/categories/Java/"/>
    
      <category term="JUC" scheme="http://mingshan.me/categories/Java/JUC/"/>
    
    
      <category term="java" scheme="http://mingshan.me/tags/java/"/>
    
      <category term="JUC" scheme="http://mingshan.me/tags/JUC/"/>
    
  </entry>
  
  <entry>
    <title>读过几本书，还是菜</title>
    <link href="http://mingshan.me/2018/10/07/%E8%AF%BB%E8%BF%87%E5%87%A0%E6%9C%AC%E4%B9%A6%EF%BC%8C%E8%BF%98%E6%98%AF%E8%8F%9C/"/>
    <id>http://mingshan.me/2018/10/07/读过几本书，还是菜/</id>
    <published>2018-10-06T16:00:00.000Z</published>
    <updated>2018-10-19T15:38:51.710Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>以前喜欢买书来看，有空捧着一本书静静的读着，这种感觉仿佛时间都停止了，现在参加了工作，时间变得相对少些，所以看电子书的频率高些，因为电子书看着方便，但对眼睛有伤害，看时间长了会眼睛疲劳，不过能过看书的瘾，也挺好^_^</p><a id="more"></a><p>下面是我近几年来看过和正在看的亦准备看到的书籍列表，不过有些已经忘记了。这些书藏匿着我旧日的时光，看到这些书，仿佛看到了过去的自己，为了避免以后忘却那些美好的旧日时光，亦是不对过去的背弃，记录下来吧。。</p><p>一个好的作品藏着作者的大悲大痛，大彻大悟，即使是最平淡的文字，也能体会到作者对生活、人性的思考，世上的一切本就平凡真切，或得道弃俗，或坠入俗世，也是我们的世界啊。</p><p>书富如入海，百货皆有。人之精力，不能兼收尽取，但得春所欲求者尔。故愿学者每次作一意求之。 —— 苏轼 《东坡文集事略》</p><p><strong>历史类：</strong></p><p>当年明月，《明朝那些事》<br>卢志丹，《毛泽东读二十四史》<br>高晓松，《鱼羊野史（全集）》（未读完）<br>王晓磊，《卑鄙的圣人：曹操（全集）》<br>洪钊，《明朝十讲》<br>张鸣，《大历史的边角料》（未读完）<br>吕思勉，《三国史话》<br>黄仁宇，《万历十五年（精装版）》<br>朱东润，《张居正大传》</p><p><strong>古代哲学</strong></p><p>孔子，《论语》<br>李耳，《道德经》<br>庄周，《庄子》<br>王阳明，《传习录》</p><p><strong>古代史书（未读完）</strong></p><p>司马迁，《史记》<br>陈寿，《三国志》<br>司马光，《资治通鉴》<br>张廷玉，《明史》</p><p><strong>明清书籍</strong></p><p>金圣叹，《贯华堂选批唐才子诗》（在读）<br>刘鹗，《老残游记》<br>罗贯中，《三国演义》<br>袁枚，《子不语》<br>袁了凡，《了凡四训》<br>李淳风和袁天罡，《推背图（金圣叹批）》<br>吴趼人，《二十年目睹之怪现状》（在读）</p><p><strong>当代小说</strong></p><p>路遥，《平凡的世界》<br>路遥，《人生》<br>贾平凹，《商州》<br>贾平凹，《自在独行》（未读完）<br>慕容雪村，《多数人死于贪婪》<br>慕容雪村，《成都，今夜请将我遗忘》<br>慕容雪村，《天堂在左，深圳向右》<br>慕容雪村，《原谅我红尘颠倒》<br>刘瑜，《我在未来等你》<br>刘震云，《故乡天地黄花》<br>刘震云，《我叫刘跃进》<br>刘震云，《一句顶一万句》<br>余华，《许三观卖血记》（未读完）</p><p><strong>随笔散文</strong></p><p>路遥，《早晨从中午开始》<br>刘瑜，《送你一颗子弹》<br>黄仁宇，《地北天南叙古今（精装版）》（在读）<br>慕容雪村，《中国，少了一味药》<br>慕容雪村，《慕容雪村随笔集》<br>梁晓声，《中国人的日常》<br>王蒙，《一辈子的活法：王蒙的人生历练》（在读）</p><p><strong>科幻</strong></p><p>刘慈欣，《三体》</p><p><strong>外国文学</strong></p><p>培根，《培根随笔集》<br>圣埃克苏佩里，《小王子》（在读）</p><p><strong>技术书籍</strong></p><p>Joshua Bloch，《Effective Java 中文 第二版》<br>周志明，《深入理解Java虚拟机:JVM高级特性与最佳实践（第二版）》<br>刘欣，《码农翻身》<br>秦小波，《设计模式之禅》<br>啊哈磊，《啊哈！算法》</p><blockquote><p>—— 更新于2018/10/19</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;以前喜欢买书来看，有空捧着一本书静静的读着，这种感觉仿佛时间都停止了，现在参加了工作，时间变得相对少些，所以看电子书的频率高些，因为电子书看着方便，但对眼睛有伤害，看时间长了会眼睛疲劳，不过能过看书的瘾，也挺好^_^&lt;/p&gt;
    
    </summary>
    
      <category term="书籍" scheme="http://mingshan.me/categories/%E4%B9%A6%E7%B1%8D/"/>
    
    
  </entry>
  
  <entry>
    <title>Optional使用姿势</title>
    <link href="http://mingshan.me/2018/10/06/Optional%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF/"/>
    <id>http://mingshan.me/2018/10/06/Optional使用姿势/</id>
    <published>2018-10-05T16:00:00.000Z</published>
    <updated>2018-10-06T13:37:24.963Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Optional类是在JDK8引入的比较有用的一个类，主要用来解决空指针（NullPointerException）问题，我们知道在平时写代码的时候，首先就要避免代码中出现空指针异常，如下面的代码：</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Blog&gt; blogs = ...;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> (blogs != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (Blog blog : blogs) &#123;</span><br><span class="line">        List&lt;Image&gt; images = blog.getImages();</span><br><span class="line">        <span class="keyword">if</span> (images != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当代码层数多的时候，这种代码看着是极其难受的，所在就引入了Optional，该类结合函数式编程进行链式调用，用着那是十分爽的^_^</p><p>首先来看看Optional类的API，截图如下：</p><p><img src="https://github.com/ZZULI-TECH/interview/blob/master/images/Optionals-api.png?raw=true" alt="image"></p><p>我们先来关心这个类暴露的API，下面列举出该类常用的方法的签名，如下：</p><ul><li>public<u> Optional<u> map(Function&lt;? super T, ? extends U&gt; mapper)</u></u></li><li>public T orElse(T other)</li><li>public T orElseGet(Supplier&lt;? extends T&gt; other)</li><li>public void ifPresent(Consumer&lt;? super T&gt; consumer)</li><li>public Optional<t> filter(Predicate&lt;? super T&gt; predicate)</t></li><li>public<u> Optional<u> flatMap(Function&lt;? super T, Optional<u>&gt; mapper)</u></u></u></li><li>public <x extends="" throwable=""> T orElseThrow(Supplier&lt;? extends X&gt; exceptionSupplier) throws X</x></li><li>public Stream<t> stream()</t></li><li>public void ifPresentOrElse(Consumer&lt;? super T&gt; action, Runnable emptyAction) </li><li>public Optional<t> or(Supplier&lt;? extends Optional&lt;? extends T&gt;&gt; supplier)</t></li></ul><p>看到<code>Function</code>、<code>Supplier</code>、<code>Consumer</code>，如果对函数式编程熟悉的话就会知道Optional这个类的大部分方法支持lambda表达式，该类是经过官方精心设计的，目的是简化代码，优雅编程，哈哈，我们来看看该怎么用。</p><h2 id="创建Optional实例"><a href="#创建Optional实例" class="headerlink" title="创建Optional实例"></a>创建Optional实例</h2><p>要使用Optional，首先就要有一个Optional的实例，现在有三种方法获得该类的实例，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;User&gt; user = Optional.empty()</span><br><span class="line">Optional&lt;User&gt; user = Optional.of(user)</span><br><span class="line">Optional&lt;User&gt; user = Optional.ofNullable(user)</span><br></pre></td></tr></table></figure><p>在该类的源码中，调用<code>empty()</code>方法会返回一个不带值的Optional实例。可以使用<code>of()</code> 和 <code>ofNullable()</code> 方法创建包含值的 Optional，区别是如果传入的值是<code>null</code>，<code>of()</code>方法会抛出空指针异常（NullPointerException），而<code>ofNullable()</code>会调用<code>empty()</code>方法，返回一个不带值的Optional实例。</p><p>看到这我们会有疑惑，该类不是要解决空指针异常吗，为什么还要向外暴露<code>of()</code>方法呢？官方把这个方法暴露出来可能考虑到使用者已经确定传入的参数不可能为<code>null</code>，但又想使用该类的其他的API；或者使用者想提前处理空指针异常，不想让空指针异常藏匿于Optional中，这也是一种设计上的考虑，只不过使用者要注意两个方法的异同，不要使用错误即可。</p><h2 id="orElse-orElseGet-orElseThrow"><a href="#orElse-orElseGet-orElseThrow" class="headerlink" title="orElse / orElseGet / orElseThrow"></a>orElse / orElseGet / orElseThrow</h2><p>现在我们有了Optional实例，接下来我们可以通过<code>get()</code>访问Optional实例的值，如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Optional.of(user).get();</span><br></pre></td></tr></table></figure><p>我们也可以利用<code>ifPresent()</code>来判断Optional实例所携带的值是否为<code>null</code>，我们一拍脑袋，就可以能写出如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;User&gt; user = Optional.ofNullable(user);</span><br><span class="line"><span class="keyword">if</span> (user.isPresent()) &#123;</span><br><span class="line">    User result = user.get();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码貌似没什么问题，但仔细思考一下，这样写和直接进行空值判断有什么区别？答案是没区别，因为这样用完全没有体现到Optional的特性，JDK的作者肯定也不希望你这样用。所以<code>orElse</code> 和 <code>orElseGet</code>这两个方法就出现了，将上面的代码改写下，如果传入的值为<code>null</code>，就返回一个自己传入的值，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">User user = <span class="keyword">null</span>;</span><br><span class="line">User u = createNewUser();</span><br><span class="line"><span class="comment">// 使用orElse</span></span><br><span class="line">User result = Optional.ofNullable(user).orElse(u);</span><br><span class="line">assertEquals(u, result);</span><br><span class="line"><span class="comment">// 使用orElseGet</span></span><br><span class="line">User result2 = Optional.ofNullable(user).orElseGet(() -&gt; createNewUser());</span><br><span class="line">assertEquals(user, result2);</span><br></pre></td></tr></table></figure><p>这里有一点要注意，无论传入的值是否为<code>null</code>，<code>orElse</code>都会执行，但<code>orElseGet</code>只有在传入的值为<code>null</code>时才会执行，这也是两者大的区别，在执行相对耗时的任务时，注意不要用错，否则这个差异会对性能产生重大影响。</p><p>如果传入的值为<code>null</code>时还有抛出其他异常的需要，就可以使用<code>orElseThrow</code>，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">User user = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">User result = Optional.ofNullable(user)</span><br><span class="line">        .orElseThrow(() -&gt; <span class="keyword">new</span> IllegalArgumentException());</span><br></pre></td></tr></table></figure><h2 id="map-flatMap-转换值"><a href="#map-flatMap-转换值" class="headerlink" title="map / flatMap 转换值"></a>map / flatMap 转换值</h2><p>现在我们已经可以根据传入值是否为<code>null</code>来返回不同的值了，而且没有空指针异常，但像下面的代码，我们需要对值进行多层转换，这时我们就需要用到<code>map</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(user != <span class="keyword">null</span>) &#123;</span><br><span class="line">    String name = user.getName();</span><br><span class="line">    <span class="keyword">if</span> (name != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> name.toLowerCase();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码经过转换后，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">return Optional.ofNullable(user)</span><br><span class="line">        .map(u -&gt; u.getName())</span><br><span class="line">        .map(name -&gt; name.toLowerCase())</span><br><span class="line">        .orElse(null);</span><br></pre></td></tr></table></figure><p>是不是既简洁又很帅？<code>map</code>方法通过传入的lambda表达式对值进行处理，然后将返回的值包装在 Optional 中，所以<code>map</code>方法可以多次调用，真的很好用。</p><p><code>map</code>方法是把结果自动封装成一个Optional，但是<code>flatmap</code>方法需要你自己去封装，这是两者的区别，<code>flatmap</code>方法相对来说比较灵活。</p><h2 id="filter-过滤"><a href="#filter-过滤" class="headerlink" title="filter 过滤"></a>filter 过滤</h2><p>Optional提供过滤值功能，调用<code>filter</code>方法时传入过滤条件，返回测试结果为true的值。如果测试结果为false，会返回一个空的Optional。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">User user = <span class="keyword">new</span> User(<span class="number">22</span>, <span class="string">"walker"</span>);</span><br><span class="line">Optional&lt;User&gt; result = Optional.ofNullable(user)</span><br><span class="line">        .filter(u -&gt; u.getName().contains(<span class="string">"w"</span>) &amp;&amp; u.getAge() &gt; <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">assertTrue(result.isPresent());</span><br></pre></td></tr></table></figure><h2 id="Java-SE-9-Optional类改进"><a href="#Java-SE-9-Optional类改进" class="headerlink" title="Java SE 9:Optional类改进"></a>Java SE 9:Optional类改进</h2><p>在JDK9中，对Optional类进行增强，增加了如下几个方法：</p><ul><li>stream()</li><li>ifPresentOrElse()</li><li>or()</li></ul><h3 id="stream"><a href="#stream" class="headerlink" title="stream"></a>stream</h3><p>现在Optional可以直接转为stream 流来进行处理，这样我们就可以利用Stream对象强大丰富的API来实现我们的逻辑，示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">User user = <span class="keyword">new</span> User(<span class="number">22</span>, <span class="string">"walker"</span>);</span><br><span class="line">User user2 = <span class="keyword">new</span> User(<span class="number">19</span>, <span class="string">"walker2"</span>);</span><br><span class="line">List&lt;User&gt; users = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">users.add(user);</span><br><span class="line">users.add(user2);</span><br><span class="line"></span><br><span class="line">List&lt;String&gt; names = Optional.ofNullable(users)</span><br><span class="line">    .stream()</span><br><span class="line">    .flatMap(x -&gt; x.stream())</span><br><span class="line">    .filter(u -&gt; u.getName().contains(<span class="string">"w"</span>) &amp;&amp; u.getAge() &gt; <span class="number">19</span>)</span><br><span class="line">    .map(u -&gt; u.getName())</span><br><span class="line">    .collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">names.stream().forEach(System.out::println);</span><br></pre></td></tr></table></figure><h3 id="ifPresentOrElse"><a href="#ifPresentOrElse" class="headerlink" title="ifPresentOrElse()"></a>ifPresentOrElse()</h3><p><code>ifPresentOrElse()</code>方法需要两个参数：一个 Consumer 和一个 Runnable。如果对象包含值，会执行 Consumer 的动作，否则运行 Runnable。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">User user = <span class="keyword">null</span>;</span><br><span class="line">Optional.ofNullable(user)</span><br><span class="line">    .ifPresentOrElse(u -&gt; System.out.print(u), () -&gt; System.out.println(<span class="string">"User not found"</span>));</span><br></pre></td></tr></table></figure><h3 id="or"><a href="#or" class="headerlink" title="or()"></a>or()</h3><p><code>or()</code> 方法与 <code>orElse()</code> 和 <code>orElseGet()</code> 类似，它们都在传入值为空的时候提供了替代情况。但<code>or()</code>的返回值是由 Supplier 参数产生的另一个 Optional 对象。示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">User user = <span class="keyword">null</span>;</span><br><span class="line">User result = Optional.ofNullable(user)</span><br><span class="line">    .or(() -&gt; Optional.of(<span class="keyword">new</span> User(<span class="number">23</span>, <span class="string">"xcc"</span>))).get();</span><br><span class="line">assertEquals(<span class="number">23</span>, result.getAge());</span><br></pre></td></tr></table></figure><h2 id="使用注意"><a href="#使用注意" class="headerlink" title="使用注意"></a>使用注意</h2><ol><li>调用<code>get()</code>注意要用<code>isPresent()</code>方法进行检测，否则会抛出异常</li><li>不要将Optional 类型用作属性或是方法参数，Optional 类型不可被序列化, 用作字段类型会出问题的</li><li>尽量进行链式调用，这也是简化我们代码的利器。</li></ol><p>参考：</p><ul><li><a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Optional.html" target="_blank" rel="noopener">Optional Doc</a></li><li><a href="https://www.nurkiewicz.com/2013/08/optional-in-java-8-cheat-sheet.html" target="_blank" rel="noopener">Optional in Java 8 cheat sheet</a></li><li><a href="https://www.cnblogs.com/zhangboyu/p/7580262.html" target="_blank" rel="noopener">理解、学习与使用 JAVA 中的 OPTIONAL</a></li><li><a href="https://yanbin.blog/proper-ways-of-using-java8-optional/" target="_blank" rel="noopener">使用 Java8 Optional 的正确姿势</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Optional类是在JDK8引入的比较有用的一个类，主要用来解决空指针（NullPointerException）问题，我们知道在平时写代码的时候，首先就要避免代码中出现空指针异常，如下面的代码：&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://mingshan.me/categories/Java/"/>
    
    
      <category term="java" scheme="http://mingshan.me/tags/java/"/>
    
      <category term="Optional" scheme="http://mingshan.me/tags/Optional/"/>
    
  </entry>
  
  <entry>
    <title>用Variable Handles来替换Unsafe</title>
    <link href="http://mingshan.me/2018/10/05/%E7%94%A8Variable%20Handles%E6%9D%A5%E6%9B%BF%E6%8D%A2Unsafe/"/>
    <id>http://mingshan.me/2018/10/05/用Variable Handles来替换Unsafe/</id>
    <published>2018-10-04T16:00:00.000Z</published>
    <updated>2018-10-05T06:07:32.654Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在JDK9中，包含了一个叫Variable Handles的新功能，下面是该功能的描述：</p><a id="more"></a><blockquote><p>Define a standard means to invoke the equivalents of various java.util.concurrent.atomic and sun.misc.Unsafe operations upon object fields and array elements, a standard set of fence operations for fine-grained control of memory ordering, and a standard reachability-fence operation to ensure that a referenced object remains strongly reachable.</p></blockquote><p>从这段官方描述中我们可以得知，Variable Handles主要是提供<code>java.util.concurrent.atomic</code> 和 <code>sun.misc.Unsafe</code>相似的功能，但会更加安全和易用，并且在并发方面提高了性能。在Java并发包中，由于包中的类大量调用<code>sun.misc.Unsafe</code>提供的功能，官方现在已不推荐再使用<code>sun.misc.Unsafe</code>这个类了，所以看看这个功能十分有必要，例如在<code>AtomicIntegerArray</code>这个类中已经用Variable Handles替换了<code>sun.misc.Unsafe</code>，并且在CAS中也会用到。</p><p>说到CAS的应用，我们需要对某一字段进行原子更新，可能会用到以下几种方式：</p><ol><li>使用AtomicInteger类来更新，但会带来额外的内存消耗以及因引用替换带来的新的并发问题；</li><li>使用Atomic*FieldUpdater类来完成字段的原子更新，其是基于反射来实现的，对字段和包装类型有一定的限制，操作开销比较大；</li><li>使用<code>sun.misc.Unsafe</code>提供的JVM内置函数API，这个类提供不安全的操作，损害安全性和移植性，官方不允许开发者使用，以后也会被替代掉。</li></ol><p>变量句柄是对变量的类型化引用，它支持在各种访问模式下对变量的读写访问。支持的变量类型包括实例字段、静态字段和数组元素。下面我们来看看它的基础API如何使用。</p><p>创建VarHandle需要通过<code>MethodHandles</code>这个类调用其静态方法来实现，根据要访问类的不同类型的成员变量调用不同的静态方法：</p><ul><li><code>MethodHandles.lookup</code> 访问类非私有属性</li><li><code>MethodHandles.privateLookupIn</code> 访问类的私有属性</li><li><code>MethodHandles.arrayElementVarHandle</code> 访问类中的数组</li></ul><p>获取到Lookup，然后通过调用<code>findVarHandle</code>方法来获取<code>VarHandle</code>实例，在JDK9中，</p><ul><li><code>findVarHandle</code>：用于创建对象中非静态字段的VarHandle。接收参数有三个，第一个为接收者的Class对象，第二个是字段名称，第三个是字段类型。</li><li><code>findStaticVarHandle</code>：用于创建对象中静态字段的VarHandle，接收参数与findVarHandle一致。</li><li><code>unreflectVarHandle</code>：通过反射字段创建VarHandle。</li></ul><p>为了保证效率，VarHandle类的实例通常需要被声明为static final变量（其实就是常量），这样可以在编译期对它进行优化。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> VarHandle VH_TEST_FIELD_I;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> VarHandle VH_TEST_ARRAY;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> VarHandle VH_TEST_FIELD_J;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> j = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        VH_TEST_FIELD_I = MethodHandles.lookup()</span><br><span class="line">                .in(Test.class)</span><br><span class="line">                .findVarHandle(Test.class, <span class="string">"i"</span>, <span class="keyword">int</span>.class);</span><br><span class="line"></span><br><span class="line">        VH_TEST_ARRAY = MethodHandles.arrayElementVarHandle(<span class="keyword">int</span>[].class);</span><br><span class="line"></span><br><span class="line">        VH_TEST_FIELD_J = MethodHandles.privateLookupIn(Test.class, MethodHandles.lookup())</span><br><span class="line">                .findVarHandle(Test.class, <span class="string">"j"</span>, <span class="keyword">int</span>.class);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ReflectiveOperationException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Error(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取到了<code>VarHandle</code>实例，接下来可以做些什么呢？<code>VarHandle</code>提供了几种访问模式（access modes）：</p><ol><li>read access modes, such as reading a variable with volatile memory ordering effects;</li><li>write access modes, such as updating a variable with release memory ordering effects;</li><li>atomic update access modes, such as a compare-and-set on a variable with volatile memory order effects for both read and writing;</li><li>numeric atomic update access modes, such as get-and-add with plain memory order effects for writing and acquire memory order effects for reading.</li><li>bitwise atomic update access modes, such as get-and-bitwise-and with release memory order effects for writing and plain memory order effects for reading.</li></ol><p>后面三个访问模式被称为 <code>read-modify-write</code>。从上面5个访问模式来看，主要包括普通变量读写、volatile变量读写和CAS操作。示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// read</span></span><br><span class="line">    System.out.println(VH_this_FIELD_I.get(<span class="keyword">this</span>)); <span class="comment">// 1</span></span><br><span class="line">    System.out.println(VH_this_ARRAY.get(arr, <span class="number">2</span>)); <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// write</span></span><br><span class="line">    VH_this_FIELD_I.set(<span class="keyword">this</span>, <span class="number">99</span>);</span><br><span class="line">    System.out.println(VH_this_FIELD_I.get(<span class="keyword">this</span>)); <span class="comment">// 99</span></span><br><span class="line"></span><br><span class="line">    VH_this_ARRAY.set(arr, <span class="number">2</span>, <span class="number">4</span>);</span><br><span class="line">    System.out.println(VH_this_ARRAY.get(arr, <span class="number">2</span>)); <span class="comment">// 4</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// CAS</span></span><br><span class="line">    System.out.println(VH_this_FIELD_I.compareAndSet(<span class="keyword">this</span>, <span class="number">99</span>, <span class="number">3</span>)); <span class="comment">// true</span></span><br><span class="line">    System.out.println(VH_this_FIELD_I.get(<span class="keyword">this</span>)); <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">    System.out.println(VH_this_ARRAY.compareAndSet(arr, <span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>)); <span class="comment">// true</span></span><br><span class="line">    System.out.println(VH_this_ARRAY.get(arr, <span class="number">2</span>)); <span class="comment">// 8</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Numeric Atomic Update</span></span><br><span class="line">    System.out.println(VH_this_FIELD_I.getAndAdd(<span class="keyword">this</span>, <span class="number">6</span>)); <span class="comment">// 3</span></span><br><span class="line">    System.out.println(VH_this_FIELD_I.get(<span class="keyword">this</span>)); <span class="comment">// 9</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了上面的五中访问模式外，在<a href="http://openjdk.java.net/jeps/193" target="_blank" rel="noopener">JEP 193</a>的描述中，还提供了一组内存屏障（Memory fences）方法，为内存排序提供更细粒度的控制。其中涉及到<code>memory order</code>的概念，与最近的c++ 11内存模型一致，详情请参考其相关概念。</p><p>在想要利用CAS去实现我们的逻辑，首先推荐使用VarHandle来实现，它提供了精细粒度的API，更加安全，相信在以后的产品中应用会非常广泛。</p><p>参考：</p><ul><li><a href="http://openjdk.java.net/jeps/193" target="_blank" rel="noopener">JEP 193: Variable Handles</a></li><li><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/invoke/VarHandle.html" target="_blank" rel="noopener">VarHandle Doc</a></li><li><a href="https://www.jianshu.com/p/e231042a52dd" target="_blank" rel="noopener">Java 9 变量句柄-VarHandle</a></li><li><a href="https://cloud.tencent.com/developer/article/1005903" target="_blank" rel="noopener">当我们在谈论 memory order 的时候，我们在谈论什么</a></li><li>杨晓峰，AtomicInteger底层实现原理是什么？如何在自己的产品代码中应用CAS操作？</li><li><a href="http://ifeve.com/memory-barriers-or-fences/" target="_blank" rel="noopener">内存屏障</a></li><li><a href="https://zh.cppreference.com/w/cpp/atomic/memory_order" target="_blank" rel="noopener">memory_order</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在JDK9中，包含了一个叫Variable Handles的新功能，下面是该功能的描述：&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://mingshan.me/categories/Java/"/>
    
    
      <category term="java" scheme="http://mingshan.me/tags/java/"/>
    
      <category term="VarHandle" scheme="http://mingshan.me/tags/VarHandle/"/>
    
  </entry>
  
  <entry>
    <title>Use MethodHandles To Invoke</title>
    <link href="http://mingshan.me/2018/10/02/Use%20MethodHandles%20To%20Invoke/"/>
    <id>http://mingshan.me/2018/10/02/Use MethodHandles To Invoke/</id>
    <published>2018-10-01T16:00:00.000Z</published>
    <updated>2018-11-01T13:11:20.409Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在Java中，我们想在程序运行时调用其方法，可以用JDK提供的反射相关API来实现，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Class clazz = Demo.class;</span><br><span class="line">Method method = clazz.getMethod(<span class="string">"studyHard"</span>, <span class="keyword">new</span> Class[]&#123;String.class&#125;);</span><br><span class="line">Demo demo = clazz.newInstance();</span><br><span class="line">method.invoke(demo, <span class="string">"哈哈"</span>);</span><br></pre></td></tr></table></figure><a id="more"></a><p>这样的代码看起来也挺简洁，不过在JDK7之后，提供了<code>java.lang.invoke.MethodHandle</code>，它的功能与反射相似，下面是一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test1</span><span class="params">(<span class="keyword">int</span> a, String b)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"test1 -&gt; "</span> + a + b);</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">test2</span><span class="params">(<span class="keyword">int</span> a, String b)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"test2 -&gt; "</span> + a + b);</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        Class&lt;?&gt; clazz = Demo.class;</span><br><span class="line">        MethodType signature = MethodType.methodType(String.class, <span class="keyword">int</span>.class, String.class);</span><br><span class="line">        MethodHandle mh = MethodHandles.lookup().findVirtual(clazz, <span class="string">"test1"</span>, signature);</span><br><span class="line"></span><br><span class="line">        Object obj = clazz.getConstructor().newInstance();</span><br><span class="line">        System.out.println(mh.bindTo(obj).invoke(<span class="number">1</span>, <span class="string">"2"</span>));</span><br><span class="line">        System.out.println((String)mh.bindTo(obj).invokeExact(<span class="number">1</span>, <span class="string">"2"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//--------------静态方法</span></span><br><span class="line">        MethodHandle mh2 = MethodHandles.lookup().findStatic(clazz, <span class="string">"test2"</span>, signature);</span><br><span class="line">        System.out.println(mh.bindTo(obj).invoke(<span class="number">1</span>, <span class="string">"2"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从例子可以看出，我们先要通过<code>MethodType</code>来生成方法的签名，比如方法的参数类型，方法的返回值类型等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MethodType signature = MethodType.methodType(String.class, <span class="keyword">int</span>.class, String.class);</span><br></pre></td></tr></table></figure><p>有了方法的签名，我们就可以利用方法签名、方法名称以及该方法所在的类来获取方法句柄（MethodHandle），代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MethodHandle mh = MethodHandles.lookup().findVirtual(clazz, <span class="string">"test1"</span>, signature);</span><br></pre></td></tr></table></figure><p>此时需要MethodHandles.lookup()静态方法来查找上下文对象，查找上下文对象有一些以“find”开头的方法，例如，findVirtual()、findSpecial()、findStatic()等。这些方法将会返回实际的方法句柄。</p><p>MethodHandle要先bindTo到某个对象实例上，然后调用invoke方法，传入参数就可以调用了。注意还有一个invokeExact方法，该方法与invoke方法的区别是方法参数、返回值匹配非常严格，调用时如果有数值参数隐式转换（如short转int/子类转父类）、装箱拆箱，会直接抛异常。比如函数返回值没有强制转换为String类型，就会抛异常：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread <span class="string">"main"</span> java.lang.invoke.WrongMethodTypeException: expected (<span class="keyword">int</span>,String)<span class="function">String but <span class="title">found</span> <span class="params">(<span class="keyword">int</span>,String)</span>Object</span></span><br><span class="line"><span class="function">at java.base/java.lang.invoke.Invokers.<span class="title">newWrongMethodTypeException</span><span class="params">(Unknown Source)</span></span></span><br><span class="line"><span class="function">at java.base/java.lang.invoke.Invokers.<span class="title">checkExactType</span><span class="params">(Unknown Source)</span></span></span><br><span class="line"><span class="function">at MethodHandles/me.mingshan.demo.Demo.<span class="title">main</span><span class="params">(Demo.java:<span class="number">26</span>)</span></span></span><br></pre></td></tr></table></figure><p>从目前接触到的API来看，似乎和以前用的反射区别并不大，其实不然，上面的特性包含在<a href="https://jcp.org/en/jsr/detail?id=292" target="_blank" rel="noopener">JSR 292</a>中，提供了比反射API更加强大的动态方法调用能力，并且新增了一个java虚拟机指令<code>invokedynamic</code>，<code>invokedynamic</code>指令通过引导方法（bootstrap method，BSM）机制来使用方法句柄。有关该指令更详细的信息可以参考Java虚拟机规范。</p><p>另外，在JDK9中新增了<code>Variable Handles</code>（变量句柄）相关功能，主要是用来取代<code>java.util.concurrent.atomic</code>包以及<code>sun.misc.Unsafe</code>类的功能，在Lookup类中，新增了<code>findVarHandle</code>方法来获取变量句柄，提供了各种细粒度的原子或有序性操作，更加安全和性能更高，毕竟<code>sun.misc.Unsafe</code>以后不推荐使用了，不安全。</p><p>参考：</p><ul><li><a href="https://jcp.org/en/jsr/detail?id=292" target="_blank" rel="noopener">JSR 292</a></li><li><a href="https://zhuanlan.zhihu.com/p/28124632" target="_blank" rel="noopener">Invokedynamic：Java的秘密武器</a></li><li><a href="https://www.infoq.com/articles/Invokedynamic-Javas-secret-weapon" target="_blank" rel="noopener">Invokedynamic - Java’s Secret Weapon</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在Java中，我们想在程序运行时调用其方法，可以用JDK提供的反射相关API来实现，代码如下：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Class clazz = Demo.class;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Method method = clazz.getMethod(&lt;span class=&quot;string&quot;&gt;&quot;studyHard&quot;&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Class[]&amp;#123;String.class&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Demo demo = clazz.newInstance();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;method.invoke(demo, &lt;span class=&quot;string&quot;&gt;&quot;哈哈&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Java" scheme="http://mingshan.me/categories/Java/"/>
    
    
      <category term="java" scheme="http://mingshan.me/tags/java/"/>
    
      <category term="MethodHandles" scheme="http://mingshan.me/tags/MethodHandles/"/>
    
  </entry>
  
  <entry>
    <title>CAS小窥</title>
    <link href="http://mingshan.me/2018/10/01/CAS%E5%B0%8F%E7%AA%A5/"/>
    <id>http://mingshan.me/2018/10/01/CAS小窥/</id>
    <published>2018-09-30T16:00:00.000Z</published>
    <updated>2018-10-19T14:49:45.329Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在JDK 1.5之后Java提供了并发包（<code>java.util.concurrent</code>）,加强对并发的支持。该包下的类大量使用 CAS（Compare and Swap）来实现原子操作、锁优化等。在<code>java.util.concurrent.atomic</code>包中，提供了对基本类型的原子封装，比如AtomicInteger，用来原子性访问和更新。我们十分熟悉的++i操作，在多线程环境下并非是线程安全的，因为它包含取值、相加与赋值三步操作，所以整体不是原子操作。</p><a id="more"></a><p>CAS是Java中所谓lock-free的基础。CAS有3个操作数，内存值V，旧的预期值A，要修改的新值B。当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做。CAS的描述如下（返回布尔值是为了让调用者知道是否更新成功）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">compareAndSwap</span><span class="params">(<span class="keyword">int</span> destValue, <span class="keyword">int</span> expectedValue, <span class="keyword">int</span> newValue)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (destValue == expectedValue) &#123;  </span><br><span class="line">        destValue = newValue;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么在JDK源码中是如何使用CAS的呢？我们先来看看AtomicInteger(JDK10)的源码实现。在JDK10版本中，CAS这部分操作是在<code>jdk.internal.misc.Unsafe</code>这个类中提供的，所以在AtomicInteger源码中，自增一是调用了Unsafe 的 getAndAddInt 方法。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> jdk.internal.misc.Unsafe U = jdk.internal.misc.Unsafe.getUnsafe();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> VALUE = U.objectFieldOffset(AtomicInteger.class, <span class="string">"value"</span>);</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> value;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">incrementAndGet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> U.getAndAddInt(<span class="keyword">this</span>, VALUE, <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>VALUE</code> 代表AtomicInteger对象value成员变量在内存中的偏移量，因为Unsafe是根据内存偏移地址获取数据的。<code>value</code>代表当前值，使用volatile修饰，保证多线程环境下值一致。</p><p>Unsafe这个类比较厉害，提供一些低级、不安全操作的方法， JDK不推荐我们直接调用这个类。下面getAndAddInt的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@HotSpotIntrinsicCandidate</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAddInt</span><span class="params">(Object o, <span class="keyword">long</span> offset, <span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        v = getIntVolatile(o, offset);</span><br><span class="line">    &#125; <span class="keyword">while</span> (!weakCompareAndSetInt(o, offset, v, v + delta));</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法的执行流程如下：</p><ol><li>假设现在有两个线程同时进入getAndAddInt方法, 主内存的value假设为2，根据Java内存模型，线程A和线程B各自持有一份value的副本，值为2；</li><li>线程A 执行<code>getIntVolatile(o, offset)</code>方法，拿到value值为2，线程A被挂起了；</li><li>线程B执行<code>getIntVolatile(o, offset)</code>方法，拿到value值为2， 接着执行<code>weakCompareAndSetInt(o, offset, v, v + delta)</code>方法，发现内存值和获取的值都是2，成功修改value的值为1；</li><li>线程A继续执行<code>weakCompareAndSetInt(o, offset, v, v + delta)</code>方法，发现自己获取的值2和内存中的值1不一样了，修改失败，继续循环执行</li><li>继续上面同样的操作，由于value被volatile修饰，所以此时线程A的value的副本就为1了，执行<code>getIntVolatile(o, offset)</code>方法，获取的值也为1，最后执行<code>weakCompareAndSetInt(o, offset, v, v + delta)</code>，直至成功修改value的值。</li></ol><p><code>weakCompareAndSetInt</code>最终调用<code>compareAndSetInt</code>方法，注意该方法为本地方法，如下。该方法有四个参数，分别是对象（这里是AtomicInteger）、对象的偏移地址、预期值、修改值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@HotSpotIntrinsicCandidate</span><br><span class="line">public final native boolean compareAndSetInt(Object o, long offset,</span><br><span class="line">                                             int expected,</span><br><span class="line">                                             int x);</span><br></pre></td></tr></table></figure><p>该方法根据操作系统的不同有不同的实现。在openjdk调用的c++代码为：<a href="https://github.com/unofficial-openjdk/openjdk/blob/4fb6d169db9c9732929ebbd5df01075b29105275/src/hotspot/share/prims/unsafe.cpp#L907" target="_blank" rel="noopener">unsafe.cpp</a>。。我也看不懂</p><p><strong>ABA问题</strong></p><p>从上面的分析可以看出，CAS涉及到修改值操作，如果一个值先被修改然后再修改为原值，那么就出现了ABA问题。具体流程如下：</p><ol><li>线程P1读取指定内存的值为A</li><li>线程P1被挂起，线程P2运行</li><li>线程P2将指定内存的值从A修改为B，再改回A。</li><li>再次调度到线程P1</li><li>线程P1发现指定内存的值没有变，于是继续执行。</li></ol><p><code>java.util.concurrent.atomic</code>包中，JDK提供了AtomicStampedReference，在该类中提供stamp来记录每次对值修改的操作，通过判断stamp来解决ABA问题的发生。示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用版本号解决CAS中的ABA问题。</span></span><br><span class="line"><span class="comment"> * 每一次修改都记录下版本号, 此版本号+1.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicStampedReferenceDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AtomicStampedReference&lt;Integer&gt; atomicStampedRef =</span><br><span class="line">            <span class="keyword">new</span> AtomicStampedReference&lt;Integer&gt;(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Thread main = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">"操作线程"</span> + Thread.currentThread() +<span class="string">", 初始值 a = "</span> </span><br><span class="line">                    + atomicStampedRef.getReference());</span><br><span class="line">            <span class="comment">// 获取当前Stamp</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> stamp = atomicStampedRef.getStamp();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 等待2秒 ，以便让干扰线程执行</span></span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 此时stamp已经被修改了, 所以CAS失败</span></span><br><span class="line">            <span class="keyword">boolean</span> isCASSuccess = atomicStampedRef.compareAndSet(<span class="number">1</span>, <span class="number">2</span>, stamp, stamp + <span class="number">1</span>);</span><br><span class="line">            System.out.println(<span class="string">"操作线程"</span> + Thread.currentThread() +<span class="string">", CAS操作结果: "</span> + isCASSuccess);</span><br><span class="line">        &#125;, <span class="string">"主操作线程"</span>);</span><br><span class="line"></span><br><span class="line">        Thread other = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// 干扰线程让出自己的cpu时间片，回到Runnable状态，让自己或主操作线程先执行</span></span><br><span class="line">            Thread.yield();</span><br><span class="line">            <span class="comment">// 加一</span></span><br><span class="line">            atomicStampedRef.compareAndSet(<span class="number">1</span>, <span class="number">2</span>, </span><br><span class="line">                    atomicStampedRef.getStamp(),atomicStampedRef.getStamp() + <span class="number">1</span>);</span><br><span class="line">            System.out.println(<span class="string">"操作线程"</span> + Thread.currentThread() + <span class="string">", 【increment】, Reference = "</span> </span><br><span class="line">                    + atomicStampedRef.getReference() + <span class="string">", Stamp = "</span> + atomicStampedRef.getStamp());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 然后减一</span></span><br><span class="line">            atomicStampedRef.compareAndSet(<span class="number">2</span>, <span class="number">1</span>, atomicStampedRef.getStamp(), </span><br><span class="line">                    atomicStampedRef.getStamp() + <span class="number">1</span>);</span><br><span class="line">            System.out.println(<span class="string">"操作线程"</span> + Thread.currentThread() + <span class="string">", 【decrement】, Reference = "</span> </span><br><span class="line">                    + atomicStampedRef.getReference() + <span class="string">", Stamp = "</span> + atomicStampedRef.getStamp());</span><br><span class="line">        &#125;, <span class="string">"干扰线程"</span>);</span><br><span class="line"></span><br><span class="line">        main.start();</span><br><span class="line">        other.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">操作线程Thread[主操作线程,5,main], 初始值 a = 1</span><br><span class="line">操作线程Thread[干扰线程,5,main], 【increment】, Reference = 2, Stamp = 1</span><br><span class="line">操作线程Thread[干扰线程,5,main], 【decrement】, Reference = 1, Stamp = 2</span><br><span class="line">操作线程Thread[主操作线程,5,main], CAS操作结果: false</span><br></pre></td></tr></table></figure><p><strong>Variable Handles</strong> </p><p>在JDK9之前，JDK源码中在进行CAS操作时需要调用<code>sun.misc.Unsafe</code>类native修饰的方法，该类由于涉及到底层操作被JDK视为不安全，不推荐使用，在以后的版本中会被逐渐替代，所以在JDK9引入了Variable Handles（变量句柄）这个概念，主要提供<code>java.util.concurrent.atomic</code> 和 <code>sun.misc.Unsafe</code>相似的功能，但会更加安全和易用，并且在并发方面提高了性能。详细参考<a href="https://github.com/ZZULI-TECH/interview/blob/master/source/java/base/VariableHandles.md" target="_blank" rel="noopener">Variable Handles（变量句柄）</a></p><p>参考：</p><ul><li><a href="https://en.wikipedia.org/wiki/Non-blocking_algorithm" target="_blank" rel="noopener">Non-blocking algorithm</a></li><li><a href="http://gee.cs.oswego.edu/dl/papers/aqs.pdf" target="_blank" rel="noopener">The java.util.concurrent Synchronizer Framework</a></li><li><a href="http://www.berlinix.com/dev/lock-free.php" target="_blank" rel="noopener">无锁程序设计</a></li><li><a href="https://www.cnblogs.com/kisty/p/5408264.html" target="_blank" rel="noopener">JAVA CAS原理深度分析</a></li><li><a href="https://www.jianshu.com/p/8b227a8adbc1" target="_blank" rel="noopener">JAVA中CAS-ABA的问题解决方案AtomicStampedReference</a></li><li>杨晓峰，AtomicInteger底层实现原理是什么？如何在自己的产品代码中应用CAS操作？</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在JDK 1.5之后Java提供了并发包（&lt;code&gt;java.util.concurrent&lt;/code&gt;）,加强对并发的支持。该包下的类大量使用 CAS（Compare and Swap）来实现原子操作、锁优化等。在&lt;code&gt;java.util.concurrent.atomic&lt;/code&gt;包中，提供了对基本类型的原子封装，比如AtomicInteger，用来原子性访问和更新。我们十分熟悉的++i操作，在多线程环境下并非是线程安全的，因为它包含取值、相加与赋值三步操作，所以整体不是原子操作。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://mingshan.me/categories/Java/"/>
    
      <category term="JUC" scheme="http://mingshan.me/categories/Java/JUC/"/>
    
    
      <category term="java" scheme="http://mingshan.me/tags/java/"/>
    
      <category term="JUC" scheme="http://mingshan.me/tags/JUC/"/>
    
      <category term="CAS" scheme="http://mingshan.me/tags/CAS/"/>
    
  </entry>
  
  <entry>
    <title>Arthas的使用并对JVM监控</title>
    <link href="http://mingshan.me/2018/09/21/Arthas%E7%9A%84%E4%BD%BF%E7%94%A8%E5%B9%B6%E5%AF%B9JVM%E7%9B%91%E6%8E%A7/"/>
    <id>http://mingshan.me/2018/09/21/Arthas的使用并对JVM监控/</id>
    <published>2018-09-20T16:00:00.000Z</published>
    <updated>2018-10-21T15:44:34.445Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Arthas 是Alibaba开源的Java诊断工具，可以查看Java进程的一些信息，例如运行情况、JVM相关参数、线程等信息，采用命令行交互模式，在Linux用着十分方便。</p><a id="more"></a><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>在Linux系统中，首先创建一个文件下，然后在该文件下执行如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -L https://alibaba.github.io/arthas/install.sh | sh</span><br></pre></td></tr></table></figure><p>该命令会下载<code>as.sh</code>脚本，执行该脚本的用户需要和目标进程具有相同的权限。比如以admin用户来执行： sudo su admin &amp;&amp; ./as.sh 或 sudo -u admin -EH ./as.sh。 详细的启动脚本说明，请参考<a href="https://alibaba.github.io/arthas/start-arthas.html" target="_blank" rel="noopener">这里</a>。 如果attatch不上目标进程，可以查看~/logs/arthas/ 目录下的日志。</p><h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><p>接下来就需要执行<code>/as.sh</code>脚本，注意后面传入java 进程id</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:/usr/soft/arthas# ./as.sh 2616</span><br></pre></td></tr></table></figure><p>启动画面如下图所示：</p><p><img src="https://github.com/ZZULI-TECH/interview/blob/master/images/arthas-start.png?raw=true" alt="image"></p><p><strong>查看dashboard</strong></p><p>输入<code>dashboard</code>可以查看当前进程的信息、JVM内存使用情况，还可以看到当前操作系统和Java的版本信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">$ dashboard</span><br><span class="line">ID     NAME                  GROUP          PRIORI STATE   %CPU   TIME   INTERRU DAEMON </span><br><span class="line">16     nioEventLoopGroup-3-1 system         10     RUNNABL 76     0:0    false   false  </span><br><span class="line">21     Timer-for-arthas-dash system         10     RUNNABL 23     0:0    false   true   </span><br><span class="line">12     AsyncAppender-Worker- system         9      WAITING 0      0:0    false   true   </span><br><span class="line">10     Attach Listener       system         9      RUNNABL 0      0:0    false   true   </span><br><span class="line">9      Common-Cleaner        InnocuousThrea 8      TIMED_W 0      0:0    false   true   </span><br><span class="line">3      Finalizer             system         8      WAITING 0      0:0    false   true   </span><br><span class="line">2      Reference Handler     system         10     RUNNABL 0      0:0    false   true   </span><br><span class="line">4      Signal Dispatcher     system         9      RUNNABL 0      0:0    false   true   </span><br><span class="line">20     as-command-execute-da system         10     TIMED_W 0      0:0    false   true   </span><br><span class="line">14     job-timeout           system         9      TIMED_W 0      0:0    false   true   </span><br><span class="line">Memory             used  total max    usage GC                                          </span><br><span class="line">heap               18M   39M   233M   7.90% gc.copy.count         24                    </span><br><span class="line">tenured_gen        16M   27M   161M         gc.copy.time(ms)      107                   </span><br><span class="line">eden_space         2M    11M   64M    4.22% gc.marksweepcompact.c 2                     </span><br><span class="line">survivor_space     0K    1408K 8256K  0.00% ount                                        </span><br><span class="line">nonheap            23M   27M   -1                                                       </span><br><span class="line">Runtime                                                                                 </span><br><span class="line">os.name               Linux                                                             </span><br><span class="line">os.version            4.15.0-29-generic                                                 </span><br><span class="line">java.version          10.0.2                                                            </span><br><span class="line">java.home             /usr/package/jdk-10.0                                             </span><br><span class="line">                      .2</span><br></pre></td></tr></table></figure><p><strong>查看JVM信息</strong></p><p>输入<code>JVM</code>参数可以查看JVM相关信息，这对JVM调试有很大帮助。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">$ jvm</span><br><span class="line"> RUNTIME                                                                                </span><br><span class="line">----------------------------------------------------------------------------------------</span><br><span class="line"> MACHINE-NAME             2616@ubuntu                                                   </span><br><span class="line"> JVM-START-TIME           2018-09-20 20:19:32                                           </span><br><span class="line"> MANAGEMENT-SPEC-VERSION  2.0                                                           </span><br><span class="line"> SPEC-NAME                Java Virtual Machine Specification                            </span><br><span class="line"> SPEC-VENDOR              Oracle Corporation                                            </span><br><span class="line"> SPEC-VERSION             10                                                            </span><br><span class="line"> VM-NAME                  Java HotSpot(TM) 64-Bit Server VM                             </span><br><span class="line"> VM-VENDOR                &quot;Oracle Corporation&quot;                                          </span><br><span class="line"> VM-VERSION               10.0.2+13                                                     </span><br><span class="line"> INPUT-ARGUMENTS          []                                                            </span><br><span class="line"> CLASS-PATH               .:/usr/package/jdk-10.0.2/lib/                                </span><br><span class="line"> BOOT-CLASS-PATH                                                                        </span><br><span class="line"> LIBRARY-PATH             /usr/java/packages/lib:/usr/lib64:/lib64:/lib:/usr/lib        </span><br><span class="line">                                                                                        </span><br><span class="line">----------------------------------------------------------------------------------------</span><br><span class="line"> CLASS-LOADING                                                                          </span><br><span class="line">----------------------------------------------------------------------------------------</span><br><span class="line"> LOADED-CLASS-COUNT       2818                                                          </span><br><span class="line"> TOTAL-LOADED-CLASS-COUN  2818                                                          </span><br><span class="line"> T                                                                                      </span><br><span class="line"> UNLOADED-CLASS-COUNT     0                                                             </span><br><span class="line"> IS-VERBOSE               false                                                         </span><br><span class="line">                                                                                        </span><br><span class="line">----------------------------------------------------------------------------------------</span><br><span class="line"> COMPILATION                                                                            </span><br><span class="line">----------------------------------------------------------------------------------------</span><br><span class="line"> NAME                     HotSpot 64-Bit Tiered Compilers                               </span><br><span class="line"> TOTAL-COMPILE-TIME       3875(ms)                                                      </span><br><span class="line">                                                                                        </span><br><span class="line">----------------------------------------------------------------------------------------</span><br><span class="line"> GARBAGE-COLLECTORS                                                                     </span><br><span class="line">----------------------------------------------------------------------------------------</span><br><span class="line"> Copy                     25/110(ms)                                                    </span><br><span class="line"> [count/time]                                                                           </span><br><span class="line"> MarkSweepCompact         2/108(ms)                                                     </span><br><span class="line"> [count/time]                                                                           </span><br><span class="line">                                                                                        </span><br><span class="line">----------------------------------------------------------------------------------------</span><br><span class="line"> MEMORY-MANAGERS                                                                        </span><br><span class="line">----------------------------------------------------------------------------------------</span><br><span class="line"> CodeCacheManager         CodeHeap &apos;non-nmethods&apos;                                       </span><br><span class="line">                          CodeHeap &apos;profiled nmethods&apos;                                  </span><br><span class="line">                          CodeHeap &apos;non-profiled nmethods&apos;                              </span><br><span class="line">                                                                                        </span><br><span class="line"> Metaspace Manager        Metaspace                                                     </span><br><span class="line">                          Compressed Class Space                                        </span><br><span class="line">                                                                                        </span><br><span class="line"> Copy                     Eden Space                                                    </span><br><span class="line">                          Survivor Space                                                </span><br><span class="line">                                                                                        </span><br><span class="line"> MarkSweepCompact         Eden Space                                                    </span><br><span class="line">                          Survivor Space                                                </span><br><span class="line">                          Tenured Gen                                                   </span><br><span class="line">                                                                                        </span><br><span class="line">                                                                                        </span><br><span class="line">----------------------------------------------------------------------------------------</span><br><span class="line"> MEMORY                                                                                 </span><br><span class="line">----------------------------------------------------------------------------------------</span><br><span class="line"> HEAP-MEMORY-USAGE        41689088/16777216/245301248/18364616                          </span><br><span class="line"> [committed/init/max/use                                                                </span><br><span class="line"> d]                                                                                     </span><br><span class="line"> NO-HEAP-MEMORY-USAGE     32047104/7667712/-1/27755016                                  </span><br><span class="line"> [committed/init/max/use                                                                </span><br><span class="line"> d]                                                                                     </span><br><span class="line"> PENDING-FINALIZE-COUNT   0                                                             </span><br><span class="line">                                                                                        </span><br><span class="line">----------------------------------------------------------------------------------------</span><br><span class="line"> OPERATING-SYSTEM                                                                       </span><br><span class="line">----------------------------------------------------------------------------------------</span><br><span class="line"> OS                       Linux                                                         </span><br><span class="line"> ARCH                     amd64                                                         </span><br><span class="line"> PROCESSORS-COUNT         1                                                             </span><br><span class="line"> LOAD-AVERAGE             0.53                                                          </span><br><span class="line"> VERSION                  4.15.0-29-generic                                             </span><br><span class="line">                                                                                        </span><br><span class="line">----------------------------------------------------------------------------------------</span><br><span class="line"> THREAD                                                                                 </span><br><span class="line">----------------------------------------------------------------------------------------</span><br><span class="line"> COUNT                    14                                                            </span><br><span class="line"> DAEMON-COUNT             8                                                             </span><br><span class="line"> LIVE-COUNT               15                                                            </span><br><span class="line"> STARTED-COUNT            17                                                            </span><br><span class="line">Affect(row-cnt:0) cost in 42 ms.</span><br></pre></td></tr></table></figure><p><strong>class/classloader相关</strong></p><ul><li>sc——查看JVM已加载的类信息</li><li>sm——查看已加载类的方法信息</li><li>dump——dump 已加载类的 byte code 到特定目录</li><li>redefine——加载外部的.class文件，redefine到JVM里</li><li>jad——反编译指定已加载类的源码</li><li>classloader——查看classloader的继承树，urls，类加载信息，使用classloader去getResource</li></ul><p>详细参考：</p><ul><li><a href="https://alibaba.github.io/arthas/index.html" target="_blank" rel="noopener">Arthas Doc</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Arthas 是Alibaba开源的Java诊断工具，可以查看Java进程的一些信息，例如运行情况、JVM相关参数、线程等信息，采用命令行交互模式，在Linux用着十分方便。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://mingshan.me/categories/Java/"/>
    
    
      <category term="java" scheme="http://mingshan.me/tags/java/"/>
    
      <category term="Arthas" scheme="http://mingshan.me/tags/Arthas/"/>
    
  </entry>
  
</feed>
