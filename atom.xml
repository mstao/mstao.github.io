<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>明山的博客</title>
  <subtitle>一念开明，反身而诚</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-06-23T13:05:44.037Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Mingshan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>基于java中的泛型与反射构建通用DAO层</title>
    <link href="http://yoursite.com/2017/06/23/%E5%9F%BA%E4%BA%8Ejava%E4%B8%AD%E7%9A%84%E6%B3%9B%E5%9E%8B%E4%B8%8E%E5%8F%8D%E5%B0%84%E6%9E%84%E5%BB%BA%E9%80%9A%E7%94%A8DAO%E5%B1%82/"/>
    <id>http://yoursite.com/2017/06/23/基于java中的泛型与反射构建通用DAO层/</id>
    <published>2017-06-23T12:53:52.425Z</published>
    <updated>2017-06-23T13:05:44.037Z</updated>
    
    <content type="html"><![CDATA[<p>在利用hibernate写通用DAO层时需要获取泛型的类型，比如我在写hql的update语句时需要获取泛型的实体类，由于泛型有擦除机制，所以与需要在运行过程中获取泛型的类型产生了矛盾。此时需要利用反射机制来实现此功能，下面来看一个小例子。</p>
<blockquote>
<p>首先建一个实体类Dog</p>
</blockquote>
<pre><code>import java.io.Serializable;

public class Dog implements Serializable{

private static final long serialVersionUID = 8108340856807454651L;


private int age;
private String name;
public int getAge() {
    return age;
}
public void setAge(int age) {
    this.age = age;
}
public String getName() {
    return name;
}
public void setName(String name) {
    this.name = name;
}

}
</code></pre><a id="more"></a>
<blockquote>
<p> 然后写一个基类，在此类中可以获取泛型的类型</p>
</blockquote>
<pre><code>package com.han.one;

import java.lang.reflect.Field;
import java.lang.reflect.ParameterizedType;
import java.util.HashMap;
import java.util.Map;

/**
 * 通过反射获取泛型实例
 */
 public  class Genericity&lt;T&gt; {

@SuppressWarnings(&quot;rawtypes&quot;)
protected Class clazz;

@SuppressWarnings(&quot;unchecked&quot;)
/**
 * 把泛型的参数提取出来的过程放入到构造函数中写，因为
 * 当子类创建对象的时候，直接调用父类的构造函数
 */
public Genericity() {
    // 通过反射机制获取子类传递过来的实体类的类型信息
    ParameterizedType type = (ParameterizedType) this.getClass().getGenericSuperclass();
    //得到t的实际类型
    clazz = (Class&lt;T&gt;) type.getActualTypeArguments()[0];
}

/**
 * 获取指定实例的所有属性名及对应值的Map实例
 * @param entity 实例
 * @return 字段名及对应值的Map实例
 */
protected Map&lt;String, Object&gt; getFieldValueMap(T entity) {
    // key是属性名，value是对应值
    Map&lt;String, Object&gt; fieldValueMap = new HashMap&lt;String, Object&gt;();

    // 获取当前加载的实体类中所有属性
    Field[] fields = this.clazz.getDeclaredFields();

    for (int i = 0; i &lt; fields.length; i++) {
        Field f = fields[i];
        // 属性名
        String key = f.getName();
        //属性值
        Object value = null;
        // 忽略序列化版本ID号
        if (! &quot;serialVersionUID&quot;.equals(key)) {
            // 取消Java语言访问检查
            f.setAccessible(true);
            try {
                value =f.get(entity);
            } catch (IllegalArgumentException e) {
                e.printStackTrace();
            } catch (IllegalAccessException e) {
                e.printStackTrace();
            }
            fieldValueMap.put(key, value);
        }
    }
    return fieldValueMap;
}
}
</code></pre><p>在此类的构造方法中利用反射获取子类传递过来的实体类的类型信息，getFieldValueMap方法用于获取该实体类的属性信息</p>
<blockquote>
<p>最后写一个测试类</p>
</blockquote>
<pre><code>package com.han.one;

import java.util.Map;
import java.util.Set;

/**
 * 测试：通过反射获取运行过程中泛型实例
 *
 */

public class GenericityTest extends Genericity&lt;Dog&gt; {

public static void main(String[] args) {

    GenericityTest gt = new GenericityTest();

    //赋值
    Dog  dd=new Dog();
    dd.setAge(1);
    dd.setName(&quot;旺财&quot;);

    Map&lt;String,Object&gt; map = gt.getFieldValueMap(dd);
    //遍历
    Set&lt;Map.Entry&lt;String, Object&gt;&gt; entrySet = map.entrySet();
    for (Map.Entry&lt;String, Object&gt; entry : entrySet){
        String key = entry.getKey();
        Object value = entry.getValue();
        System.out.println(key + &quot;---&quot; + value);
    }
}
}
</code></pre><p>在这个测试类中，此类继承基类，并向其传递实体类，这样在父类中就可以通过反射获取泛型的类型了。</p>
<p>以此为基础，就可以构建通用的DAO了，代码如下：</p>
<pre><code>public class BaseDaoImpl&lt;T&gt;  implements IBaseDao&lt;T&gt; {


@Autowired
private SessionFactory  sessionFactory;


@SuppressWarnings(&quot;rawtypes&quot;)
private final Class clazz;


@SuppressWarnings(&quot;unchecked&quot;)
public BaseDaoImpl(){
    // 通过反射机制获取子类传递过来的实体类的类型信息
    ParameterizedType type = (ParameterizedType) this.getClass().getGenericSuperclass();
    clazz = (Class&lt;T&gt;) type.getActualTypeArguments()[0];
}


@Override
public boolean update(T t) {
    // TODO Auto-generated method stub

    StringBuffer stringBuffer=new StringBuffer();
    stringBuffer.append(&quot;update &quot;+this.clazz.getSimpleName());
    stringBuffer.append(&quot; u set u.itemTitle=:itemTitle ,u.itemContent=:itemContent,u.addTime=:addTime,u.isImage=:isImage,u.isPublish=:isPublish,u.author=:author  where u.id=:id&quot;);
    System.out.println(stringBuffer.toString());
    Query query  = sessionFactory.getCurrentSession().createQuery(stringBuffer.toString());
    query.setProperties(t);
    return (query.executeUpdate()&gt;0);
}
}
</code></pre><p>这里只是在update方法中利用反射获取实体类，通过拼装hql语句来达到重用目的，当然参数也可以动态获取，这里只是个小例子。</p>
<blockquote>
<p>总结</p>
</blockquote>
<p>java中泛型与反射的应用很广泛，想要完全掌握不是那么容易，多写多练是比较好的方式^_^</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在利用hibernate写通用DAO层时需要获取泛型的类型，比如我在写hql的update语句时需要获取泛型的实体类，由于泛型有擦除机制，所以与需要在运行过程中获取泛型的类型产生了矛盾。此时需要利用反射机制来实现此功能，下面来看一个小例子。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;首先建一个实体类Dog&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;import java.io.Serializable;

public class Dog implements Serializable{

private static final long serialVersionUID = 8108340856807454651L;


private int age;
private String name;
public int getAge() {
    return age;
}
public void setAge(int age) {
    this.age = age;
}
public String getName() {
    return name;
}
public void setName(String name) {
    this.name = name;
}

}
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>利用hibernate进行多表查询问题</title>
    <link href="http://yoursite.com/2017/06/23/%E5%88%A9%E7%94%A8hibernate%E8%BF%9B%E8%A1%8C%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2017/06/23/利用hibernate进行多表查询问题/</id>
    <published>2017-06-23T12:52:13.388Z</published>
    <updated>2017-06-23T13:10:24.687Z</updated>
    
    <content type="html"><![CDATA[<p>在Hibernate框架中，一个实体类映射为一个数据库表，在进行多表查询时,如何将不同表中的数据整合起来，并且映射为一个实体类是利用Hibernate进行多表查询的关键，根据我的理解，先将代码整理一下：</p>
<blockquote>
<p>实体类</p>
</blockquote>
<pre><code>@Entity
@Table(name = &quot;ps_trends&quot;)
public class Trends implements Serializable{


private static final long serialVersionUID = -2228382525594394975L;

@Id
@GeneratedValue(strategy = GenerationType.IDENTITY)
private int id;

@Column(name = &quot;item_title&quot;)
private String itemTitle;

@Column(name = &quot;item_content&quot;)
private String itemContent;

@Column(name = &quot;type_id&quot;)
private int  typeId;

@Column(name = &quot;add_time&quot;)
private String addTime;

@Column(name = &quot;view_count&quot;)
private int viewCount;

@Column(name = &quot;is_image&quot;)
private int isImage;

@Column(name = &quot;is_publish&quot;)
private int isPublish;

//临时属性
@Transient
private String itemTypeFlag;

@Transient
private String itemTypeName;

public Trends(){}

public Trends(int id, String itemTitle, String itemContent, String addTime, int viewCount,
          String itemTypeName,String itemTypeFlag) {
    super();
    this.id = id;
    this.itemTitle = itemTitle;
    this.itemContent = itemContent;
    this.addTime = addTime;
    this.viewCount = viewCount;
    this.itemTypeName = itemTypeName;
    this.itemTypeFlag = itemTypeFlag;

}
setter ，getter方法
}
</code></pre> <a id="more"></a>
<p>这里有两个属性注解为Transient，因为它们不是主表的映射字段。同时写一个有参构造方法，构造方法的参数列表即为要查询的映射字段。</p>
<blockquote>
<p>DaoImpl方法</p>
</blockquote>
<pre><code>@Override
public Trends findTrendsInfoById(int id) {
    // TODO Auto-generated method stub
    String hql=&quot;select new com.primaryschool.home.entity.Trends(t.id,t.itemTitle,t.itemContent,t.addTime,t.viewCount,tt.itemTypeName,tt.itemTypeFlag)from Trends t,TrendsType tt  where tt.id=t.typeId and t.id=? and t.isPublish=1&quot;;
    Query query=sessionFactory.getCurrentSession().createQuery(hql);
    query.setInteger(0, id);
    return (Trends) query.uniqueResult();
}
</code></pre><p>在findTrendsInfoById(int id)方法中，hql语句有些特别，它是将两个表的需要字段传入到Trends实体类的构造方法中，这样就可以直接利用getter方法进行取值了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在Hibernate框架中，一个实体类映射为一个数据库表，在进行多表查询时,如何将不同表中的数据整合起来，并且映射为一个实体类是利用Hibernate进行多表查询的关键，根据我的理解，先将代码整理一下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;实体类&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;@Entity
@Table(name = &amp;quot;ps_trends&amp;quot;)
public class Trends implements Serializable{


private static final long serialVersionUID = -2228382525594394975L;

@Id
@GeneratedValue(strategy = GenerationType.IDENTITY)
private int id;

@Column(name = &amp;quot;item_title&amp;quot;)
private String itemTitle;

@Column(name = &amp;quot;item_content&amp;quot;)
private String itemContent;

@Column(name = &amp;quot;type_id&amp;quot;)
private int  typeId;

@Column(name = &amp;quot;add_time&amp;quot;)
private String addTime;

@Column(name = &amp;quot;view_count&amp;quot;)
private int viewCount;

@Column(name = &amp;quot;is_image&amp;quot;)
private int isImage;

@Column(name = &amp;quot;is_publish&amp;quot;)
private int isPublish;

//临时属性
@Transient
private String itemTypeFlag;

@Transient
private String itemTypeName;

public Trends(){}

public Trends(int id, String itemTitle, String itemContent, String addTime, int viewCount,
          String itemTypeName,String itemTypeFlag) {
    super();
    this.id = id;
    this.itemTitle = itemTitle;
    this.itemContent = itemContent;
    this.addTime = addTime;
    this.viewCount = viewCount;
    this.itemTypeName = itemTypeName;
    this.itemTypeFlag = itemTypeFlag;

}
setter ，getter方法
}
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="Hibernate" scheme="http://yoursite.com/tags/Hibernate/"/>
    
  </entry>
  
  <entry>
    <title>利用uploadify插件上传文件时java后台获取不到当前session问题</title>
    <link href="http://yoursite.com/2017/06/23/%E5%88%A9%E7%94%A8uploadify%E6%8F%92%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%E6%97%B6java%E5%90%8E%E5%8F%B0%E8%8E%B7%E5%8F%96%E4%B8%8D%E5%88%B0%E5%BD%93%E5%89%8Dsession%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2017/06/23/利用uploadify插件上传文件时java后台获取不到当前session问题/</id>
    <published>2017-06-23T12:51:23.675Z</published>
    <updated>2017-06-23T13:04:31.971Z</updated>
    
    <content type="html"><![CDATA[<p>我在利用uploadify插件上传文件时发现java后台获取不到当前用户的session值，即当前的用户的session保存的信息失效，导致拦截器将上传请求拦截，这里的拦截器主要对登录的信息进行拦截验证，正因为此原因，导致上传文件失败，后来在利用firebug查找请求的时候，发现uploadify插件会自动生成一个新的session，导致原来的session失效，解决方法是将jsessionid通过url传到后台，这样后台就能识别当前session，问题也就解决了。代码如下：</p>
<pre><code>$(&quot;#uploadify&quot;).uploadify({
        debug            : false,
        swf             :  CTPPATH+&apos;/admin/static/uploadify/js/uploadify.swf&apos;,    //swf文件路径
        method            : &apos;get&apos;,    // 提交方式
        uploader        :  CTPPATH+&apos;/processUpload.ado;jsessionid=${pageContext.session.id}&apos;, // 服务器端处理该上传请求的程序(servlet, struts2-Action)   )};
</code></pre><p>  代码中有许多属性这里没有贴出来，这里主要看uploader属性，uploader属性为CTPPATH+’/processUpload.ado;jsessionid=${pageContext.session.id}’，即在请求url中附上<br>;jsessionid=${pageContext.session.id}，这样上传就没问题了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我在利用uploadify插件上传文件时发现java后台获取不到当前用户的session值，即当前的用户的session保存的信息失效，导致拦截器将上传请求拦截，这里的拦截器主要对登录的信息进行拦截验证，正因为此原因，导致上传文件失败，后来在利用firebug查找请求的时候
    
    </summary>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>javaweb下载文件时IE浏览器下报错问题</title>
    <link href="http://yoursite.com/2017/06/23/javaweb%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B6%E6%97%B6IE%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%8B%E6%8A%A5%E9%94%99%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2017/06/23/javaweb下载文件时IE浏览器下报错问题/</id>
    <published>2017-06-23T12:50:10.805Z</published>
    <updated>2017-06-23T13:04:03.725Z</updated>
    
    <content type="html"><![CDATA[<p>最近做的网站的一个下载功能出现了问题，在firefox浏览器以及360浏览器下下载均正常，也能将中文正常转换，但在IE浏览器下却出现了问题，当点击下载链接的时候，后台直接报错：<br><img src="http://www.mingzhiwen.cn/usr/uploads/2017/03/1999726111.png" alt="2017-03-17_113722.png"><br>后台我怎么兼容也不能解决问题，我下载的部分java代码：</p>
<p><img src="http://www.mingzhiwen.cn/usr/uploads/2017/03/95431087.png" alt="QQ图片20170317113901.png"></p>
<p>进过我仔细查找，发现我前台通过get方式提交的文件名包含一下字符，导致浏览器解析url不一致，所以需要将url通过javascript进行转码，即用encodeURIComponent函数进行编码，代码如下</p>
<pre><code>&lt;a href=&quot;javascript:location.href=&apos;${pageContext.request.contextPath}/download.do?realname=&apos;+encodeURIComponent(&apos;${file_list.real_name}&apos;)+&apos;&amp;filename=&apos;+encodeURIComponent(&apos;${file_list.file_name}&apos;);&quot; class=&quot;file-name&quot;&gt;${file_list.file_name}&lt;/a&gt;
</code></pre><p>通过将文件名编码之后就能解决问题了</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近做的网站的一个下载功能出现了问题，在firefox浏览器以及360浏览器下下载均正常，也能将中文正常转换，但在IE浏览器下却出现了问题，当点击下载链接的时候，后台直接报错：&lt;br&gt;&lt;img src=&quot;http://www.mingzhiwen.cn/usr/upload
    
    </summary>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>网站消息推送之long polling（长轮询）初探</title>
    <link href="http://yoursite.com/2017/06/23/%E7%BD%91%E7%AB%99%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81%E4%B9%8Blong%20polling%EF%BC%88%E9%95%BF%E8%BD%AE%E8%AF%A2%EF%BC%89%E5%88%9D%E6%8E%A2/"/>
    <id>http://yoursite.com/2017/06/23/网站消息推送之long polling（长轮询）初探/</id>
    <published>2017-06-23T12:47:58.301Z</published>
    <updated>2017-06-23T13:03:12.516Z</updated>
    
    <content type="html"><![CDATA[<p>网站的消息推送功能应用很广泛，比如论坛，问答网站等等都需要推送消息，那么采用什么样的推送方式更加便捷，更加节省服务器资源呢，这个需要根据网站的流量和规模来决定，因为long polling是我最先接触到的，我就来谈谈它吧。</p>
<p>长轮询初看像是轮流查询的意思，其实不是，它是客户端通过ajax发出请求，然后客户端挂起，等待服务器端响应，服务器端会检测有无新消息，如果有消息，服务器端会将新消息推送给客户端，结束本次请求，如果在有效请求期内没有新消息出现，那么会一直检测有无新消息出现。连接会保持一段时间周期直到数据或状态改变或者时间过期，通过这种机制来减少无效的客户端和服务器间的交互。</p>
<p>虽然长轮循比传统的轮询性能会有些提高，但在服务器端数据变化非常频繁的情况下，两者的性能并不能差多少，因为都是客户端先请求，服务器再响应，只是两者服务器端响应的机制不同。<br>下面来说说代码，服务器端我用的是php，客户端用的是jQuery</p>
<p>服务器端代码：</p>
<pre><code>/**
 * @desc ajax长轮询 来获取通知消息信息
 * @return 通知信息数量&gt;o
 */
public function longPolling(){


    if(!$_GET[&apos;timed&apos;]) exit();
    date_default_timezone_set(&quot;PRC&quot;);
    session_write_close(); //防止session访问互斥问题
    set_time_limit(0);//无限请求超时时间
    $timed = $_GET[&apos;timed&apos;];
    while (true) {
        sleep(3); // 休眠3秒
        //判断有无新通知出现
         $no_count=D(&apos;Notifications&apos;)-&gt;getNotificationsCount($this-&gt;uid);
         if ($no_count&gt;0) {
            $responseTime = time();
            // 返回数据信息，请求时间、返回数据时间、耗时
            $content=array(
                &apos;result&apos;         =&gt;$no_count,
                &apos;reponse_time&apos;   =&gt;$responseTime,
                &apos;request_time&apos;   =&gt;$timed,
                &apos;use_time&apos;       =&gt;($responseTime - $timed)
            );
            echo $this-&gt;ajaxReturn($content);
            exit();
        } else { // 模拟没有数据变化，将休眠 hold住连接
            sleep(13);
            exit();
        }
    }


}
</code></pre><a id="more"></a>
<p>从服务器段代码可以看出，里面有个while(true){}死循环，只有有新信息或者连接失效时会退出循环。</p>
<p>客户端代码：</p>
<pre><code>$(function(){

    /**
     * 消息的处理 递归调用
     */
     (function longPolling() {  
         $.ajax({  
             url: MODULE+&quot;/Notifications/longPoll&quot;,  
             data: {&quot;timed&quot;: Date.parse(new Date())/1000},  
             dataType: &quot;json&quot;,  
             timeout: 70000,//单位毫秒
             error: function (XMLHttpRequest, textStatus, errorThrown) {  

                 if (textStatus == &quot;timeout&quot;) { // 请求超时  
                     longPolling(); // 递归调用  
                 } else { // 其他错误，如网络错误等  
                     longPolling();  
                 }  
             },  
             success: function (data, textStatus) {  
                 //此时已有消息过来了，将消息数量显示
                 $(&apos;.nav-counter&apos;).text(data.result);
                 if (textStatus == &quot;success&quot;) {
                       // 请求成功，继续请求
                    longPolling();
                 }  
             }  
         });  

     })();



});
</code></pre><p>客户端代码调用ajax进行处理，逻辑已经很清楚了。</p>
<p>以上就是我对long polling的理解，虽然长轮询较轮询有了不错的改进，但还是会消耗很多的服务器资源，并不是十分理想的网站消息推送方案。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;网站的消息推送功能应用很广泛，比如论坛，问答网站等等都需要推送消息，那么采用什么样的推送方式更加便捷，更加节省服务器资源呢，这个需要根据网站的流量和规模来决定，因为long polling是我最先接触到的，我就来谈谈它吧。&lt;/p&gt;
&lt;p&gt;长轮询初看像是轮流查询的意思，其实不是，它是客户端通过ajax发出请求，然后客户端挂起，等待服务器端响应，服务器端会检测有无新消息，如果有消息，服务器端会将新消息推送给客户端，结束本次请求，如果在有效请求期内没有新消息出现，那么会一直检测有无新消息出现。连接会保持一段时间周期直到数据或状态改变或者时间过期，通过这种机制来减少无效的客户端和服务器间的交互。&lt;/p&gt;
&lt;p&gt;虽然长轮循比传统的轮询性能会有些提高，但在服务器端数据变化非常频繁的情况下，两者的性能并不能差多少，因为都是客户端先请求，服务器再响应，只是两者服务器端响应的机制不同。&lt;br&gt;下面来说说代码，服务器端我用的是php，客户端用的是jQuery&lt;/p&gt;
&lt;p&gt;服务器端代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/**
 * @desc ajax长轮询 来获取通知消息信息
 * @return 通知信息数量&amp;gt;o
 */
public function longPolling(){


    if(!$_GET[&amp;apos;timed&amp;apos;]) exit();
    date_default_timezone_set(&amp;quot;PRC&amp;quot;);
    session_write_close(); //防止session访问互斥问题
    set_time_limit(0);//无限请求超时时间
    $timed = $_GET[&amp;apos;timed&amp;apos;];
    while (true) {
        sleep(3); // 休眠3秒
        //判断有无新通知出现
         $no_count=D(&amp;apos;Notifications&amp;apos;)-&amp;gt;getNotificationsCount($this-&amp;gt;uid);
         if ($no_count&amp;gt;0) {
            $responseTime = time();
            // 返回数据信息，请求时间、返回数据时间、耗时
            $content=array(
                &amp;apos;result&amp;apos;         =&amp;gt;$no_count,
                &amp;apos;reponse_time&amp;apos;   =&amp;gt;$responseTime,
                &amp;apos;request_time&amp;apos;   =&amp;gt;$timed,
                &amp;apos;use_time&amp;apos;       =&amp;gt;($responseTime - $timed)
            );
            echo $this-&amp;gt;ajaxReturn($content);
            exit();
        } else { // 模拟没有数据变化，将休眠 hold住连接
            sleep(13);
            exit();
        }
    }


}
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java多态学习</title>
    <link href="http://yoursite.com/2017/06/23/java%E5%A4%9A%E6%80%81%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yoursite.com/2017/06/23/java多态学习/</id>
    <published>2017-06-23T12:46:18.002Z</published>
    <updated>2017-06-23T13:05:55.245Z</updated>
    
    <content type="html"><![CDATA[<p>在java多态中，引用与对象可以是不同的类型，如:</p>
<pre><code>A b=new B();
</code></pre><p>运用多态时，引用类型可以是实际对象类型的父类，即实际对象类型已经是一个比较具体的类，而引用类型则是一个比较抽象的类，任何extends过声明引用类型的对象都可以赋值给这个引用变量，这样就可以做出类似动态数组的东西，如下:</p>
<pre><code>Animal[] a=new Animal[2];
a[0]=new Dog();
a[1]=new Cat();
for(int i=0;i&lt;a.length;i++){
    a[i].eat();
}
</code></pre><p>a数组里面可以放任何Animal的子类对象，调用的时候可以把子类都当作Animal来操作，实际上调用的是子类的方法，是不是很好玩呢→_→</p>
<p>当然，多态的应用很广泛呢，参数和返回类型也可以多态，如下:</p>
<pre><code>class Vet{
   public void giveShot(Anmial a){

      a.makeNoise();
   }
}

class Pet{
   public void a(){
      Vet v=new Vet();
      Dog dog=new Dog();
      Cat cat=new Cat();
      v.giveShot(dog);
      v.giveShot(cat);
   }

}
</code></pre><p>giveShot会接受任何Animal的子类的对象实例，根据传入的参数不同，会调用不同对象的方法。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在java多态中，引用与对象可以是不同的类型，如:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;A b=new B();
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;运用多态时，引用类型可以是实际对象类型的父类，即实际对象类型已经是一个比较具体的类，而引用类型则是一个比较抽象的类，任何extends
    
    </summary>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>javaee 配置数据源后数据库连接未及时关闭出现的问题</title>
    <link href="http://yoursite.com/2017/06/23/javaee%20%20%E9%85%8D%E7%BD%AE%E6%95%B0%E6%8D%AE%E6%BA%90%E5%90%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%9C%AA%E5%8F%8A%E6%97%B6%E5%85%B3%E9%97%AD%E5%87%BA%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2017/06/23/javaee  配置数据源后数据库连接未及时关闭出现的问题/</id>
    <published>2017-06-23T12:43:01.663Z</published>
    <updated>2017-06-23T13:11:12.869Z</updated>
    
    <content type="html"><![CDATA[<p>我在配置要数据源后没有仔细检查我的代码，有些数据库连接没有及时关闭，报以下异常:</p>
<blockquote>
<p>org.apache.tomcat.dbcp.dbcp.SQLNestedException: Cannot get a connection, pool error Timeout waiting for idle objec</p>
</blockquote>
<p>这个异常产生的原因是在使用完数据库连接后没有及时关闭，导致数据库连接池的连接没有可供使用的连接，进而报异常。<br>解决的方法是检查代码，将数据库连接及时关闭，并且在context.xml文件中加上</p>
<blockquote>
<p>removeAbandoned=”true” removeAbandonedTimeout=”60”<br>logAbandoned=”true”</p>
</blockquote>
<p>这样就解决问题了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我在配置要数据源后没有仔细检查我的代码，有些数据库连接没有及时关闭，报以下异常:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;org.apache.tomcat.dbcp.dbcp.SQLNestedException: Cannot get a connection, poo
    
    </summary>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>javaee 配置Tomcat数据源问题</title>
    <link href="http://yoursite.com/2017/06/23/javaee%20%E9%85%8D%E7%BD%AETomcat%E6%95%B0%E6%8D%AE%E6%BA%90%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2017/06/23/javaee 配置Tomcat数据源问题/</id>
    <published>2017-06-23T12:42:10.365Z</published>
    <updated>2017-06-23T13:44:22.704Z</updated>
    
    <content type="html"><![CDATA[<p>最近用javaee写网站配置数据源时遇到了这个错误:</p>
<blockquote>
<p>java.lang.ClassCastException: org.apache.tomcat.dbcp.dbcp.PoolingDataSource$PoolGuardConnectionWrapper cannot be cast to com.mysql.jdbc.Connection</p>
</blockquote>
<p>经过我查看代码发现有些类中包导错了，涉及到数据库的包应该导入java.sql.*这个相关的，而我用ide自动导入为jdbc那个了，发生了类型不匹配问题，改掉就不会报这个错了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近用javaee写网站配置数据源时遇到了这个错误:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;java.lang.ClassCastException: org.apache.tomcat.dbcp.dbcp.PoolingDataSource$PoolGuardConne
    
    </summary>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>php json_encode函数使用遇到的问题</title>
    <link href="http://yoursite.com/2017/06/23/php%20%20json_encode%E5%87%BD%E6%95%B0%E4%BD%BF%E7%94%A8%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2017/06/23/php  json_encode函数使用遇到的问题/</id>
    <published>2017-06-23T12:35:53.853Z</published>
    <updated>2017-06-23T13:10:15.317Z</updated>
    
    <content type="html"><![CDATA[<p>在php中有一个函数可以将数组转化为json数据存储格式，这个函数就是json_encode<br>但在使用这个函数时转化的格式不一致，比如：</p>
<pre><code>//关联二位数组
$a2=array(    
  &apos;1&apos;=&gt;array(&apos;name&apos;=&gt;&apos;john&apos;,&apos;age&apos;=&gt;&apos;32&apos;),
  &apos;2&apos;=&gt;array(&apos;name&apos;=&gt;&apos;tom&apos;,&apos;age&apos;=&gt;&apos;22&apos;)
);
$json2=json_encode($a2);
echo $json2.&quot;&lt;br&gt;&quot;; //{&quot;1&quot;:{&quot;name&quot;:&quot;john&quot;,&quot;age&quot;:&quot;32&quot;},&quot;2&quot;:{&quot;name&quot;:&quot;tom&quot;,&quot;age&quot;:&quot;22&quot;}}
//索引二维数组
$a3=array(
   array(&apos;name&apos;=&gt;&apos;zz&apos;,&apos;age&apos;=&gt;&apos;31&apos;),
   array(&apos;name&apos;=&gt;&apos;we&apos;,&apos;AGE&apos;=&gt;&apos;12&apos;)
  );
 $json3=json_encode($a3);
 echo $json3.&quot;&lt;br&gt;&quot;;//[{&quot;name&quot;:&quot;zz&quot;,&quot;age&quot;:&quot;31&quot;},{&quot;name&quot;:&quot;we&quot;,&quot;AGE&quot;:&quot;12&quot;}]
</code></pre><p>关联二维数组和索引二维数组转化为json数据格式不同，这时在前台用js解析json的时候就有差别</p>
<ul>
<li>对于关联数组生成的json数据格式 ，在前台直接用js的eval()将其转化为json对象，然后根据{key:value}取值</li>
<li>对于索引数组生成的json数据格式，用js的eval()转为json对象后，由于[]代表数组格式，所以遇到[]还是按照数组取值，遇到{key:value}这种形式的按照对象取值就行了</li>
</ul>
<p>当数组维数多的时候需要根据转换后的json数据格式用js进行相应的解析，避免出错。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在php中有一个函数可以将数组转化为json数据存储格式，这个函数就是json_encode&lt;br&gt;但在使用这个函数时转化的格式不一致，比如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//关联二位数组
$a2=array(    
  &amp;apos;1&amp;apos;=&amp;gt;array(
    
    </summary>
    
    
      <category term="php" scheme="http://yoursite.com/tags/php/"/>
    
  </entry>
  
  <entry>
    <title>关于首页feed流如何展示和数据库如何设计问题</title>
    <link href="http://yoursite.com/2017/06/23/%E5%85%B3%E4%BA%8E%E9%A6%96%E9%A1%B5feed%E6%B5%81%E5%A6%82%E4%BD%95%E5%B1%95%E7%A4%BA%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2017/06/23/关于首页feed流如何展示和数据库如何设计问题/</id>
    <published>2017-06-23T12:34:14.035Z</published>
    <updated>2017-06-23T13:10:23.029Z</updated>
    
    <content type="html"><![CDATA[<p>最近在做一个简单的问答网站，首页的内容需要根据用户关注的话题和关注的问题等来展示最新的动态信息，刚开始的时候我想数据库表的设计是关键。</p>
<p>这里涉及到两个概念 <strong>推模式（push）</strong>和<strong>拉模式（pull）</strong>，这里有两篇大神分享的知识<a href="http://blog.sina.com.cn/s/blog_53b95aec0100ujim.html" target="_blank" rel="external"> 新浪微博架构和FEED架构分析–人人架构<em>paper0023</em>新浪博客</a>和<a href="http://www.cnblogs.com/sunli/archive/2010/08/24/twitter_feeds_push_pull.html" target="_blank" rel="external">微博feed系统的推(push)模式和拉(pull)模式和时间分区拉模式架构探讨</a>，讲解的比较清楚</p>
<blockquote>
<p>简单来说，什么是推，什么是拉呢？</p>
</blockquote>
<ol>
<li><strong>推模式</strong>是一个用户发表了一条动态，那么后台就遍历关注该用户的所有用户，向他们的feed中推送一条动态</li>
<li><strong>拉模式</strong>与推模式相反，当用户刷新首页时，后台会遍历该用户关注的用户的动态信息，并将动态信息压入到该用户的feed中</li>
</ol>
<p>简单介绍完推拉模式后，下面就要考虑数据库表该怎么设计了，我采用的是最简单的推模式，毕竟新手嘛，先掌握实现流程。</p>
<hr>
<p>首先设计feed表，这里我设计一个feed表来存储推送的信息，该表主要有以下几个字段</p>
<ul>
<li>id  自增id</li>
<li>suid  推送者uid</li>
<li>ruid  接收者uid</li>
<li>item_id  推送的信息id</li>
<li>type   推送信息类型</li>
<li>add_time  推送时间</li>
</ul>
<p>这是我感觉很简单的feed表，毕竟我那个问答站推送类型不是太多，当然还需要为这个表设计索引哦。<br>设计完数据库表后，下面该考虑后台推送逻辑和代码如何实现以及前台首页如何渲染feed流信息。</p>
<hr>
<p>后台我用的是PHP的ThinkPHP框架，新手表示该框架很好用，用该框架可以快速实现的我的想法，我感觉这一点还是很好的。首先在推送类型的选择中我选择了以下几种推送类型</p>
<ul>
<li>当一个话题下有新话题发起时，推送给关注该话题的用户</li>
<li>当一个问题有回答时，推送给关注该问题的用户</li>
<li>当一个话题的问题有新回答时，推送给关注该话题的用户</li>
</ul>
<p>上面推送过程中会产生大量的重复信息，所以需要在推送时对推送信息进行过滤，以避免重复的推送信息出现。代码就是当上面的推送类型产生时，将信息写入到feed表中，这里并没有对推送用户进行筛选（对推送用户的筛选可以降低数据库的压力）。</p>
<p>前台渲染的话需要对信息进行排序整合，并对每一条动态信息进行标记，以便在模板渲染时匹配对应的模板。<br>我写的简单部分整合代码，需要对信息进行遍历整合（这里没写）</p>
<pre><code> //如果推送类型 为a  则代表推送信息类型为  用户关注的话题有关的问题或关注的问题产生的回答
 $aid=$val[&apos;item_id&apos;];
 /**根据回答id获取获取与此回答有关的信息**/
 //获取推送人的uid
 $suid=$val[&apos;suid&apos;];
 //获取当前用户对回答的赞同状态
 $upvote_status=$this-&gt;getUpvoteStatusByAid($aid, $uid);
//获取feed流 回答信息
 $a_info_all=$this-&gt;getFeedAnswerInfo($aid);
 $question_id=$a_info_all[0][&apos;question_id&apos;];
 //根据问题id获取与此问题相关的话题信息
 $tinfo_a=D(&apos;Topic&apos;)-&gt;getFeedTopicByQuestion($question_id);
 //将话题信息追加到回答信息数组中
 $a_info_all[0][&apos;topic&apos;]= $tinfo_a;
 //将当前用户对回答的赞同状态最佳到信息数组中
 $a_info_all[0][&apos;upvote_status&apos;]=$upvote_status;
 //将整理后的信息添加到feed数组中，并做一个标记 a,以便在模板中判断解析
 $arr_fd[&apos;answer&apos;]=$a_info_all;
 $arr_fd[&apos;feed_flag&apos;]=&apos;a&apos;;
 $feed_return_arr[]=  $arr_fd;
</code></pre><p>这里 $feed_return_arr[]是一个三维数组，在模板渲染的时候要注意一下。<br><a id="more"></a><br>上面是我对feed流简单的思考，如果是真实网络环境下这种简单的实现有许多大问题，比如feed表数据量过大，是否设定一个时间阀对表中超过该时间阀的推送信息进行删除以减少feed表的记录量等等。所以这种方式并不适合真实的网络环境，需要将推拉模式结合进行使用。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在做一个简单的问答网站，首页的内容需要根据用户关注的话题和关注的问题等来展示最新的动态信息，刚开始的时候我想数据库表的设计是关键。&lt;/p&gt;
&lt;p&gt;这里涉及到两个概念 &lt;strong&gt;推模式（push）&lt;/strong&gt;和&lt;strong&gt;拉模式（pull）&lt;/strong&gt;，这里有两篇大神分享的知识&lt;a href=&quot;http://blog.sina.com.cn/s/blog_53b95aec0100ujim.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt; 新浪微博架构和FEED架构分析–人人架构&lt;em&gt;paper0023&lt;/em&gt;新浪博客&lt;/a&gt;和&lt;a href=&quot;http://www.cnblogs.com/sunli/archive/2010/08/24/twitter_feeds_push_pull.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;微博feed系统的推(push)模式和拉(pull)模式和时间分区拉模式架构探讨&lt;/a&gt;，讲解的比较清楚&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;简单来说，什么是推，什么是拉呢？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;推模式&lt;/strong&gt;是一个用户发表了一条动态，那么后台就遍历关注该用户的所有用户，向他们的feed中推送一条动态&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;拉模式&lt;/strong&gt;与推模式相反，当用户刷新首页时，后台会遍历该用户关注的用户的动态信息，并将动态信息压入到该用户的feed中&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;简单介绍完推拉模式后，下面就要考虑数据库表该怎么设计了，我采用的是最简单的推模式，毕竟新手嘛，先掌握实现流程。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;首先设计feed表，这里我设计一个feed表来存储推送的信息，该表主要有以下几个字段&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;id  自增id&lt;/li&gt;
&lt;li&gt;suid  推送者uid&lt;/li&gt;
&lt;li&gt;ruid  接收者uid&lt;/li&gt;
&lt;li&gt;item_id  推送的信息id&lt;/li&gt;
&lt;li&gt;type   推送信息类型&lt;/li&gt;
&lt;li&gt;add_time  推送时间&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这是我感觉很简单的feed表，毕竟我那个问答站推送类型不是太多，当然还需要为这个表设计索引哦。&lt;br&gt;设计完数据库表后，下面该考虑后台推送逻辑和代码如何实现以及前台首页如何渲染feed流信息。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;后台我用的是PHP的ThinkPHP框架，新手表示该框架很好用，用该框架可以快速实现的我的想法，我感觉这一点还是很好的。首先在推送类型的选择中我选择了以下几种推送类型&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当一个话题下有新话题发起时，推送给关注该话题的用户&lt;/li&gt;
&lt;li&gt;当一个问题有回答时，推送给关注该问题的用户&lt;/li&gt;
&lt;li&gt;当一个话题的问题有新回答时，推送给关注该话题的用户&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;上面推送过程中会产生大量的重复信息，所以需要在推送时对推送信息进行过滤，以避免重复的推送信息出现。代码就是当上面的推送类型产生时，将信息写入到feed表中，这里并没有对推送用户进行筛选（对推送用户的筛选可以降低数据库的压力）。&lt;/p&gt;
&lt;p&gt;前台渲染的话需要对信息进行排序整合，并对每一条动态信息进行标记，以便在模板渲染时匹配对应的模板。&lt;br&gt;我写的简单部分整合代码，需要对信息进行遍历整合（这里没写）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; //如果推送类型 为a  则代表推送信息类型为  用户关注的话题有关的问题或关注的问题产生的回答
 $aid=$val[&amp;apos;item_id&amp;apos;];
 /**根据回答id获取获取与此回答有关的信息**/
 //获取推送人的uid
 $suid=$val[&amp;apos;suid&amp;apos;];
 //获取当前用户对回答的赞同状态
 $upvote_status=$this-&amp;gt;getUpvoteStatusByAid($aid, $uid);
//获取feed流 回答信息
 $a_info_all=$this-&amp;gt;getFeedAnswerInfo($aid);
 $question_id=$a_info_all[0][&amp;apos;question_id&amp;apos;];
 //根据问题id获取与此问题相关的话题信息
 $tinfo_a=D(&amp;apos;Topic&amp;apos;)-&amp;gt;getFeedTopicByQuestion($question_id);
 //将话题信息追加到回答信息数组中
 $a_info_all[0][&amp;apos;topic&amp;apos;]= $tinfo_a;
 //将当前用户对回答的赞同状态最佳到信息数组中
 $a_info_all[0][&amp;apos;upvote_status&amp;apos;]=$upvote_status;
 //将整理后的信息添加到feed数组中，并做一个标记 a,以便在模板中判断解析
 $arr_fd[&amp;apos;answer&amp;apos;]=$a_info_all;
 $arr_fd[&amp;apos;feed_flag&amp;apos;]=&amp;apos;a&amp;apos;;
 $feed_return_arr[]=  $arr_fd;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这里 $feed_return_arr[]是一个三维数组，在模板渲染的时候要注意一下。&lt;br&gt;
    
    </summary>
    
    
      <category term="php" scheme="http://yoursite.com/tags/php/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2017/06/23/hello-world/"/>
    <id>http://yoursite.com/2017/06/23/hello-world/</id>
    <published>2017-06-23T10:10:30.046Z</published>
    <updated>2017-06-23T10:10:30.046Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>markdown-01</title>
    <link href="http://yoursite.com/2017/06/22/markdown-01/"/>
    <id>http://yoursite.com/2017/06/22/markdown-01/</id>
    <published>2017-06-22T07:44:07.000Z</published>
    <updated>2017-06-22T08:46:20.941Z</updated>
    
    <content type="html"><![CDATA[<p><em>试试一下markdowm</em></p>
<h2 id="这是一个标题"><a href="#这是一个标题" class="headerlink" title="这是一个标题"></a>这是一个标题</h2><ol>
<li>这是第一行列表项</li>
<li>这是第二行列表项</li>
</ol>
<h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><p>Markdown 支持有序列表和无序列表。</p>
<p>无序列表使用星号、加号或是减号作为列表标记：</p>
<pre>
*   Red
*   Green
*   Blue
</pre>
等同于：
<pre>
+   Red
+   Green
+   Blue
</pre>
也等同于：
<pre>
-   Red
-   Green
-   Blue
</pre>
有序列表则使用数字接着一个英文句点：
<pre>
1.  Bird
2.  McHale
3.  Parish
</pre>

<h2 id="代码区块"><a href="#代码区块" class="headerlink" title="代码区块"></a>代码区块</h2><p>markdown使用<pre></pre><code></code> 来将代码包裹起来</p>
<h2 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h2><hr>
<hr>
<hr>
<hr>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">System.out.println(&quot;helllo world&quot;);</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[This link](http://example.net/) has no title attribute.</div></pre></td></tr></table></figure>
<p><a href="http://example.net/" target="_blank" rel="external">This link</a> has no title attribute.</p>
<h2 id="强调"><a href="#强调" class="headerlink" title="强调"></a>强调</h2><p>Markdown 使用星号（<em>）和底线（_）作为标记强调字词的符号，被 </em> 或 <em> 包围的字词会被转成用 <em> 标签包围，用两个 * 或 </em> 包起来的话，则会被转成 <strong>，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">*single asterisks*</div><div class="line"></div><div class="line">_single underscores_</div><div class="line"></div><div class="line">**double asterisks**</div><div class="line"></div><div class="line">__double underscores__</div></pre></td></tr></table></figure></strong></em></p>
<p>会转成：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;em&gt;single asterisks&lt;/em&gt;</div><div class="line"></div><div class="line">&lt;em&gt;single underscores&lt;/em&gt;</div><div class="line"></div><div class="line">&lt;strong&gt;double asterisks&lt;/strong&gt;</div><div class="line"></div><div class="line">&lt;strong&gt;double underscores&lt;/strong&gt;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;试试一下markdowm&lt;/em&gt;&lt;/p&gt;
&lt;h2 id=&quot;这是一个标题&quot;&gt;&lt;a href=&quot;#这是一个标题&quot; class=&quot;headerlink&quot; title=&quot;这是一个标题&quot;&gt;&lt;/a&gt;这是一个标题&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;这是第一行列表项&lt;/li&gt;
&lt;li&gt;这
    
    </summary>
    
    
      <category term="markdown" scheme="http://yoursite.com/tags/markdown/"/>
    
  </entry>
  
</feed>
