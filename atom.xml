<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Mingshan&#39;s Blog</title>
  
  <subtitle>一念开明，反身而诚</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://mingshan.me/"/>
  <updated>2018-11-28T15:28:53.702Z</updated>
  <id>http://mingshan.me/</id>
  
  <author>
    <name>Mingshan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Hadoop之初体验</title>
    <link href="http://mingshan.me/2018/11/28/Hadoop%E4%B9%8B%E5%88%9D%E4%BD%93%E9%AA%8C/"/>
    <id>http://mingshan.me/2018/11/28/Hadoop之初体验/</id>
    <published>2018-11-27T16:00:00.000Z</published>
    <updated>2018-11-28T15:28:53.702Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Hadoop 主要是运行在Linux平台，所以安装和测试都在Linux上，这里以Ubuntu Linux系统为例来安装和配置Hadoop。</p><a id="more"></a><h2 id="配置Hadoop用户组"><a href="#配置Hadoop用户组" class="headerlink" title="配置Hadoop用户组"></a>配置Hadoop用户组</h2><p><strong>创建Hadoop用户组：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo addgroup hadoop</span><br></pre></td></tr></table></figure><p><strong>创建Hadoop用户：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo adduser -ingroup hadoop hadoop</span><br></pre></td></tr></table></figure><p>回车后会提示输入密码，这是新建Hadoop的密码，输入两次密码敲回车即可。如下图所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">mingshan@ubuntu:/usr$ sudo adduser -ingroup hadoop hadoop</span><br><span class="line">Adding user `hadoop&apos; ...</span><br><span class="line">Adding new user `hadoop&apos; (1001) with group `hadoop&apos; ...</span><br><span class="line">Creating home directory `/home/hadoop&apos; ...</span><br><span class="line">Copying files from `/etc/skel&apos; ...</span><br><span class="line">Enter new UNIX password: </span><br><span class="line">Retype new UNIX password: </span><br><span class="line">passwd: password updated successfully</span><br><span class="line">Changing the user information for hadoop</span><br><span class="line">Enter the new value, or press ENTER for the default</span><br><span class="line">Full Name []: </span><br><span class="line">Room Number []: </span><br><span class="line">Work Phone []: </span><br><span class="line">Home Phone []: </span><br><span class="line">Other []: </span><br><span class="line">Is the information correct? [Y/n] y</span><br></pre></td></tr></table></figure><p><strong>为Hadoop用户添加权限：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo vim /etc/sudoers</span><br></pre></td></tr></table></figure><p>然后在</p><p><code>root　　　　ALL=(ALL:ALL) ALL</code></p><p>后添加：</p><p><code>hadoop　　 ALL=(ALL:ALL) ALL</code></p><p>如下所示：</p><p><img src="https://github.com/ZZULI-TECH/interview/blob/master/images/sudoers.png?raw=true" alt="image"></p><p><strong>切换hadoop用户</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">su - hadoop</span><br></pre></td></tr></table></figure><h2 id="配置SSH"><a href="#配置SSH" class="headerlink" title="配置SSH"></a>配置SSH</h2><p>Linux 系统需要安装ssh和rsync，命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install ssh </span><br><span class="line">$ sudo apt-get install rsync</span><br></pre></td></tr></table></figure><p>检测sshd运行状态</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl status sshd</span><br></pre></td></tr></table></figure><h2 id="镜像下载"><a href="#镜像下载" class="headerlink" title="镜像下载"></a>镜像下载</h2><p>首先选择国内的镜像速度较快</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ wget http://mirror.bit.edu.cn/apache/hadoop/common/hadoop-3.1.1/hadoop-3.1.1.tar.gz</span><br></pre></td></tr></table></figure><p>解压</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo tar -zxvf hadoop-3.1.1.tar.gz</span><br></pre></td></tr></table></figure><p>将hadoop移动到 /usr/local/hadoop目录下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo mv hadoop-3.1.1 /usr/local/hadoop</span><br></pre></td></tr></table></figure><p>给hadoop用户授予<code>/usr/local/hadoop</code>文件夹权限：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo chown -R hadoop:hadoop /usr/local/hadoop</span><br></pre></td></tr></table></figure></p><h2 id="运行hadoop"><a href="#运行hadoop" class="headerlink" title="运行hadoop"></a>运行hadoop</h2><p><strong>Hadoop部署模式</strong></p><p>Hadoop部署模式有：本地模式、伪分布模式、完全分布式模式、HA完全分布式模式。</p><p>下面是各模式的区别：</p><table><thead><tr><th>模式名称</th><th>各个模块占用的JVM进程数</th><th>各个模块运行在几个机器数上</th></tr></thead><tbody><tr><td>本地模式</td><td>1个</td><td>1个</td></tr><tr><td>伪分布式模式</td><td>N个</td><td>1个</td></tr><tr><td>完全分布式模式</td><td>N个</td><td>N个</td></tr><tr><td>HA完全分布式</td><td>N个</td><td>N个</td></tr></tbody></table><h3 id="本地模式部署"><a href="#本地模式部署" class="headerlink" title="本地模式部署"></a>本地模式部署</h3><p>我们来测试本地部署模式，用在带的例子（比如WordCount）进行测试</p><p>首先在<code>/usr/local/hadoop/hadoop-3.1.1</code> 文件夹下创建<code>input</code>文件夹</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir input</span><br></pre></td></tr></table></figure><p>拷贝 README.txt 到 input 文件夹</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cp README.txt input</span><br></pre></td></tr></table></figure><p>运行测试例子，命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ bin/hadoop jar share/hadoop/mapreduce/sources/hadoop-mapreduce-examples-3.1.1-sources.jar org.apache.hadoop.examples.WordCount input output</span><br></pre></td></tr></table></figure><p>运行后会在屏幕上输出一大堆东西，最终如下：</p><p><img src="https://github.com/ZZULI-TECH/interview/blob/master/images/hadoop/hadoop-example1-result.png?raw=true" alt="image"></p><p>OK, 安装测试完毕，撒花✿✿ヽ(°▽°)ノ✿</p><p>参考：</p><ul><li><a href="http://hadoop.apache.org/docs/r1.0.4/cn/quickstart.html" target="_blank" rel="noopener">Hadoop快速入门</a></li><li><a href="https://www.cnblogs.com/maybe2030/p/4591195.html" target="_blank" rel="noopener">在Ubuntu系统上一步步搭建Hadoop（单机模式）</a></li><li><a href="https://blog.csdn.net/hliq5399/article/details/78193113" target="_blank" rel="noopener">史上最详细的Hadoop环境搭建</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Hadoop 主要是运行在Linux平台，所以安装和测试都在Linux上，这里以Ubuntu Linux系统为例来安装和配置Hadoop。&lt;/p&gt;
    
    </summary>
    
      <category term="Hadoop" scheme="http://mingshan.me/categories/Hadoop/"/>
    
    
      <category term="Hadoop" scheme="http://mingshan.me/tags/Hadoop/"/>
    
  </entry>
  
  <entry>
    <title>Java虚拟机的监控及诊断工具（GUI）</title>
    <link href="http://mingshan.me/2018/11/22/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7%EF%BC%88GUI%EF%BC%89/"/>
    <id>http://mingshan.me/2018/11/22/Java虚拟机的监控及诊断工具（GUI）/</id>
    <published>2018-11-21T16:00:00.000Z</published>
    <updated>2018-11-24T16:36:28.753Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>前面我们总结了<a href="http://mingshan.me/2018/10/21/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7%EF%BC%88%E5%91%BD%E4%BB%A4%E8%A1%8C%EF%BC%89/">Java虚拟机的监控及诊断工具(命令行)</a>相关命令的使用，用命令行虽然说比较方便，但不够直观，要是有图形显示JVM运行的一些情况就好了。<code>eclipse MAT</code> 和 <code>Java Mission Control</code> 是两个使用比较广泛的GUI虚拟机的监控及诊断工具，下面让我们来用用吧。</p><a id="more"></a><h2 id="Eclipse-MAT"><a href="#Eclipse-MAT" class="headerlink" title="Eclipse MAT"></a>Eclipse MAT</h2><p>在命令行那篇，我们已经知道可以用<code>jmap</code> 命令来生成Java虚拟机堆dump文件，那么我们就可以用Eclipse的<a href="https://www.eclipse.org/mat/" target="_blank" rel="noopener">Memory Analyzer (MAT)</a>工具来解析了。</p><p>MAT 支持自己获取dump 文件，它是利用<code>jps</code>命令来列出正在运行的虚拟机进程信息，然后进行选择将要分析的虚拟机进程，如下图所示：</p><p><img src="https://github.com/ZZULI-TECH/interview/blob/master/images/mat/mat_acquire_heap_dump.png?raw=true" alt="image"></p><p>我们来选择刚启动的SpringBoot应用，点击对应的选项后，MAT会加载堆快照信息，完成后主界面将会有一个饼状图，列举占据的 <code>Retained heap</code> 最多的几个对象。如下图所示：</p><p><img src="https://github.com/ZZULI-TECH/interview/blob/master/images/mat/mat_overview.png?raw=true" alt="image"></p><p><code>Retained heap</code>是什么意思，感觉好陌生啊。。不慌，我们来查一下，在Eclipse documentation的Memory Analyzer章节中，介绍了MAT计算内存占用的两种方式，<a href="https://help.eclipse.org/mars/index.jsp?topic=%2Forg.eclipse.mat.ui.help%2Fconcepts%2Fshallowretainedheap.html&amp;cp=46_2_1" target="_blank" rel="noopener">Shallow Heap 和 Retained Heap</a>，简单地了解下：</p><p><strong>Shallow Heap</strong></p><p>Shallow Heap 是一个对象所占用的内存，不包括它所引用对象的内存，根据32/64位操作系统的不同，该值的计算结果可能有所不同。</p><p><strong>Retained Heap</strong></p><p>Retained Heap 是一个对象不再被引用时，GC所能回收的总内存，包括对象自身占用的内存，以及仅能通过该对象引用的其他对象所占据的内存。即一些对象需要依赖该对象而存活，GC Roots 不直接引用。下面放一张官方介绍的图解析一下（如下图所示），由于H还被F直接引用，所以E的Retaned Set 只包括E 和 G，不包括H，其他同理。上面饼状图所显示的就是Retained Heap。</p><p><img src="https://github.com/ZZULI-TECH/interview/blob/master/images/mat/mat_shallow_retained.png?raw=true" alt="image"></p><p>Mat包含了几种比较重要的视图，<code>Histogram</code>（直方图）和<code>dominator tree</code>（支配树），也提供了线程总览视图。</p><h3 id="Histogram（直方图）"><a href="#Histogram（直方图）" class="headerlink" title="Histogram（直方图）"></a><code>Histogram</code>（直方图）</h3><p><img src="https://github.com/ZZULI-TECH/interview/blob/master/images/mat/mat_histogram.png?raw=true" alt="image"></p><p>点击直方图按钮，样式如上图所示。包含各类的对象数量以及Shallow Heap的大小，还统计了Retained Heap的大小，只不过该值为近似值。支持对图中的四个列进行排序，默认是Shallow Heap。</p><p>当我们点击具体的类名时，在下面的Inspector面板显示该类的相关信息，比如包名、类名、类加载等信息，如下图所示：<br><img src="https://github.com/ZZULI-TECH/interview/blob/master/images/mat/mat_histogram_inspector.png?raw=true" alt="image"></p><h3 id="dominator-tree（支配树）"><a href="#dominator-tree（支配树）" class="headerlink" title="dominator tree（支配树）"></a><code>dominator tree</code>（支配树）</h3><p>下面讨论一下支配树视图，说这个之前首先要知道在Java中是通过可达性分析（Reachability Analysis）来判定对象是否存活的。这个算法是基于被称为“GC Roots”的对象作为起点，从这些节点开始向下搜索，所走过的路径被称为引用链（Reference Chain），当一个对象到GC Roots没有任何引用链，则这个对象是不可用的。这种概念源自于图论。如下图所示：</p><p><img src="https://github.com/ZZULI-TECH/interview/blob/master/images/gc_root.png?raw=true" alt="image"></p><p>在Java语言中，可以作为GC Roots的对象有以下几种：</p><ul><li>所有Java线程当前活跃的栈帧里指向GC堆里的对象的引用；换句话说，当前所有正在被调用的方法的引用类型的参数/局部变量/临时值。</li><li>VM的一些静态数据结构里指向GC堆里的对象的引用，例如说HotSpot VM里的Universe里有很多这样的引用。</li><li>JNI handles，包括global handles和local handles</li><li>（看情况）所有当前被加载的Java类</li><li>（看情况）Java类的引用类型静态变量</li><li>（看情况）Java类的运行时常量池里的引用类型常量（String或Class类型）</li><li>（看情况）String常量池（StringTable）里的引用</li></ul><p>好了，掌握了这么多姿势，来看看支配树的样子，MAT 将默认按照每个对象 Retained heap 的大小排列支配树，如下图所示：</p><p><img src="https://github.com/ZZULI-TECH/interview/blob/master/images/mat/mat_dominator_tree.png?raw=true" alt="image"></p><p>从图中可以看出，对象的引用呈链式引用，垃圾回收器回收第一个对象，那么处于链式引用的对象也可以被回收。</p><h3 id="定位溢出源"><a href="#定位溢出源" class="headerlink" title="定位溢出源"></a>定位溢出源</h3><p>我们还可以利用MAT 提供 的 <code>Path To GC Roots</code>功能来反推出该对象到GC Roots的引用路径，如下图所示：</p><p><img src="https://github.com/ZZULI-TECH/interview/blob/master/images/mat/mat_path_to_gc_roots.png?raw=true" alt="image"></p><p>MAT 还提供了<code>Merge Shortest Paths to GC Roots</code> 来显示GC根节点到选中对象的引用路径，如下图所示：</p><p><img src="https://github.com/ZZULI-TECH/interview/blob/master/images/mat/mat_dominator_tree_merge.png?raw=true" alt="image"></p><p><img src="https://github.com/ZZULI-TECH/interview/blob/master/images/mat/mat_dominator_tree_merge_result.png?raw=true" alt="image"></p><p><code>exclude all phantom/weak/soft etc. reference</code> 意思是排除虚引用、弱引用和软引用，即只剩下强引用，因为除了强引用之外，其他的引用都可以被JVM GC掉，如果一个对象始终无法被GC，就说明有强引用存在，从而导致在GC的过程中一直得不到回收，最终就内存溢出了。</p><p>MAT 还提供查询等功能，简直是强大，有空要好好用下，嘻嘻~</p><h2 id="Java-Mission-Control"><a href="#Java-Mission-Control" class="headerlink" title="Java Mission Control"></a>Java Mission Control</h2><p>了解完Mat， 感觉已经很强大，Java 官方有没有提供类似的工具呢？<br>Java Mission Control(JMC) 和 Java Flight Recorder(飞行记录仪) 是从Java官方提供的一个完整的工具链用来收集JVM底层运行时的信息，可以在线监控JVM的运行情况和进行事后数据分析。</p><p>Java Mission Control是Java虚拟机平台的性能检测工具。它包含一个GUI客户端，以及众多众多用来收集JVM性能数据的插件，其中包括Java Flight Recorder。</p><p>Java Flight Recorder是一个内置在Oracle JDK中的分析和事件收集框架。它允许开发人员收集关于Java虚拟机(JVM)和Java应用程序行为的详细底层信息。</p><p>JMC 是从Java1.7 开始提供的，不过自Java 11开始，不再包含在Java的发行包中，需要单独下载。JFR 在JDK11 开源了，但在之前的 Java 版本，JFR 属于 Commercial Feature，需要通过 <code>-XX:+UnlockCommercialFeatures</code>开启。</p><p>启动JMC，然后选择我们要监控的Java的进程，稍等一会就显示出该进程的概览面板，包括当前当前进程的CPU占用率，堆内存情况等信息，注意这些都是实时监控。如下图所示：</p><p><img src="https://github.com/ZZULI-TECH/interview/blob/master/images/jmc/jmc_overview.png?raw=true" alt="image"></p><p>我们也可以用它来查看当前进程所运行线程的相关情况，包括线程的状态，阻塞次数，CPU总体占用率，是否发生死锁以及分配的内存，挺详细的，如下图所示：</p><p><img src="https://github.com/ZZULI-TECH/interview/blob/master/images/jmc/jmc_thread.png?raw=true" alt="image"></p><h3 id="JFR"><a href="#JFR" class="headerlink" title="JFR"></a>JFR</h3><p>JFR 开启的方式主要有三种，</p><p><strong>第一种</strong>是在运行目标 Java 程序时添加<code>-XX:StartFlightRecording=</code>参数。关于该参数的配置详情，你可以参考<a href="https://docs.oracle.com/en/java/javase/11/tools/java.html#GUID-3B1CE181-CD30-4178-9602-230B800D4FAE" target="_blank" rel="noopener">该帮助文档</a>（请在页面中搜索<code>-XX:StartFlightRecording</code>）。</p><p>下面的这条命令是在JVM启动后5秒（delay=5s），持续时间为20秒（duration=20s），当收集完后，将数据保存在<code>myrecored.jfr</code>文件中（filename=myrecored.jfr）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ java -XX:StartFlightRecording=delay=5s,duration=20s,filename=myrecored.jfr,settings=profile MyApp</span><br></pre></td></tr></table></figure><p><strong>第二种</strong>是通过jcmd来让 JFR 开始收集数据、停止收集数据，或者保存所收集的数据，对应的子命令分别为JFR.start，JFR.stop，以及JFR.dump。</p><p><strong>第三种</strong>就是我们要操作的，通过JMC的JFR插件来启动。下面是启动参数配置，在该配置选项中，可以配置记录文件的存放位置、持续收集时间等信息：</p><p><img src="https://github.com/ZZULI-TECH/interview/blob/master/images/jmc/jfr_start.png?raw=true" alt="image"></p><p>等待收集信息完毕，会出现outline界面，首先映入我们眼帘的是jfr的自动分析结果，CPU暂用率阿等信息，如下图所示：</p><p><img src="https://github.com/ZZULI-TECH/interview/blob/master/images/jmc/jfr_overview.png?raw=true" alt="image"></p><p>我们发现左边出现了一个outline界面，包括Java应用程序的信息（线程、内存等），JVM内部信息（GC、类加载、TLAB分配等），环境信息（环境变量、当前进程CPU占用情况等）和事件浏览器。如下图所示：</p><p><img src="https://github.com/ZZULI-TECH/interview/blob/master/images/jmc/jfr_outline.png?raw=true" alt="image"></p><p><strong>查看Java应用程序的信息</strong></p><p>点击左侧outline的Java应用程序按钮，在右边会出现当前进程的相关数据总览，包括当前的线程、堆使用情况、CPU占用情况等信息，从下方的图中可以看出发生GC了：</p><p><img src="https://github.com/ZZULI-TECH/interview/blob/master/images/jmc/jfr_application.png?raw=true" alt="image"></p><p>当然你可以点击Java应用程序下的小按钮，例如点击内存按钮，显示内存的使用情况：</p><p><img src="https://github.com/ZZULI-TECH/interview/blob/master/images/jmc/jfr_memory.png?raw=true" alt="image"></p><p><strong>查看GC情况</strong></p><p>在虚拟机内部栏，点击垃圾收集按钮，会在右侧显示垃圾回收的情况，包含垃圾回收的次数及暂停时间，当点击具体的一次垃圾收集时，注意在左下角会显示当前垃圾收集的参数，包括类型、开始结束时间等信息。如下图所示：</p><p><img src="https://github.com/ZZULI-TECH/interview/blob/master/images/jmc/jfr_gc.png?raw=true" alt="image"></p><p>其他的就不再一一介绍了。。贼多~</p><h2 id="jvisualvm"><a href="#jvisualvm" class="headerlink" title="jvisualvm"></a>jvisualvm</h2><p>Java VisualVM（<a href="https://docs.oracle.com/javase/8/docs/technotes/guides/visualvm/" target="_blank" rel="noopener">帮助文档</a>）在JDK11中已被移除，暂时不用了。</p><p>参考：</p><ul><li><a href="https://time.geekbang.org/column/article/40821" target="_blank" rel="noopener">Java虚拟机的监控及诊断工具（GUI篇）</a></li><li><a href="https://help.eclipse.org/mars/index.jsp?topic=%2Forg.eclipse.mat.ui.help%2Fconcepts%2Fshallowretainedheap.html&amp;cp=46_2_1" target="_blank" rel="noopener">Shallow vs. Retained Heap</a></li><li><a href="https://help.eclipse.org/luna/index.jsp?topic=%2Forg.eclipse.mat.ui.help%2Fconcepts%2Fgcroots.html&amp;cp=37_2_3" target="_blank" rel="noopener">Garbage Collection Roots</a></li><li><a href="https://www.zhihu.com/question/53613423/answer/135743258" target="_blank" rel="noopener">java的gc为什么要分代？ - RednaxelaFX的回答 - 知乎</a></li><li><a href="http://jdk.java.net/jmc/" target="_blank" rel="noopener">Java Mission Control</a></li><li><a href="https://docs.oracle.com/javacomponents/jmc-5-5/jmc-user-guide/" target="_blank" rel="noopener"> Java Mission Control User’s Guide</a></li><li><a href="https://docs.oracle.com/javase/8/docs/technotes/guides/visualvm/" target="_blank" rel="noopener">Java VisualVM</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前面我们总结了&lt;a href=&quot;http://mingshan.me/2018/10/21/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7%EF%BC%88%E5%91%BD%E4%BB%A4%E8%A1%8C%EF%BC%89/&quot;&gt;Java虚拟机的监控及诊断工具(命令行)&lt;/a&gt;相关命令的使用，用命令行虽然说比较方便，但不够直观，要是有图形显示JVM运行的一些情况就好了。&lt;code&gt;eclipse MAT&lt;/code&gt; 和 &lt;code&gt;Java Mission Control&lt;/code&gt; 是两个使用比较广泛的GUI虚拟机的监控及诊断工具，下面让我们来用用吧。&lt;/p&gt;
    
    </summary>
    
      <category term="JVM" scheme="http://mingshan.me/categories/JVM/"/>
    
    
      <category term="JVM" scheme="http://mingshan.me/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Apache ServiceComb Saga分布式事务框架体验</title>
    <link href="http://mingshan.me/2018/11/07/Apache%20ServiceComb%20Saga%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E6%A1%86%E6%9E%B6%E4%BD%93%E9%AA%8C/"/>
    <id>http://mingshan.me/2018/11/07/Apache ServiceComb Saga分布式事务框架体验/</id>
    <published>2018-11-06T16:00:00.000Z</published>
    <updated>2018-11-07T13:36:18.842Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Apache ServiceComb (incubating) Saga 是一个微服务应用的数据最终一致性解决方案。</p><a id="more"></a><p>Saga Pack 架构是由 alpha 和 omega组成，其中：</p><ul><li>alpha充当协调者的角色，主要负责对事务进行管理和协调。</li><li>omega是微服务中内嵌的一个agent，负责对网络请求进行拦截并向alpha上报事务事件。</li></ul><p>下图展示了alpha, omega以及微服务三者的关系： </p><p><img src="https://github.com/ZZULI-TECH/interview/blob/master/images/pack.png?raw=true" alt="image"></p><p>看了它的架构方案，我们需要用例子来理解它的机制和使用方式，Saga为我们提供了一系列Demo，包含与Spring、Dubbo等结合使用的例子，下面就用与Spring结合的例子</p><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>首先我们需要从<a href="https://github.com/apache/incubator-servicecomb-saga" target="_blank" rel="noopener">github 仓库</a>克隆源代码到本地，然后在项目根目录执行如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn clean package -DskipTests -Pdemo</span><br></pre></td></tr></table></figure><p>该命令会编译源代码，跳过单元测试，并且编译demo项目。</p><h2 id="运行Alpha-Server"><a href="#运行Alpha-Server" class="headerlink" title="运行Alpha Server"></a>运行Alpha Server</h2><p>从上面的架构图看出，alpha充当协调者的角色，所以我们需要先运行Alpha Server，Alpha Server是需要数据库支持，默认用的PostgreSQL数据库，我们在项目中使用MySQL较多，所以需要切换为MySQL数据库。</p><p>先在<code>alpha/alpha-server/pom.xml</code> 文件中添加MySQL数据库驱动依赖，然后重新编译</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>接下来创建数据库<code>saga</code>和表，数据库Schema<a href="https://github.com/apache/incubator-servicecomb-saga/blob/master/alpha/alpha-server/src/main/resources/schema-mysql.sql" target="_blank" rel="noopener">在这里</a>，首先执行该数据库脚本，创建相应的表<br>，包括<code>TxEvent</code>、<code>Command</code>、<code>TxTimeout</code>、<code>tcc_global_tx_event</code>、<code>tcc_participate_event</code>、<code>tcc_tx_event</code>这几张表。</p><p>接下来运行Alpha Server，进入到<code>alpha\alpha-server\target\saga</code>文件夹，运行如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Dspring.profiles.active=mysql -D&quot;spring.datasource.url=jdbc:mysql://127.0.0.1:3306/saga?useSSL=false&amp;allowPublicKeyRetrieval=true&quot; -D&quot;spring.datasource.username=root&quot; -D&quot;spring.datasource.password=admin&quot; -jar alpha-server-0.3.0-SNAPSHOT-exec.jar</span><br></pre></td></tr></table></figure><p>该命令指明了数据库的<code>url</code>、<code>username</code>、<code>password</code>, 同时指定spring的profile为mysql，注意<code>alpha-server-0.3.0-SNAPSHOT-exec.jar</code> 该jar包为本目录下的jar包。</p><p> 默认情况下，8080端口用于处理omega处发起的gRPC的请求，而8090端口用于处理查询存储在alpha处的事件信息。</p><h2 id="运行Demo"><a href="#运行Demo" class="headerlink" title="运行Demo"></a>运行Demo</h2><p>由于上面我们已经对demo项目进行了编译，下面我们就可以来执行了，demo分为三个项目，booking、car、hotel，流程是通过booking可以预定车和房间，分别调用car和hotel两个服务，来模拟分布式事务的流程。</p><p>下面启动hotel服务，这里做个控制，不允许预定超过二个房间，否则报错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Dserver.port=8081 -Dalpha.cluster.address=127.0.0.1:8080 -jar hotel-0.3.0-SNAPSHOT-exec.jar</span><br></pre></td></tr></table></figure><p>然后启动car服务：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Dserver.port=8082 -Dalpha.cluster.address=127.0.0.1:8080 -jar car-0.3.0-SNAPSHOT-exec.jar</span><br></pre></td></tr></table></figure><p>最后启动booking服务：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Dserver.port=8083 -Dalpha.cluster.address=127.0.0.1:8080 -Dcar.service.address=http://127.0.0.1:8082 -Dhotel.service.address=http://127.0.0.1:8081 -jar booking-0.3.0-SNAPSHOT-exec.jar</span><br></pre></td></tr></table></figure><p>三个服务启动后，首先预定2个车和2个房间，用curl或者postman发送请求：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -X POST http://127.0.0.1:8083/booking/test/2/2</span><br></pre></td></tr></table></figure><p>结果会预定成功，分别查询car 和 hotel 均会返回预定成功：</p><p>[hotel]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">curl -X http://127.0.0.1:8081/bookings</span><br><span class="line"></span><br><span class="line">[&#123;&quot;name&quot;:&quot;test&quot;,&quot;amount&quot;:2,&quot;confirmed&quot;:true,&quot;cancelled&quot;:false&#125;]</span><br></pre></td></tr></table></figure><p>[car]<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">curl -X http://127.0.0.1:8082/bookings</span><br><span class="line"></span><br><span class="line">[&#123;&quot;name&quot;:&quot;test&quot;,&quot;amount&quot;:2,&quot;confirmed&quot;:true,&quot;cancelled&quot;:false&#125;</span><br></pre></td></tr></table></figure></p><p>接下来要预定2个车和3个房间，此时会预定失败</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -X POST http://127.0.0.1:8083/booking/test/3/2</span><br></pre></td></tr></table></figure><p>分别查询car 和 hotel ，如下所示：</p><p>[hotel]<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">curl -X http://127.0.0.1:8081/bookings</span><br><span class="line"></span><br><span class="line">[&#123;&quot;name&quot;:&quot;test&quot;,&quot;amount&quot;:2,&quot;confirmed&quot;:true,&quot;cancelled&quot;:false&#125;]</span><br></pre></td></tr></table></figure></p><p>[car]<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">curl -X http://127.0.0.1:8082/bookings</span><br><span class="line"></span><br><span class="line">[&#123;&quot;name&quot;:&quot;test&quot;,&quot;amount&quot;:2,&quot;confirmed&quot;:true,&quot;cancelled&quot;:false&#125;,</span><br><span class="line">&#123;&quot;name&quot;:&quot;test&quot;,&quot;amount&quot;:2,&quot;confirmed&quot;:false,&quot;cancelled&quot;:true&#125;]</span><br></pre></td></tr></table></figure></p><p>我们知道预定三个房间会失败报错，这是预定的car就要进行回滚，不能预定成功，因为这是在一个预定事务里，所以查询car的预定情况，第二条记录就会显示<strong>cancel:true</strong></p><p>下图是上面操作的结果界面：</p><p><img src="https://github.com/ZZULI-TECH/interview/blob/master/images/saga-demo-result.png?raw=true" alt="image"></p><h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><ol><li>在应用入口添加 <code>@EnableOmega</code> 的注解来初始化omega的配置并与alpha建立连接。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableOmega</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    SpringApplication.run(Application.class, args);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>在全局事务的起点添加 <code>@SagaStart</code> 的注解。这里是在booking项目的预定方法加此注解，该方法包括预定车和房间。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SagaStart</span></span><br><span class="line"><span class="meta">@PostMapping</span>(<span class="string">"/booking/&#123;name&#125;/&#123;rooms&#125;/&#123;cars&#125;"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">order</span><span class="params">(@PathVariable String name,  @PathVariable Integer rooms, @PathVariable Integer cars)</span> </span>&#123;</span><br><span class="line">    template.postForEntity(</span><br><span class="line">        carServiceUrl + <span class="string">"/order/&#123;name&#125;/&#123;cars&#125;"</span>,</span><br><span class="line">        <span class="keyword">null</span>, String.class, name, cars);</span><br><span class="line">    </span><br><span class="line">    postCarBooking();</span><br><span class="line">    </span><br><span class="line">    template.postForEntity(</span><br><span class="line">        hotelServiceUrl + <span class="string">"/order/&#123;name&#125;/&#123;rooms&#125;"</span>,</span><br><span class="line">        <span class="keyword">null</span>, String.class, name, rooms);</span><br><span class="line">    </span><br><span class="line">    postBooking();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> name + <span class="string">" booking "</span> + rooms + <span class="string">" rooms and "</span> + cars + <span class="string">" cars OK"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>在子事务处添加 <code>@Compensable</code> 的注解并指明其对应的补偿方法。注意这里两个子事务都要加。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Compensable</span>(compensationMethod = <span class="string">"cancel"</span>)</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">order</span><span class="params">(CarBooking booking)</span> </span>&#123;</span><br><span class="line">    booking.confirm();</span><br><span class="line">    bookings.put(booking.getId(), booking);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cancel</span><span class="params">(CarBooking booking)</span> </span>&#123;</span><br><span class="line">    Integer id = booking.getId();</span><br><span class="line">    <span class="keyword">if</span> (bookings.containsKey(id)) &#123;</span><br><span class="line">      bookings.get(id).cancel();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意:</strong> </p><ol><li>实现的服务和补偿必须满足幂等的条件。</li><li>默认情况下，超时设置需要显式声明才生效。</li><li>若全局事务起点与子事务起点重合，需同时声明 <code>@SagaStart</code> 和 <code>@Compensable</code> 的注解。</li></ol><p><strong>对于<code>@Compensable</code>方法及<code>compenstation</code>方法的要求</strong></p><ol><li>这两个方法的参数列表完全一致。</li><li>这两个方法在写在同一个类中。</li><li>参数要能够序列化。</li><li>这两个方法是可交换的，即如果参数相同，这两个方法无论以什么顺序执行结果都是一样的</li></ol><h2 id="设计思路和运行机制"><a href="#设计思路和运行机制" class="headerlink" title="设计思路和运行机制"></a>设计思路和运行机制</h2><p>后面再深入研究(￣▽￣)~*</p><p>参考：</p><ul><li><a href="https://www.cnblogs.com/savorboard/p/distributed-system-transaction-consistency.html" target="_blank" rel="noopener">聊聊分布式事务，再说说解决方案</a></li><li><a href="https://docs.servicecomb.io/saga/en_US/index.html" target="_blank" rel="noopener">Saga DOC</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Apache ServiceComb (incubating) Saga 是一个微服务应用的数据最终一致性解决方案。&lt;/p&gt;
    
    </summary>
    
      <category term="分布式事务" scheme="http://mingshan.me/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"/>
    
    
      <category term="分布式事务" scheme="http://mingshan.me/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"/>
    
      <category term="Saga" scheme="http://mingshan.me/tags/Saga/"/>
    
  </entry>
  
  <entry>
    <title>分布式事务解决方案</title>
    <link href="http://mingshan.me/2018/11/06/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <id>http://mingshan.me/2018/11/06/分布式事务解决方案/</id>
    <published>2018-11-05T16:00:00.000Z</published>
    <updated>2018-11-06T11:37:01.242Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>分布式事务目前有以下几种解决方案：</p><a id="more"></a><p><strong>一. 两阶段提交（2PC）</strong></p><p>【强一致性】</p><p>2PC又叫做XA Transactions，XA是一个两阶段提交协议，该协议分为下面两个阶段：</p><ul><li>第一阶段：事务协调器要求每个涉及到事务的数据库预提交(precommit)此操作，并反映是否可以提交.</li><li>第二阶段：事务协调器要求每个数据库提交数据。 </li></ul><p>其中，如果有任何一个数据库否决此次提交，那么所有数据库都会被要求回滚它们在此事务中的那部分信息。</p><p><strong>二、补偿事务（TCC）</strong></p><p>【最终一致性】</p><p>TCC 其实就是采用的补偿机制，其核心思想是：针对每个操作，都要注册一个与其对应的确认和补偿（撤销）操作。它分为三个阶段：</p><ul><li>Try 阶段主要是对业务系统做检测及资源预留</li><li>Confirm 阶段主要是对业务系统做确认提交，Try阶段执行成功并开始执行 Confirm阶段时，默认 Confirm阶段是不会出错的。即：只要Try成功，Confirm一定成功。</li><li>Cancel 阶段主要是在业务执行错误，需要回滚的状态下执行的业务取消，预留资源释放。</li></ul><p>注意Confirm 和 Cancel要保证操作的幂等性。</p><p><strong>三、本地消息表（异步确保）</strong></p><p>【最终一致性】</p><p>将分布式事务拆分成本地事务进行处理</p><p>消息生产方，需要额外建一个消息表，并记录消息发送状态。消息表和业务数据要在一个事务里提交，也就是说他们要在一个数据库里面。然后消息会经过MQ发送到消息的消费方。如果消息发送失败，会进行重试发送。</p><p>消息消费方，需要处理这个消息，并完成自己的业务逻辑。此时如果本地事务处理成功，表明已经处理成功了，如果处理失败，那么就会重试执行。如果是业务上面的失败，可以给生产方发送一个业务补偿消息，通知生产方进行回滚等操作。</p><p>生产方和消费方定时扫描本地消息表，把还没处理完成的消息或者失败的消息再发送一遍。如果有靠谱的自动对账补账逻辑，这种方案还是非常实用的。</p><p><strong>四、Sagas 事务模型</strong></p><p>Saga事务模型又叫做长时间运行的事务（Long-running-transaction）</p><p><img src="https://github.com/ZZULI-TECH/interview/blob/master/images/saga.png?raw=true" alt="image"></p><p><a href="https://www.cs.cornell.edu/andru/cs711/2002fa/reading/sagas.pdf" target="_blank" rel="noopener">论文</a></p><p>参考：</p><ul><li><a href="https://www.cnblogs.com/savorboard/p/distributed-system-transaction-consistency.html" target="_blank" rel="noopener">聊聊分布式事务，再说说解决方案</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;分布式事务目前有以下几种解决方案：&lt;/p&gt;
    
    </summary>
    
      <category term="分布式事务" scheme="http://mingshan.me/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"/>
    
    
      <category term="分布式事务" scheme="http://mingshan.me/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>循环队列结构分析</title>
    <link href="http://mingshan.me/2018/11/01/%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90/"/>
    <id>http://mingshan.me/2018/11/01/循环队列结构分析/</id>
    <published>2018-10-31T16:00:00.000Z</published>
    <updated>2018-11-01T14:16:24.265Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="ArrayQueue假溢出"><a href="#ArrayQueue假溢出" class="headerlink" title="ArrayQueue假溢出"></a>ArrayQueue假溢出</h2><p>我们在利用数组实现队列的时候，发现数组队列会出现假溢出问题，即队列还没有满，但不能再往队列中放入元素了，如下图所示：</p><a id="more"></a><p><img src="https://github.com/ZZULI-TECH/interview/blob/master/images/ArrayQueue_false_overflow.png?raw=true" alt="image"></p><p>在数据进行出队的时候，每一个元素出队，指向队列头元素的head就会向后移动，导致head之前的元素被“遗忘”了，无法再次利用，出队的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isEmpty()) &#123;</span><br><span class="line">        E value = (E) elements[head];</span><br><span class="line">        <span class="comment">// 移除头部元素</span></span><br><span class="line">        elements[head] = <span class="keyword">null</span>;</span><br><span class="line">        head++;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，我们可以对数组队列进行一些优化。在插入元素的时候，我们检查一下tail是否已经指向了队尾，如果指向了队尾并且head不等于0的情况下，说明发生了假溢出，需要进行元素迁移工作，将head和tail之间的元素整体移动到 0 到 <code>tail - head</code> 的位置，这样就可以避免假溢出问题了（还是上面的图），实现代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 由于数组队列存在假溢出问题，所谓要进行数据搬运</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(e);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (tail == capacity) &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 证明队列是满的</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Queue full"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果head 不等于0，证明head之前的空间是空着的，所以需要进行数据搬运</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head; i &lt; tail; i++) &#123;</span><br><span class="line">            elements[i - head] = elements[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 搬运完更新head 和 tail</span></span><br><span class="line">        head = <span class="number">0</span>;</span><br><span class="line">        tail -= head; <span class="comment">// tail = tail - head</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 正常操作</span></span><br><span class="line">    elements[tail++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h2><p>上面我们知道了假溢出问题，并且找到了解决方式，但在添加元素的时候可能会出现数据移动工作，并不是十分优雅，有没有一种比较好的方式去处理这个问题呢？既不出现假溢出问题，又不移动数据，还…（想的太多），答案是有的。仔细想想如果我们将数组队列收尾相连会出现什么情况，哈哈，根本不用管假溢出问题了，添加元素的时候直接往后移动tail（tail 加 1）就完事了，是不是很酷？大致结构如下图所示：</p><p><img src="https://github.com/ZZULI-TECH/interview/blob/master/images/CircularQueue.png?raw=true" alt="image"></p><h3 id="空和满队列判断"><a href="#空和满队列判断" class="headerlink" title="空和满队列判断"></a>空和满队列判断</h3><p>看完描述和图示，我们可能会有疑问，head 和 tail的位置一直是不固定的，那么该如何判断队列是否满的呢？</p><p>当<strong>循环队列为空</strong>时，很明显head 和 tail 是相等的，如下图所示：</p><p><img src="https://github.com/ZZULI-TECH/interview/blob/master/images/CircularQueue_empty.png?raw=true" alt="image"></p><p>那么如何判断队列是否满了呢？ 由于我们用head与tail相等来判断队列为空的情况，所以队列满时，必须有一个空位来由我们的tail指向，如下图所示：</p><p><img src="https://github.com/ZZULI-TECH/interview/blob/master/images/CircularQueue_full.png?raw=true" alt="image"></p><p>上图只是一种情况，总结来说，队头指针head在队尾指针tail的下一位置时，队满。由于是环形结构，所以需要进行求余运算，例如<code>（5 + 1） % 8 = 3</code>，总结规律下来，就是 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(head + 1） % capacity = tail</span><br></pre></td></tr></table></figure><p>由于这种机制的存在，当队列满时，总有一个位置是被浪费掉的。</p><p><strong>构造函数和成员变量</strong></p><p>循环队列默认把元素存到数组里，所以这里用数组来保存队列里的元素，在构造函数中初始化容量和数组，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 队列内部数组默认容量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 队列内部数组的容量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> capacity;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 保存元素的数组</span></span><br><span class="line"><span class="keyword">private</span> Object[] elements;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指向队列头部</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> head;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指向队列尾部</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> tail;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 默认构造函数初始化</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CircularQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    capacity =  DEFAULT_CAPACITY;</span><br><span class="line">    elements = <span class="keyword">new</span> Object[capacity];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定队列内部数组容量进行初始化</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> capacity 指定容量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CircularQueue</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">    elements = <span class="keyword">new</span> Object[capacity];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面就不废话了，直接看实现吧，通过上面的分析，代码没什么难度了。嘻嘻^_^</p><p><strong>入队</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public boolean add(E e) &#123;</span><br><span class="line">    Objects.requireNonNull(e);</span><br><span class="line">    // 判断队列是否满了</span><br><span class="line">    if ((tail + 1) % capacity == head) &#123;</span><br><span class="line">        throw new IllegalStateException(&quot;Queue full&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    elements[tail] = e;</span><br><span class="line">    tail = (tail + 1) % capacity;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>出队</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public E poll() &#123;</span><br><span class="line">    // 如果 head == tail, 队列就为null</span><br><span class="line">    if (isEmpty()) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    E value = (E) elements[head];</span><br><span class="line">    head = (head + 1) % capacity;</span><br><span class="line">    return value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>打印</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 打印</span><br><span class="line"> */</span><br><span class="line">public String toString() &#123;</span><br><span class="line">    if (isEmpty()) &#123;</span><br><span class="line">        return &quot;[]&quot;;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        StringBuilder sb = new StringBuilder(&quot;[&quot;);</span><br><span class="line">        for (int i = head; i != tail; i = (i + 1) % capacity) &#123;</span><br><span class="line">          sb.append(elements[i].toString() + &quot;, &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        int len = sb.length();  </span><br><span class="line">        return sb.delete(len - 2, len).append(&quot;]&quot;).toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>源代码在<a href="https://github.com/mstao/data-structures/blob/master/Queue/src/pers/mingshan/queue/CircularQueue.java" target="_blank" rel="noopener">这里</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;ArrayQueue假溢出&quot;&gt;&lt;a href=&quot;#ArrayQueue假溢出&quot; class=&quot;headerlink&quot; title=&quot;ArrayQueue假溢出&quot;&gt;&lt;/a&gt;ArrayQueue假溢出&lt;/h2&gt;&lt;p&gt;我们在利用数组实现队列的时候，发现数组队列会出现假溢出问题，即队列还没有满，但不能再往队列中放入元素了，如下图所示：&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构" scheme="http://mingshan.me/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="队列" scheme="http://mingshan.me/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%98%9F%E5%88%97/"/>
    
    
      <category term="数据结构" scheme="http://mingshan.me/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="队列" scheme="http://mingshan.me/tags/%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>Java虚拟机的监控及诊断工具（命令行）</title>
    <link href="http://mingshan.me/2018/10/21/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7%EF%BC%88%E5%91%BD%E4%BB%A4%E8%A1%8C%EF%BC%89/"/>
    <id>http://mingshan.me/2018/10/21/Java虚拟机的监控及诊断工具（命令行）/</id>
    <published>2018-10-20T16:00:00.000Z</published>
    <updated>2018-10-21T15:51:31.693Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>对于普通的开发人员来说，可以阅读帮助文档或者源码来对JDK的设计以及JVM的内存管理获取一定的了解，但对于线上运行的程序，如何对程序进行监控和诊断呢？比如一个程序挂了，怎么通过分析堆栈信息、GC日志、线程快照等信息来快速定位问题？JDK的大佬早就为我们考虑到这一点，所以在JDK中包含了许多用于监控及诊断的工具，主要分为两类，<strong>命令行工具</strong>和<strong>GUI工具</strong>，这些工具在平时的开发中用到的频率非常高，我们一起来总结了解下。</p><a id="more"></a><p>常用的命令行工具以及作用：</p><table><thead><tr><th>名称</th><th>主要作用</th></tr></thead><tbody><tr><td>jps</td><td>JVM Process Status Tool,  列出指定系统内正在运行的虚拟机进程</td></tr><tr><td>jstat</td><td>JVM Statistics Monitoring Tool，允许用户查看目标 Java 进程的类加载、即时编译以及垃圾回收相关信息。常用来检测垃圾回收及内存泄露问题。</td></tr><tr><td>jinfo</td><td>打印目标 Java 进程的配置参数，并能够改动其中 manageabe 的参数。</td></tr><tr><td>jmap</td><td>统计用户统计目标 Java 进程的堆中存放的 Java 对象，生成堆转储快照（heapdump文件）</td></tr><tr><td>jstack</td><td>打印目标 Java 进程中各个线程的栈轨迹、线程状态、锁状况等信息，它还将自动检测死锁。</td></tr><tr><td>jcmd</td><td>实现前面除了jstat之外所有命令的功能</td></tr></tbody></table><h2 id="jps"><a href="#jps" class="headerlink" title="jps"></a>jps</h2><p>jps命令（<a href="https://docs.oracle.com/en/java/javase/11/tools/jps.html#GUID-6EB65B96-F9DD-4356-B825-6146E9EEC81E" target="_blank" rel="noopener">帮助文档</a>）用于列出正在运行的虚拟机进程信息，它的命令格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jps [ -q ] [ -mlvV ][hostid ]</span><br><span class="line">jps [ -help ]</span><br></pre></td></tr></table></figure><p>在默认情况下，jps的输出信息包括 Java 进程的进程ID以及主类名。jps还提供一些参数用于打印详细的信息。</p><p>其中 <code>-q</code>仅显示虚拟机的进程id， <code>-mlvV</code> 的意义如下：</p><ul><li><code>-m</code> 将打印传递给主类的参数</li><li><code>-l</code> 将打印模块名以及包名</li><li><code>-v</code> 将打印传递给虚拟机的参数</li><li><code>-V</code> 将打印传递给主类的参数、jar文件名等</li></ul><p>具体jps示例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ jps -l</span><br><span class="line">11988</span><br><span class="line">48932</span><br><span class="line">32696 org.jetbrains.idea.maven.server.RemoteMavenServer</span><br><span class="line">26140 jdk.jcmd/sun.tools.jps.Jps</span><br></pre></td></tr></table></figure><p>添加<code>-mlvV</code>打印更加详细的信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ jps -mlvV</span><br><span class="line">32696 org.jetbrains.idea.maven.server.RemoteMavenServer -Djava.awt.headless=true -Didea.version==2018.2.5 -Xmx768m -Didea.maven.embedder.version=3.5.4 -Dfile.encoding=GBK</span><br><span class="line">26924 jdk.jcmd/sun.tools.jps.Jps -mlvV -Dapplication.home=F:\develope\Java\Java11 -Xms8m -Djdk.module.main=jdk.jcmd</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure><h2 id="jstat"><a href="#jstat" class="headerlink" title="jstat"></a>jstat</h2><p><code>jstat</code>（<a href="https://docs.oracle.com/en/java/javase/11/tools/jstat.html#GUID-5F72A7F9-5D5A-4486-8201-E1D1BA8ACCB5" target="_blank" rel="noopener">帮助文档</a>）是用于监视虚拟机各种运行状态信息的命令行工具，它可以显示本地或者远程虚拟机进程中的类加载、内存、垃圾回收等信息，它的命令格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jstat generalOptions</span><br><span class="line">jstat -outputOptions [ -t] [-hlines] vmid [interval [count] ]</span><br></pre></td></tr></table></figure><p>其中<code>vmid</code>全称是Virtual Machine Identifier，就是<code>jps</code>命令显示的进程id，如果是远程虚拟机进程，<code>vmid</code>的格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[protocol:][//]lvmid[@hostname[:port]/servername]</span><br></pre></td></tr></table></figure><p><code>jstat</code>命令包含很多的子命令，主要分为3类：</p><ul><li>类加载（<code>-class</code>）</li><li>即时编译（<code>-compiler</code>和<code>-printcompilation</code>）</li><li>垃圾回收（<code>-gc*</code>）</li></ul><p>输入<code>jstat -options</code>显示如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ jstat -options</span><br><span class="line">-class</span><br><span class="line">-compiler</span><br><span class="line">-gc</span><br><span class="line">-gccapacity</span><br><span class="line">-gccause</span><br><span class="line">-gcmetacapacity</span><br><span class="line">-gcnew</span><br><span class="line">-gcnewcapacity</span><br><span class="line">-gcold</span><br><span class="line">-gcoldcapacity</span><br><span class="line">-gcutil</span><br><span class="line">-printcompilation</span><br></pre></td></tr></table></figure><p>参数<code>interval</code>和<code>count</code>代表查询间隔和次数，如果省略，默认查询一次。</p><p>现在我们要查询进程id 为26792的垃圾收集情况，并且是每隔2秒打印一次，共打印2次，命令和输出示例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ jstat -gc 26792 2s 2</span><br><span class="line"> S0C    S1C    S0U    S1U      EC       EU        OC         OU       MC     MU    CCSC   CCSU   YGC     YGCT    FGC    FGCT    CGC    CGCT     GCT</span><br><span class="line">5120.0 5120.0  0.0   5095.1 33280.0  30033.1   87552.0     2573.4   15232.0 14724.4 1920.0 1782.4      3    0.027   1      0.032   -          -    0.059</span><br><span class="line">5120.0 5120.0  0.0   5095.1 33280.0  30033.1   87552.0     2573.4   15232.0 14724.4 1920.0 1782.4      3    0.027   1      0.032   -          -    0.059</span><br></pre></td></tr></table></figure><p>在上面的示例中，输出了一大堆东西，那么这些是什么意思呢？前面说了，<code>jstat</code>有很多的关于垃圾回收的子命令，每个子命令的输出结果也不一样，具体可参考（<a href="https://docs.oracle.com/en/java/javase/11/tools/jstat.html#GUID-5F72A7F9-5D5A-4486-8201-E1D1BA8ACCB5" target="_blank" rel="noopener">帮助文档</a>）。我们知道JVM堆是分代的，前四个 表示Survivor 区的容量（Capacity）和已使用量（Utilization），EC表示当前Eden的容量，剩下的就不说了。</p><p>在翻阅文档的时候，发现没有CGC 和 CGCT的解释，它们分别代表并发 GC Stop-The-World 的次数和时间。</p><p><code>-t</code> 参数会显示时间戳列作为输出的第一列，它将在每行数据之前打印目标 Java 进程的启动以来的时间，示例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ jstat -gc -t 26792 2s 2</span><br><span class="line">Timestamp        S0C    S1C    S0U    S1U      EC       EU        OC         OU       MC     MU    CCSC   CCSU   YGC     YGCT    FGC    FGCT    CGC    CGCT     GCT</span><br><span class="line">         1949.1 5120.0 5120.0  0.0   5095.1 33280.0  31206.1   87552.0     2573.4   15232.0 14724.4 1920.0 1782.4      3    0.027   1      0.032   -          -   0.059</span><br><span class="line">         1951.1 5120.0 5120.0  0.0   5095.1 33280.0  31206.1   87552.0     2573.4   15232.0 14724.4 1920.0 1782.4      3    0.027   1      0.032   -          -   0.059</span><br></pre></td></tr></table></figure><h2 id="jmap"><a href="#jmap" class="headerlink" title="jmap"></a>jmap</h2><p><code>jmap</code>命令（<a href="https://docs.oracle.com/en/java/javase/11/tools/jmap.html#GUID-D2340719-82BA-4077-B0F3-2803269B7F41" target="_blank" rel="noopener">帮助文档</a>）用于生成堆转储快照，用于分析Java虚拟机堆中的对象。</p><p>它的命令格式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmap [options] pid</span><br></pre></td></tr></table></figure><p><code>jmap</code>命令的参数选项也包括很多种，具体如下：</p><p><strong>1. -clstats</strong></p><p>连接到正在运行的进程并打印Java堆被加载类的统计信息</p><p><strong>2. -finalizerinfo</strong></p><p>连接到正在运行的进程并打印所有待 finalize 的对象。</p><p><strong>3. -histo[:live]</strong></p><p>连接到正在运行的进程并统计各个类的实例数目以及占用内存，并按照内存使用量从多至少的顺序排列。此外，-histo:live只统计堆中还在存活的对象。</p><p><strong>4. -dump</strong></p><p>连接到正在运行的进程并导出Java虚拟机堆内存的快照。该子命令该包含如下参数：</p><ul><li>live  只保存堆中存活的对象</li><li>format=b 将使jmap导出与hprof（在 Java 9 中已被移除）-XX:+HeapDumpAfterFullGC、-XX:+HeapDumpOnOutOfMemoryError格式一样的文件</li><li>file=filename 指定导出堆内存快照的位置</li></ul><p>综合以上参数，示例命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmap -dump:live,format=b,file=heap.bin pid</span><br></pre></td></tr></table></figure><h2 id="jinfo"><a href="#jinfo" class="headerlink" title="jinfo"></a>jinfo</h2><p><code>jinfo</code>命令（<a href="https://docs.oracle.com/en/java/javase/11/tools/jinfo.html#GUID-69246B58-28C4-477D-B375-278F5F9830A5" target="_blank" rel="noopener">帮助文档</a>）用来实时地查看和调整虚拟机的各项参数。我们可以使用<code>jps -v</code>来查看传递给虚拟机的参数，即<code>System.getProperty</code>获取的<code>-D</code>参数，现在我们可以利用<code>jinfo</code>命令来获取了。</p><p>它的命令格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jinfo [option] pid</span><br></pre></td></tr></table></figure><p>它也包括了许多子命令，具体如下：</p><p><strong>1. -flag name</strong></p><p>打印指定的虚拟机参数的名称和值</p><p><strong>2. -flag [+|-]name</strong></p><p>用来修改目标 Java 进程的“manageable”虚拟机参数。其中<code>+</code>代表开启，<code>-</code>代表关闭。</p><p>输入<code>java -XX:+PrintFlagsFinal -version | grep manageable</code>来查看“manageable”虚拟机参数，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ java -XX:+PrintFlagsFinal -version | grep manageable</span><br><span class="line">     intx CMSAbortablePrecleanWaitMillis           = 100                                    &#123;manageable&#125; &#123;default&#125;</span><br><span class="line">     intx CMSTriggerInterval                       = -1                                     &#123;manageable&#125; &#123;default&#125;</span><br><span class="line">     intx CMSWaitDuration                          = 2000                                   &#123;manageable&#125; &#123;default&#125;</span><br><span class="line">     bool HeapDumpAfterFullGC                      = false                                  &#123;manageable&#125; &#123;default&#125;</span><br><span class="line">     bool HeapDumpBeforeFullGC                     = false                                  &#123;manageable&#125; &#123;default&#125;</span><br><span class="line">     bool HeapDumpOnOutOfMemoryError               = false                                  &#123;manageable&#125; &#123;default&#125;</span><br><span class="line">    ccstr HeapDumpPath                             =                                        &#123;manageable&#125; &#123;default&#125;</span><br><span class="line">    uintx MaxHeapFreeRatio                         = 70                                     &#123;manageable&#125; &#123;default&#125;</span><br><span class="line">    uintx MinHeapFreeRatio                         = 40                                     &#123;manageable&#125; &#123;default&#125;</span><br><span class="line">     bool PrintClassHistogram                      = false                                  &#123;manageable&#125; &#123;default&#125;</span><br><span class="line">     bool PrintConcurrentLocks                     = false                                  &#123;manageable&#125; &#123;default&#125;</span><br><span class="line">java version &quot;11&quot; 2018-09-25</span><br><span class="line">Java(TM) SE Runtime Environment 18.9 (build 11+28)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM 18.9 (build 11+28, mixed mode)</span><br></pre></td></tr></table></figure><p><strong>3. -flag name=value</strong></p><p>设置指定的虚拟机参数的值</p><p><strong>4. -flags</strong></p><p>打印全部的虚拟机参数，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ jinfo -flags 26792</span><br><span class="line">VM Flags:</span><br><span class="line">-XX:CICompilerCount=3 -XX:InitialHeapSize=134217728 -XX:MaxHeapSize=805306368 -XX:MaxNewSize=268435456 -XX:MinHeapDeltaBytes=524288 -XX:NewSize=44564480 -XX:OldSize=89653248 -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:-UseLargePagesIndividualAllocation -XX:+UseParallelGC</span><br></pre></td></tr></table></figure><p><strong>5. -sysprops</strong></p><p>打印java系统参数（Java System Properties）</p><h2 id="jstack"><a href="#jstack" class="headerlink" title="jstack"></a>jstack</h2><p><code>jstack</code>命令（<a href="https://docs.oracle.com/en/java/javase/11/tools/jstack.html#GUID-721096FC-237B-473C-A461-DBBBB79E4F6A" target="_blank" rel="noopener">帮助文档</a>）可以用来打印目标 Java 进程中各个线程的栈轨迹，以及这些线程所持有的锁。通过线程的栈轨迹可以定位线程长时间停顿的原因，如线程间死锁、死循环、请求外部资源导致长时间等待等。</p><p>它的命令格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jstack [options] pid</span><br></pre></td></tr></table></figure><p>它也有子命令：</p><p><strong>-l</strong></p><p>输出关于锁的附加信息，例如属于java.util.concurrent的ownable synchronizers列表</p><p>下面是一个示例，如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$ jstack -l 42680</span><br><span class="line">2018-10-21 23:09:17</span><br><span class="line">Full thread dump OpenJDK 64-Bit Server VM (25.152-b19 mixed mode):</span><br><span class="line"></span><br><span class="line">&quot;ApplicationImpl pooled thread 35&quot; #142 daemon prio=4 os_prio=-1 tid=0x0000000018422000 nid=0xafe8 waiting on condition [0x00000000458bf000]</span><br><span class="line">   java.lang.Thread.State: TIMED_WAITING (parking)</span><br><span class="line">        at sun.misc.Unsafe.park(Native Method)</span><br><span class="line">        - parking to wait for  &lt;0x00000000e1506488&gt; (a java.util.concurrent.SynchronousQueue$TransferStack)</span><br><span class="line">        at java.util.concurrent.locks.LockSupport.parkNanos(LockSupport.java:215)</span><br><span class="line">        at java.util.concurrent.SynchronousQueue$TransferStack.awaitFulfill(SynchronousQueue.java:460)</span><br><span class="line">        at java.util.concurrent.SynchronousQueue$TransferStack.transfer(SynchronousQueue.java:362)</span><br><span class="line">        at java.util.concurrent.SynchronousQueue.poll(SynchronousQueue.java:941)</span><br><span class="line">        at java.util.concurrent.ThreadPoolExecutor.getTask(ThreadPoolExecutor.java:1066)</span><br><span class="line">        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1127)</span><br><span class="line">        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)</span><br><span class="line">        at java.lang.Thread.run(Thread.java:745)</span><br><span class="line"></span><br><span class="line">   Locked ownable synchronizers:</span><br><span class="line">        - None</span><br></pre></td></tr></table></figure><p>在输出的信息中，会包含线程的状态，下面是常见的线程状态：</p><ol><li>RUNNABLE，线程处于执行中</li><li>BLOCKED，线程被阻塞</li><li>WAITING，线程正在等待</li><li>TIMED_WAITING 超时等待</li></ol><h2 id="jcmd"><a href="#jcmd" class="headerlink" title="jcmd"></a>jcmd</h2><p><code>jcmd</code>命令（<a href="https://docs.oracle.com/en/java/javase/11/tools/jcmd.html#GUID-59153599-875E-447D-8D98-0078A5778F05" target="_blank" rel="noopener">帮助文档</a>）可以向运行中的Java虚拟机(JVM)发送诊断命令。</p><p>它的命令格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jcmd &lt;pid | main class&gt; &lt;command ... | PerfCounter.print | -f  file&gt;</span><br><span class="line">jcmd -l</span><br><span class="line">jcmd -h</span><br></pre></td></tr></table></figure><p><strong>pid</strong></p><p>虚拟机的进程id</p><p><strong>main class</strong></p><p>接收诊断命令请求的进程的main类。</p><p><strong>command</strong></p><p>该命令必须是针对所选JVM的有效jcmd命令。jcmd的可用命令列表是通过运行help命令(jcmd pid help)获得的，其中pid是运行Java进程的进程ID。如果pid为0，命令将被发送到所有的Java进程。main class参数将用于部分或完全匹配用于启动Java的类。如果没有提供任何选项，它会列出正在运行的Java进程标识符以及用于启动进程的主类和命令行参数(与使用-l相同)。</p><p><strong>Perfcounter.print</strong></p><p>打印目标Java进程上可用的性能计数器。性能计数器的列表可能会随着Java进程的不同而产生变化。</p><p><strong>-f file</strong></p><p>从文件file中读取命令，然后在目标Java进程上调用这些命令。</p><p><strong>-l</strong></p><p>查看所有的进程列表信息。</p><p><strong>-h</strong><br>查看帮助信息。（同 -help）</p><p>jcmd的可用命令列表如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">$ jcmd 26792 help</span><br><span class="line">26792:</span><br><span class="line">The following commands are available:</span><br><span class="line">VM.native_memory</span><br><span class="line">ManagementAgent.stop</span><br><span class="line">ManagementAgent.start_local</span><br><span class="line">ManagementAgent.start</span><br><span class="line">GC.rotate_log</span><br><span class="line">Thread.print</span><br><span class="line">GC.class_stats</span><br><span class="line">GC.class_histogram</span><br><span class="line">GC.heap_dump</span><br><span class="line">GC.run_finalization</span><br><span class="line">GC.run</span><br><span class="line">VM.uptime</span><br><span class="line">VM.flags</span><br><span class="line">VM.system_properties</span><br><span class="line">VM.command_line</span><br><span class="line">VM.version</span><br><span class="line">help</span><br><span class="line"></span><br><span class="line">For more information about a specific command use &apos;help &lt;command&gt;&apos;.</span><br></pre></td></tr></table></figure><p>PS: 以后用到了再详细补充。。</p><p>参考：</p><ul><li><a href="https://docs.oracle.com/en/java/javase/11/tools/monitoring-tools-and-commands.html" target="_blank" rel="noopener">Monitoring Tools and Commands</a></li><li><a href="https://docs.oracle.com/en/java/javase/11/tools/troubleshooting-tools-and-commands.html" target="_blank" rel="noopener">Troubleshooting Tools and Commands</a></li><li><a href="https://time.geekbang.org/column/article/40520" target="_blank" rel="noopener">Java虚拟机的监控及诊断工具（命令行篇）</a></li><li>周志明，深入理解Java虚拟机:JVM高级特性与最佳实践（第二版）</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对于普通的开发人员来说，可以阅读帮助文档或者源码来对JDK的设计以及JVM的内存管理获取一定的了解，但对于线上运行的程序，如何对程序进行监控和诊断呢？比如一个程序挂了，怎么通过分析堆栈信息、GC日志、线程快照等信息来快速定位问题？JDK的大佬早就为我们考虑到这一点，所以在JDK中包含了许多用于监控及诊断的工具，主要分为两类，&lt;strong&gt;命令行工具&lt;/strong&gt;和&lt;strong&gt;GUI工具&lt;/strong&gt;，这些工具在平时的开发中用到的频率非常高，我们一起来总结了解下。&lt;/p&gt;
    
    </summary>
    
      <category term="JVM" scheme="http://mingshan.me/categories/JVM/"/>
    
    
      <category term="JVM" scheme="http://mingshan.me/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>ForkJoin实践及JMH基准测试其性能</title>
    <link href="http://mingshan.me/2018/10/19/ForkJoin%E5%AE%9E%E8%B7%B5%E5%8F%8AJMH%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95%E5%85%B6%E6%80%A7%E8%83%BD/"/>
    <id>http://mingshan.me/2018/10/19/ForkJoin实践及JMH基准测试其性能/</id>
    <published>2018-10-18T16:00:00.000Z</published>
    <updated>2018-10-19T16:18:41.068Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>熟悉Java Stream API的同学可能知道可以利用<code>parallelStream</code>来实现并行操作，而Stream的并行操作依赖JDK1.7引入的Fork/Join框架，提供实现并行编程的一种方案。下面是Doug Lea对并行编程的描述：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(recursively) splitting them into subtasks that are solved in</span><br><span class="line">parallel, waiting for them to complete, and then composing</span><br><span class="line">results.</span><br></pre></td></tr></table></figure><a id="more"></a><p>Fork/Join框架的主要设计思想是采用了类似分治算法（ divide−<br>and−conquer algorithms），将任务分割成许多小任务并行执行，最后合并计算结果，这比串行化执行效率提高不少。伪代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Result <span class="title">solve</span><span class="params">(Problem problem)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">if</span> (problem is small)</span><br><span class="line"> directly solve problem</span><br><span class="line"> <span class="keyword">else</span> &#123;</span><br><span class="line"> split problem into independent parts</span><br><span class="line"> fork <span class="keyword">new</span> subtasks to solve each part</span><br><span class="line"> join all subtasks</span><br><span class="line"> compose result from subresults</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里涉及到两个词，fork和join，在Doug Lea的论文中，有以下描述：</p><p>Fork：开启一个新的子任务进行计算</p><blockquote><p>The fork operation starts a new parallel fork/join subtask. </p></blockquote><p>Join: 导致当前任务等待直至被fork的线程计算完成</p><blockquote><p>The join operation causes the current task not to proceed until the<br>forked subtask has completed.</p></blockquote><p>从fork/join的描述来看，就是利用递归不断的划分子任务，直至任务被划分的足够小，直接串行执行足够简单，没有问题。</p><h2 id="测试和性能对比"><a href="#测试和性能对比" class="headerlink" title="测试和性能对比"></a>测试和性能对比</h2><p>我们通过计算1 ~ 100000000相加求和问题，来模拟fork/join并行执行，并通过与串行化for循环执行，利用线程池多线程并发执行 的时间对比，来推测fork/join的计算效率。</p><h3 id="FOR串行"><a href="#FOR串行" class="headerlink" title="FOR串行"></a>FOR串行</h3><p>先考虑最简单的情况，直接利用for循环执行上面的计算任务，这是在单线程情况下来执行的，也就是串行执行，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForLoopCalculatorImpl</span> <span class="keyword">implements</span> <span class="title">Calculator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">sum</span><span class="params">(<span class="keyword">long</span>[] numbers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> result = <span class="number">0L</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numbers.length; i++) &#123;</span><br><span class="line">            result += numbers[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码相当简单，无需多言。</p><h3 id="线程池并发"><a href="#线程池并发" class="headerlink" title="线程池并发"></a>线程池并发</h3><p>For循环执行时利用单线程来执行的，当计算任务较大时，我们可能会考虑使用多线程来处理计算任务，并且计算过程是异步的。首先考虑CPU核心数，将任务分割成与CPU核心数一样数量的子任务，避免CPU时间片的过度切换引起资源浪费。获取CPU核心数和初始化线程池的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> parallism = Runtime.getRuntime().availableProcessors();</span><br><span class="line"><span class="keyword">private</span> ExecutorService pool;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ExecutorServiceCalculatorImpl</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> corePoolSize = Math.max(<span class="number">2</span>, Math.min(parallism - <span class="number">1</span>, <span class="number">4</span>));</span><br><span class="line">    <span class="keyword">int</span> maximumPoolSize = parallism * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> keepAliveTime = <span class="number">30</span>;</span><br><span class="line">    System.out.println(String.format(<span class="string">"corePoolSize = %s, maximumPoolSize = %s"</span>, corePoolSize, maximumPoolSize));</span><br><span class="line">    BlockingQueue&lt;Runnable&gt; workQueue = <span class="keyword">new</span> LinkedBlockingDeque&lt;&gt;();</span><br><span class="line">    <span class="comment">// 线程的创建工厂</span></span><br><span class="line">    ThreadFactory threadFactory = <span class="keyword">new</span> ThreadFactory() &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger mCount = <span class="keyword">new</span> AtomicInteger(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Thread(r, <span class="string">"AdvacnedAsyncTask #"</span> + mCount.getAndIncrement());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线程池任务满载后采取的任务拒绝策略</span></span><br><span class="line">    RejectedExecutionHandler rejectHandler = <span class="keyword">new</span> ThreadPoolExecutor.DiscardOldestPolicy();</span><br><span class="line"></span><br><span class="line">    pool = <span class="keyword">new</span> ThreadPoolExecutor(corePoolSize,</span><br><span class="line">            maximumPoolSize,</span><br><span class="line">            keepAliveTime,</span><br><span class="line">            TimeUnit.SECONDS,</span><br><span class="line">            workQueue,</span><br><span class="line">            threadFactory,</span><br><span class="line">            rejectHandler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码是使用ThreadPoolExecutor来创建线程池的，这样会更加了解线程池使用的各种细节。</p><p>接下来我们就需要使用线程池，根据CPU核心数来划分一定数量的子任务，然后将这些子任务交给线程池里面的线程去执行。此时注意任务的划分不一定是均匀的，因为最后一份任务可能比其他的多或者少，需要特别处理一下，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">sum</span><span class="params">(<span class="keyword">long</span>[] numbers)</span> </span>&#123;</span><br><span class="line">    List&lt;Future&lt;Long&gt;&gt; futures = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把任务分解为 n 份，交给 n 个线程处理，</span></span><br><span class="line">    <span class="comment">// 此时由于int类型丢失精度</span></span><br><span class="line">    <span class="keyword">int</span> part = numbers.length / parallism;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; parallism; i++) &#123;</span><br><span class="line">        <span class="comment">// 进行任务分配</span></span><br><span class="line">        <span class="keyword">int</span> from = i * part;</span><br><span class="line">        <span class="comment">// 最后一份任务可能不均匀，直接分配给最后一个线程</span></span><br><span class="line">        <span class="keyword">int</span> to = (i == parallism - <span class="number">1</span>) ? numbers.length - <span class="number">1</span> : (i + <span class="number">1</span>) * part - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 提交计算任务</span></span><br><span class="line">        futures.add(pool.submit(<span class="keyword">new</span> SumTask(numbers, from, to)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把每个线程的结果相加，得到最终结果</span></span><br><span class="line">    <span class="keyword">long</span> total = <span class="number">0L</span>;</span><br><span class="line">    <span class="keyword">for</span> (Future&lt;Long&gt; future : futures) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            total += future.get();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ignore) &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    pool.shutdown();</span><br><span class="line">    <span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中涉及到一个计算任务<code>SumTask</code>，抽象出来用来计算从<code>from</code> 到 <code>to</code> 之间的数相加之和，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SumTask</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span>[] numbers;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> from;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> to;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SumTask</span><span class="params">(<span class="keyword">long</span>[] numbers, <span class="keyword">int</span> from, <span class="keyword">int</span> to)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.numbers = numbers;</span><br><span class="line">        <span class="keyword">this</span>.from = from;</span><br><span class="line">        <span class="keyword">this</span>.to = to;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> total = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = from; i &lt;= to; i++) &#123;</span><br><span class="line">            total += numbers[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> total;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看过上面的代码，我们主要是利用了线程池来并发来执行计算任务，同时利用了线程池异步的特性，从设计上来说比for循环串行执行要好，但由于涉及到CPU的时间片切换，执行耗时上可能会比串行执行要高。</p><h3 id="Fokr-Join"><a href="#Fokr-Join" class="headerlink" title="Fokr/Join"></a>Fokr/Join</h3><p>写完线程池并发执行计算任务，如果让我们来设计并行执行任务的框架，可能会想到用线程池来做，既然Doug Lea写出了Fork/Join框架，肯定不是利用我们现在的方式来做，那么他是如何实现的呢？</p><p>Fork/Join框架抽象出了<code>ForkJoinTask</code>来代表要执行的计算任务，该类实现了<code>Future</code>接口，比<code>Thread</code>更加轻量级。不过我们通常不需要直接继承该类，Fork/Join框架给我们提供了两个抽象类供我们继承：</p><ul><li><code>RecursiveTask</code> ：代表有返回值的计算任务 </li><li><code>RecursiveAction</code>：代表没有返回值的任务</li></ul><p>我们的计算任务有返回值，所以我们直接继承<code>RecursiveTask</code>就好了，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SumTask</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THRESHOLD = <span class="number">2000000</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span>[] numbers;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> start;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> end;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SumTask</span><span class="params">(<span class="keyword">long</span>[] numbers, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.numbers = numbers;</span><br><span class="line">        <span class="keyword">this</span>.start = start;</span><br><span class="line">        <span class="keyword">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Long <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断问题规模</span></span><br><span class="line">        <span class="keyword">if</span> ((end - start) &lt;= THRESHOLD) &#123;</span><br><span class="line">            <span class="keyword">long</span> result = <span class="number">0L</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt;= end; i++) &#123;</span><br><span class="line">                result += numbers[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将任务分割为多个小任务</span></span><br><span class="line">        <span class="keyword">int</span> middle = (start + end) / <span class="number">2</span>;</span><br><span class="line">        SumTask taskLeft = <span class="keyword">new</span> SumTask(numbers, start, middle);</span><br><span class="line">        SumTask taskRight = <span class="keyword">new</span> SumTask(numbers, middle + <span class="number">1</span>, end);</span><br><span class="line">        invokeAll(taskLeft, taskRight);</span><br><span class="line">        <span class="keyword">long</span> result = taskLeft.join() + taskRight.join();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们需要重写<code>RecursiveTask</code>类的<code>compute()</code>方法，在该方法中进行任务的分割操作。和开始我们见到的伪代码类似，先判断任务规模（其实也是递归终止条件），相当于一个阈值，任务规模小于这个阈值，直接进行计算；大于这个阈值，将任务一份为二，这样递归下去，直至任务不可再分。注意这里我们采用<code>invokeAll</code>来进行任务分割，不过很多网上的例子采用的是如下写法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 分别对子任务调用fork():</span><br><span class="line">subTask1.fork();</span><br><span class="line">subTask2.fork();</span><br></pre></td></tr></table></figure><p>在JDK官方例子中，这种写法是没有出现过的，也是不正确的，原因后面再分析。</p><p>Fork/Join框架提供了<code>ForkJoinPool</code>来执行我们分割好的任务，<code>pool.invoke(task)</code>来提交一个Fork/Join任务并发执行，然后获得异步执行的结果。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForkJoinCalculatorImpl</span> <span class="keyword">implements</span> <span class="title">Calculator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ForkJoinPool pool;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">sum</span><span class="params">(<span class="keyword">long</span>[] source)</span> </span>&#123;</span><br><span class="line">        pool = <span class="keyword">new</span> ForkJoinPool();</span><br><span class="line">        SumTask task = <span class="keyword">new</span> SumTask(source, <span class="number">0</span>, source.length - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> pool.invoke(task);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在利用Fork/Join计算任务时，可能会出现<code>StackOverflowError</code>，这是由于递归层数太深，导致超出JDK的设置，需要重新评估任务分割的程度或者调整大小。</p><p>如果任务分割不正确，还会抛出以下异常，需要关注：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.lang.NoClassDefFoundError: Could not initialize class java.util.concurrent.locks.AbstractQueuedSynchronizer$Node</span><br></pre></td></tr></table></figure><h3 id="计算耗时（基础测试）"><a href="#计算耗时（基础测试）" class="headerlink" title="计算耗时（基础测试）"></a>计算耗时（基础测试）</h3><p>上面三种计算方式究竟计算效率怎么样呢？我们来写个测试类测试一把，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">long[] numbers = LongStream.rangeClosed(1L, 100000000L).toArray();</span><br><span class="line"></span><br><span class="line">// 1 直接for循环</span><br><span class="line">Calculator calculator = new ForLoopCalculatorImpl();</span><br><span class="line">long currentTime1 = System.currentTimeMillis();</span><br><span class="line">long result1 = calculator.sum(numbers);</span><br><span class="line">long executedTime = System.currentTimeMillis() - currentTime1;</span><br><span class="line">System.out.println(&quot;直接循环计算结果：&quot; + result1 + &quot;, 耗时：&quot; + executedTime);</span><br><span class="line"></span><br><span class="line">// 2 利用线程池</span><br><span class="line">Calculator calculator2 = new ExecutorServiceCalculatorImpl();</span><br><span class="line">long currentTime2 = System.currentTimeMillis();</span><br><span class="line">long result2 = calculator2.sum(numbers);</span><br><span class="line">long executedTime2 = System.currentTimeMillis() - currentTime2;</span><br><span class="line">System.out.println(&quot;线程池计算结果：&quot; + result2 + &quot;, 耗时：&quot; + executedTime2);</span><br><span class="line"></span><br><span class="line">// 3 fork/join</span><br><span class="line">Calculator calculator3 = new ForkJoinCalculatorImpl();</span><br><span class="line">long currentTime3 = System.currentTimeMillis();</span><br><span class="line">long result3 = calculator3.sum(numbers);</span><br><span class="line">long executedTime3 = System.currentTimeMillis() - currentTime3;</span><br><span class="line">System.out.println(&quot;Fork/Join计算结果：&quot; + result3 + &quot;, 耗时：&quot; + executedTime3);</span><br></pre></td></tr></table></figure><p>计算结果如下：</p><p><img src="https://github.com/ZZULI-TECH/interview/blob/master/images/concurrency/fj_calculator_result.png?raw=true" alt="image"></p><p>我用的是Window10操作系统，CPU i5 7代、4核心，跑的时候CPU飙到了100%，由于是计算密集型任务，需要CPU的全力参与，也无可厚非。。如下：</p><p><img src="https://github.com/ZZULI-TECH/interview/blob/master/images/concurrency/fj_cpu.png?raw=true" alt="image"></p><p>从上面的计算结果来看，Fork/Join耗时最少，线程池次之，直接For循环是耗时最多的，简直是难以置信啊，不过这个结果可能不稳定，至少也说明了Fork/Join在某些场景下比较优秀的事实（结论未必正确）。</p><h3 id="基准测试（JMH）"><a href="#基准测试（JMH）" class="headerlink" title="基准测试（JMH）"></a>基准测试（JMH）</h3><p>上面我们是利用方法执行的开始与结束时间的差值来评估方法的执行性能，利用这种方式得出的结论往往是站不住脚的（不严谨），因为没有考虑到程序在运行时JVM所带来的影响，所以得出的结论未必可靠，我们也不能乱下结论。</p><p>那么有没有一个比较靠谱的性能测试框架呢？JMH（Java Microbenchmark Harness）是一个面向Java语言或JVM平台语言的性能基准测试框架，它针对的是纳秒级别、微秒级别、毫秒级别以及秒级别的性能测试。听上去是不是很叼？我们就用它来测试上面写的三个计算任务吧。</p><p>首先我们需要用<code>@Benchmark</code>来标识JMH基准测试的测试方法，用法和Junit的<code>@Test</code>类似，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span>[] numbers = LongStream.rangeClosed(<span class="number">1L</span>, <span class="number">100_000_000L</span>).toArray();</span><br><span class="line"></span><br><span class="line"><span class="meta">@Benchmark</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1 直接for循环</span></span><br><span class="line">    Calculator calculator = <span class="keyword">new</span> ForLoopCalculatorImpl();</span><br><span class="line">    calculator.sum(numbers);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Benchmark</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 2 利用线程池</span></span><br><span class="line">    Calculator calculator2 = <span class="keyword">new</span> ExecutorServiceCalculatorImpl();</span><br><span class="line">    calculator2.sum(numbers);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Benchmark</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 3 fork/join</span></span><br><span class="line">    Calculator calculator3 = <span class="keyword">new</span> ForkJoinCalculatorImpl();</span><br><span class="line">    calculator3.sum(numbers);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>别忘了添加相关依赖哦，目前最新版本已是<code>1.21</code>，由于JMH性能测试是运行其提供的Main方法，需要添加maven相关插件配置运行Main方法，如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.openjdk.jmh&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;jmh-core&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;$&#123;jmh.version&#125;&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.openjdk.jmh&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;jmh-generator-annprocess&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;$&#123;jmh.version&#125;&lt;/version&gt;</span><br><span class="line">  &lt;scope&gt;provided&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>maven插件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-shade-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">phase</span>&gt;</span>package<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">goal</span>&gt;</span>shade<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">finalName</span>&gt;</span>java11-tutorial<span class="tag">&lt;/<span class="name">finalName</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">transformers</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transformer</span> <span class="attr">implementation</span>=<span class="string">"org.apache.maven.plugins.shade.resource.ManifestResourceTransformer"</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">mainClass</span>&gt;</span>org.openjdk.jmh.Main<span class="tag">&lt;/<span class="name">mainClass</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">transformer</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">transformers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure><p>接下来在该项目主目录下运行<code>maven clean package</code>进行编译打包，然后运行<code>java -jar target/java11-tutorial.jar</code> 直接执行测试，它的输出如下（重复的省略）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"># JMH version: 1.21</span><br><span class="line"># VM version: JDK 11, Java HotSpot(TM) 64-Bit Server VM, 11+28</span><br><span class="line"># VM invoker: F:\develope\Java\Java11\bin\java.exe</span><br><span class="line"># VM options: &lt;none&gt;</span><br><span class="line"># Warmup: 5 iterations, 10 s each</span><br><span class="line"># Measurement: 5 iterations, 10 s each</span><br><span class="line"># Timeout: 10 min per iteration</span><br><span class="line"># Threads: 1 thread, will synchronize iterations</span><br><span class="line"># Benchmark mode: Throughput, ops/time</span><br><span class="line"># Benchmark: me.mingshan.demo.fj.Test.test1</span><br><span class="line"></span><br><span class="line"># Run progress: 0.00% complete, ETA 00:25:00</span><br><span class="line"># Fork: 1 of 5</span><br><span class="line"># Warmup Iteration   1: 11.702 ops/s</span><br><span class="line"># Warmup Iteration   2: 11.902 ops/s</span><br><span class="line"># Warmup Iteration   3: 11.014 ops/s</span><br><span class="line"># Warmup Iteration   4: 10.663 ops/s</span><br><span class="line"># Warmup Iteration   5: 11.611 ops/s</span><br><span class="line">Iteration   1: 11.615 ops/s</span><br><span class="line">Iteration   2: 11.981 ops/s</span><br><span class="line">Iteration   3: 13.429 ops/s</span><br><span class="line">Iteration   4: 12.363 ops/s</span><br><span class="line">Iteration   5: 10.350 ops/s</span><br><span class="line"></span><br><span class="line">...运行五次</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Result &quot;me.mingshan.demo.fj.Test.test1&quot;:</span><br><span class="line">  11.492 ±(99.9%) 0.864 ops/s [Average]</span><br><span class="line">  (min, avg, max) = (9.804, 11.492, 14.808), stdev = 1.154</span><br><span class="line">  CI (99.9%): [10.628, 12.356] (assumes normal distribution)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># JMH version: 1.21</span><br><span class="line"># VM version: JDK 11, Java HotSpot(TM) 64-Bit Server VM, 11+28</span><br><span class="line"># VM invoker: F:\develope\Java\Java11\bin\java.exe</span><br><span class="line"># VM options: &lt;none&gt;</span><br><span class="line"># Warmup: 5 iterations, 10 s each</span><br><span class="line"># Measurement: 5 iterations, 10 s each</span><br><span class="line"># Timeout: 10 min per iteration</span><br><span class="line"># Threads: 1 thread, will synchronize iterations</span><br><span class="line"># Benchmark mode: Throughput, ops/time</span><br><span class="line"># Benchmark: me.mingshan.demo.fj.Test.test2</span><br><span class="line"></span><br><span class="line"># Run progress: 33.33% complete, ETA 00:16:59</span><br><span class="line"># Fork: 1 of 5</span><br><span class="line"># Warmup Iteration   1: 17.420 ops/s</span><br><span class="line"># Warmup Iteration   2: 15.220 ops/s</span><br><span class="line"># Warmup Iteration   3: 15.497 ops/s</span><br><span class="line"># Warmup Iteration   4: 14.617 ops/s</span><br><span class="line"># Warmup Iteration   5: 17.724 ops/s</span><br><span class="line">Iteration   1: 18.410 ops/s</span><br><span class="line">Iteration   2: 18.326 ops/s</span><br><span class="line">Iteration   3: 16.326 ops/s</span><br><span class="line">Iteration   4: 15.471 ops/s</span><br><span class="line">Iteration   5: 15.603 ops/s</span><br><span class="line"></span><br><span class="line">...运行五次</span><br><span class="line"></span><br><span class="line">Result &quot;me.mingshan.demo.fj.Test.test2&quot;:</span><br><span class="line">  16.358 ±(99.9%) 1.549 ops/s [Average]</span><br><span class="line">  (min, avg, max) = (11.898, 16.358, 18.918), stdev = 2.068</span><br><span class="line">  CI (99.9%): [14.809, 17.907] (assumes normal distribution)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># JMH version: 1.21</span><br><span class="line"># VM version: JDK 11, Java HotSpot(TM) 64-Bit Server VM, 11+28</span><br><span class="line"># VM invoker: F:\develope\Java\Java11\bin\java.exe</span><br><span class="line"># VM options: &lt;none&gt;</span><br><span class="line"># Warmup: 5 iterations, 10 s each</span><br><span class="line"># Measurement: 5 iterations, 10 s each</span><br><span class="line"># Timeout: 10 min per iteration</span><br><span class="line"># Threads: 1 thread, will synchronize iterations</span><br><span class="line"># Benchmark mode: Throughput, ops/time</span><br><span class="line"># Benchmark: me.mingshan.demo.fj.Test.test3</span><br><span class="line"></span><br><span class="line"># Run progress: 66.67% complete, ETA 00:08:29</span><br><span class="line"># Fork: 1 of 5</span><br><span class="line"># Warmup Iteration   1: 14.169 ops/s</span><br><span class="line"># Warmup Iteration   2: 14.925 ops/s</span><br><span class="line"># Warmup Iteration   3: 14.652 ops/s</span><br><span class="line"># Warmup Iteration   4: 14.448 ops/s</span><br><span class="line"># Warmup Iteration   5: 14.090 ops/s</span><br><span class="line">Iteration   1: 14.948 ops/s</span><br><span class="line">Iteration   2: 15.234 ops/s</span><br><span class="line">Iteration   3: 15.371 ops/s</span><br><span class="line">Iteration   4: 15.451 ops/s</span><br><span class="line">Iteration   5: 18.772 ops/s</span><br><span class="line"></span><br><span class="line">...运行五次</span><br><span class="line"></span><br><span class="line">Result &quot;me.mingshan.demo.fj.Test.test3&quot;:</span><br><span class="line">  17.366 ±(99.9%) 0.902 ops/s [Average]</span><br><span class="line">  (min, avg, max) = (14.948, 17.366, 19.462), stdev = 1.204</span><br><span class="line">  CI (99.9%): [16.465, 18.268] (assumes normal distribution)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Run complete. Total time: 00:25:27</span><br><span class="line"></span><br><span class="line">REMEMBER: The numbers below are just data. To gain reusable insights, you need to follow up on</span><br><span class="line">why the numbers are the way they are. Use profilers (see -prof, -lprof), design factorial</span><br><span class="line">experiments, perform baseline and negative tests that provide experimental control, make sure</span><br><span class="line">the benchmarking environment is safe on JVM/OS/HW level, ask for reviews from the domain experts.</span><br><span class="line">Do not assume the numbers tell you what you want them to tell.</span><br><span class="line"></span><br><span class="line">Benchmark    Mode  Cnt   Score   Error  Units</span><br><span class="line">Test.test1  thrpt   25  11.492 ± 0.864  ops/s</span><br><span class="line">Test.test2  thrpt   25  16.358 ± 1.549  ops/s</span><br><span class="line">Test.test3  thrpt   25  17.366 ± 0.902  ops/s</span><br></pre></td></tr></table></figure><p>其中<code>Fork：1 of 5</code>指的是JMH会Fork出一个新的虚拟机，来运行基准测试，目的是获得一个相对干净的运行环境，每个 Fork 包含了 5 个预热迭代（warmup iteration，如# Warmup Iteration   1: 14.169 ops/s）和5个测试迭代（measurement iteration，如Iteration   5: 18.772 ops/s）。</p><p>每次迭代后面的数据代表本次迭代的吞吐量，即每秒运行的次数（ops/s），也就是一次操作调用了一次测试方法。</p><p>好了，我们直接来看性能测试结果吧，如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Benchmark    Mode  Cnt   Score   Error  Units</span><br><span class="line">Test.test1  thrpt   25  11.492 ± 0.864  ops/s</span><br><span class="line">Test.test2  thrpt   25  16.358 ± 1.549  ops/s</span><br><span class="line">Test.test3  thrpt   25  17.366 ± 0.902  ops/s</span><br></pre></td></tr></table></figure><p>上面的输出便是本次基准测试的结果，主要关注Score和Error，Socre代表本次基准测试的平均吞吐量（每秒运行test*的次数），Error代表误差范围，所以。。。test1代表For循环串性执行，test2代表线程池并发执行，test3代表Fork/Join执行，结果很明显，Fork/Join每秒执行次数最多，线程池并发执行次之，For循环串性执行最少。</p><p>综合以上，我们可以小心翼翼地得出结论（怕被打。。），Fork/Join在计算密集型任务执行效率上是很好的，推荐大家使用。（完毕）</p><h2 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h2><p>目前先不分析，后面再写一遍文章。</p><p>参考：</p><ul><li><a href="http://gee.cs.oswego.edu/dl/papers/fj.pdf" target="_blank" rel="noopener">A Java Fork/Join Framework</a></li><li><a href="https://www.oracle.com/technetwork/cn/articles/java/fork-join-422606-zhs.html" target="_blank" rel="noopener">分解和合并：Java 也擅长轻松的并行编程！</a></li><li><a href="https://docs.oracle.com/javase/tutorial/essential/concurrency/forkjoin.html" target="_blank" rel="noopener">Fork/Join tutorial</a></li><li><a href="https://www.jianshu.com/p/f777abb7b251" target="_blank" rel="noopener">jdk1.8-ForkJoin框架剖析</a></li><li><a href="http://blog.dyngr.com/blog/2016/09/15/java-forkjoinpool-internals/" target="_blank" rel="noopener">Java 并发编程笔记：如何使用 ForkJoinPool 以及原理</a></li><li><a href="http://openjdk.java.net/projects/code-tools/jmh/" target="_blank" rel="noopener">Code Tools: jmh</a></li><li><a href="https://time.geekbang.org/column/article/40275" target="_blank" rel="noopener">基准测试框架JMH（上）</a></li><li><a href="https://time.geekbang.org/column/article/40281" target="_blank" rel="noopener">基准测试框架JMH（下）</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;熟悉Java Stream API的同学可能知道可以利用&lt;code&gt;parallelStream&lt;/code&gt;来实现并行操作，而Stream的并行操作依赖JDK1.7引入的Fork/Join框架，提供实现并行编程的一种方案。下面是Doug Lea对并行编程的描述：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;(recursively) splitting them into subtasks that are solved in&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;parallel, waiting for them to complete, and then composing&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;results.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Java" scheme="http://mingshan.me/categories/Java/"/>
    
      <category term="JUC" scheme="http://mingshan.me/categories/Java/JUC/"/>
    
    
      <category term="java" scheme="http://mingshan.me/tags/java/"/>
    
      <category term="JUC" scheme="http://mingshan.me/tags/JUC/"/>
    
  </entry>
  
  <entry>
    <title>IDEA中Maven配置JDK11进行编译</title>
    <link href="http://mingshan.me/2018/10/13/IDEA%E4%B8%ADMaven%E9%85%8D%E7%BD%AEJDK11%E8%BF%9B%E8%A1%8C%E7%BC%96%E8%AF%91/"/>
    <id>http://mingshan.me/2018/10/13/IDEA中Maven配置JDK11进行编译/</id>
    <published>2018-10-12T16:00:00.000Z</published>
    <updated>2018-10-13T08:13:12.036Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>前几天JDK11发布了不是，所以赶紧下载体验一番，我用的是IDEA编辑器(IntelliJ IDEA 2018.2.4 x64)，注意IDEA也要更新到最新版，用Maven编译的话需要进行相关配置，在此记录一下。</p><a id="more"></a><p>首先需要配置JDK的环境变量，配置好了显示如下：</p><p><img src="https://github.com/ZZULI-TECH/interview/blob/master/images/jdk11-version.png?raw=true" alt="image"></p><p>然后进入到IDEA中，配置项目使用的JDK版本，依次点击<code>File -&gt; Project Structure</code>，然后找到<code>Project SDK</code>选项，配置如下：</p><p><img src="https://github.com/ZZULI-TECH/interview/blob/master/images/jdk11-project-structure.png?raw=true" alt="image"></p><p>接下来配置Maven的JDK版本，点击<code>File -&gt; Settings -&gt; Build, Execution, Deployment -&gt; Build Tools -&gt; Maven</code>，然后选择<code>Runner</code>，配置Maven使用的JDK版本，配置页面如下：</p><p><img src="https://github.com/ZZULI-TECH/interview/blob/master/images/jdk11-maven-settings.png?raw=true" alt="image"></p><p>最后配置下maven的pom.xml文件，将目标编译版本改为JDK11，配置如下</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>11<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>11<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">finalName</span>&gt;</span>java11-tutorial<span class="tag">&lt;/<span class="name">finalName</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">source</span>&gt;</span>11<span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">target</span>&gt;</span>11<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><p>刷新maven项目，试着编译下，可以看到已经使用JDK11编译了：</p><p><img src="https://github.com/ZZULI-TECH/interview/blob/master/images/jdk11-build-output.png?raw=true" alt="image"></p><p>看下编译后的字节码的大小版本号，利用HexPad编辑器打开class文件，如下。可以看到minor_version为 0x0000, major_version为0x0037，而0x0037的十进制表示为55，即用jdk11编译的，准确无误。</p><p><img src="https://github.com/ZZULI-TECH/interview/blob/master/images/jdk11-class-version.png?raw=true" alt="image"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前几天JDK11发布了不是，所以赶紧下载体验一番，我用的是IDEA编辑器(IntelliJ IDEA 2018.2.4 x64)，注意IDEA也要更新到最新版，用Maven编译的话需要进行相关配置，在此记录一下。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://mingshan.me/categories/Java/"/>
    
    
      <category term="java" scheme="http://mingshan.me/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Callable&amp;Future及FutureTask实现分析(JDK11)</title>
    <link href="http://mingshan.me/2018/10/13/Callable&amp;Future%E5%8F%8AFutureTask%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90(JDK11)/"/>
    <id>http://mingshan.me/2018/10/13/Callable&amp;Future及FutureTask实现分析(JDK11)/</id>
    <published>2018-10-12T16:00:00.000Z</published>
    <updated>2018-10-22T14:05:22.233Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Callable"><a href="#Callable" class="headerlink" title="Callable"></a>Callable</h2><p>在Java中我们知道创建一个线程可以继承<code>Thread</code>类或者实现<code>Runnable</code>接口，JDK1.5之后在<code>java.util.concurrent</code>提供了<code>Callable</code>接口，该接口设计类似<code>Runnable</code>接口，不过<code>Callable</code>接口可以返回任务执行的结果，并且在执行任务过程中可能会抛出异常，而<code>Runnable</code>却不会。下面是<code>Callable</code>接口的定义：</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callable</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Computes a result, or throws an exception if unable to do so.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> computed result</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception if unable to compute a result</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">V <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Callable</code>接口中只定义了一个<code>call()</code>方法，该方法会返回一个计算结果，类型与传入的泛型一致。既然是接口，那么在哪里用到呢？下面是一个与<code>FutureTask</code>结合的例子，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallableTest</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException,</span></span><br><span class="line"><span class="function">        ExecutionException </span>&#123;</span><br><span class="line">        FutureTask&lt;String&gt; future = <span class="keyword">new</span> FutureTask&lt;&gt;(<span class="keyword">new</span> CallableTest());</span><br><span class="line">        <span class="keyword">new</span> Thread(future).start();</span><br><span class="line">        System.out.println(future.get());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以发现将 <code>Callable</code>的实现类传给<code>FutureTask</code>，然后利用线程来运行<code>FutureTask</code>，最终调用<code>get()</code>方法获取计算结果。</p><h2 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h2><p><code>FutureTask</code>是一个可取消的异步计算，该类提供了<code>Future</code>的基本实现，那么<code>Future</code>是怎么回事呢？<code>Future</code>接口提供了如下方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Future</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 试图取消此任务的执行。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> mayInterruptIfRunning)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果此任务在正常完成之前被取消，则返回true。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isCancelled</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果任务完成，返回true。完成可能是由于正常终止、异常或取消——在所有这些情况下，该方法将返回true。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isDone</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 等待计算完成，返回计算结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在给定的时间内等待计算完成，然后返回计算结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">V <span class="title">get</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Future</code>表示异步计算的结果，同时提供了用于检查计算是否完成、等待其完成以及检索计算结果的方法。下面是对这些方面的具体描述：</p><ul><li><code>cancel(boolean mayInterruptIfRunning)</code>：试图取消任务的执行。如果任务已经完成、已被取消或由于其他原因无法取消，则此尝试将失败。如果成功，并且在调用cancel时该任务尚未启动，则该任务永远不会运行。参数mayInterruptIfRunning表示是否允许取消正在执行却没有执行完毕的任务。在此方法返回后，对<code>isDone</code>的后续调用将始终返回<code>true</code>。如果该方法返回<code>true</code>，则对<code>isCancelled</code>的后续调用将始终返回<code>true</code>。</li><li><code>isCancelled</code> : 如果此任务在正常完成之前被取消，则返回true。</li><li><code>isDone</code>：如果任务完成，返回true。在正常终止、异常或取消情况下导致任务完成，该方法将返回true。</li><li><code>get</code>：等待计算完成，返回计算结果，期间会被阻塞。注意该方法会抛出异常，<ul><li>CancellationException - 如果计算被取消</li><li>ExecutionException - 如果在计算抛出异常</li><li>InterruptedException - 如果当前线程在等待时被中断</li></ul></li><li><code>get(long timeout, TimeUnit unit)</code>：在给定的时间内等待计算完成，然后返回计算结果。注意该方法也会抛出异常：<ul><li>CancellationException - 如果计算被取消</li><li>ExecutionException - 如果在计算抛出异常</li><li>InterruptedException - 如果当前线程在等待时被中断</li><li>TimeoutException - 等待超时</li></ul></li></ul><p>感觉<code>Future</code>的API设计的十分简洁明了，定义了对异步计算的常用操作，由于<code>Future</code>只是接口，刚才提到的<code>FutureTask</code>是JDK提供的一种实现，所以我们需要了解一下<code>Future</code>接口的方法是如何实现异步计算并拿到结果的。</p><h2 id="FutureTask"><a href="#FutureTask" class="headerlink" title="FutureTask"></a>FutureTask</h2><p><code>FutureTask</code>的类图如下所示，该类实现了<code>RunnableFuture</code><br>接口，<code>RunnableFuture</code>接口继承自<code>Runnable</code>和<code>Future</code>，所以该类既可以交给Thread去执行，又可以作为<code>Future</code>来获取计算结果。</p><p><img src="https://github.com/ZZULI-TECH/interview/blob/master/images/FutureTask_class.png?raw=true" alt="image"></p><h3 id="构造函数及state"><a href="#构造函数及state" class="headerlink" title="构造函数及state"></a>构造函数及state</h3><p>打开<code>FutureTask</code>类的源码，我们首先来看看其构造函数的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FutureTask</span><span class="params">(Callable&lt;V&gt; callable)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (callable == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">this</span>.callable = callable;</span><br><span class="line">    <span class="keyword">this</span>.state = NEW;       <span class="comment">// ensure visibility of callable</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FutureTask</span><span class="params">(Runnable runnable, V result)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.callable = Executors.callable(runnable, result);</span><br><span class="line">    <span class="keyword">this</span>.state = NEW;       <span class="comment">// ensure visibility of callable</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于第一个构造函数，传入Callable的实现类，将其赋给FutureTask成员变量<code>callable</code>，同时设置state为<code>NEW</code>，state字段用来保存FutureTask内部的任务执行状态，一共有7中状态，每种状态及其对应的值如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NEW          = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COMPLETING   = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NORMAL       = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EXCEPTIONAL  = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED    = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INTERRUPTING = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INTERRUPTED  = <span class="number">6</span>;</span><br></pre></td></tr></table></figure><p>注意state是用<code>volatile</code>修饰，保证其在线程之间的可见性。在源码注释中，我们可以发现state所代表状态转换如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NEW -&gt; COMPLETING -&gt; NORMAL</span><br><span class="line">NEW -&gt; COMPLETING -&gt; EXCEPTIONAL</span><br><span class="line">NEW -&gt; CANCELLED</span><br><span class="line">NEW -&gt; INTERRUPTING -&gt; INTERRUPTED</span><br></pre></td></tr></table></figure><p>用图表示如下：<br><img src="https://github.com/ZZULI-TECH/interview/blob/master/images/FutureTask_state_transitions.png?raw=true" alt="image"></p><p>从图中仿佛可以看出该类通过改变state的状态来反映最后计算的结果。</p><h3 id="run"><a href="#run" class="headerlink" title="run"></a>run</h3><p>在创建了一个FutureTask实例之后，接下来就是在另一个线程中执行此Task，无论是直接创建Thead还是通过线程池，执行的都是<code>run()</code>方法，该方法代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (state != NEW ||</span><br><span class="line">        !RUNNER.compareAndSet(<span class="keyword">this</span>, <span class="keyword">null</span>, Thread.currentThread()))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Callable&lt;V&gt; c = callable;</span><br><span class="line">        <span class="keyword">if</span> (c != <span class="keyword">null</span> &amp;&amp; state == NEW) &#123;</span><br><span class="line">            V result;</span><br><span class="line">            <span class="keyword">boolean</span> ran;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                result = c.call();</span><br><span class="line">                ran = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                result = <span class="keyword">null</span>;</span><br><span class="line">                ran = <span class="keyword">false</span>;</span><br><span class="line">                setException(ex);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (ran)</span><br><span class="line">                set(result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// runner must be non-null until state is settled to</span></span><br><span class="line">        <span class="comment">// prevent concurrent calls to run()</span></span><br><span class="line">        runner = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// state must be re-read after nulling runner to prevent</span></span><br><span class="line">        <span class="comment">// leaked interrupts</span></span><br><span class="line">        <span class="keyword">int</span> s = state;</span><br><span class="line">        <span class="keyword">if</span> (s &gt;= INTERRUPTING)</span><br><span class="line">            handlePossibleCancellationInterrupt(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在run方法中，首先会判断state是否等于<code>NEW</code>，如果不等于<code>NEW</code>，说明此任务已经被执行过，或者由于其他原因被取消了，直接返回；</p><p>接下来会利用CAS将该类<code>volatile</code>修饰的<code>runner</code>成员变量设置为当前线程，注意在设置之前<code>runner</code>必须为null，设置失败也直接返回。由于我看的版本是JDK11，所以这里的CAS操作用的是JDK9引入的<code>VarHandle</code>(方法句柄)，用来代替<code>UnSafe</code>类，详情参考：<a href="http://mingshan.me/2018/10/05/%E7%94%A8Variable%20Handles%E6%9D%A5%E6%9B%BF%E6%8D%A2Unsafe/">用Variable Handles来替换Unsafe</a>，在FutureTask类中实现代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// VarHandle mechanics</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> VarHandle STATE;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> VarHandle RUNNER;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> VarHandle WAITERS;</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        MethodHandles.Lookup l = MethodHandles.lookup();</span><br><span class="line">        STATE = l.findVarHandle(FutureTask.class, <span class="string">"state"</span>, <span class="keyword">int</span>.class);</span><br><span class="line">        RUNNER = l.findVarHandle(FutureTask.class, <span class="string">"runner"</span>, Thread.class);</span><br><span class="line">        WAITERS = l.findVarHandle(FutureTask.class, <span class="string">"waiters"</span>, WaitNode.class);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ReflectiveOperationException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ExceptionInInitializerError(e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Reduce the risk of rare disastrous classloading in first call to</span></span><br><span class="line">    <span class="comment">// LockSupport.park: https://bugs.openjdk.java.net/browse/JDK-8074773</span></span><br><span class="line">    Class&lt;?&gt; ensureLoaded = LockSupport.class;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>检测过<code>state</code>和<code>runner</code>后，接着会调用传入的callable的<code>call()</code>方法，执行任务。如果抛出异常，将结果设置为<code>null</code>，调用<code>setException()</code>方法保存异常信息，下面是代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">setException</span><span class="params">(Throwable t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (STATE.compareAndSet(<span class="keyword">this</span>, NEW, COMPLETING)) &#123;</span><br><span class="line">        outcome = t;</span><br><span class="line">        STATE.setRelease(<span class="keyword">this</span>, EXCEPTIONAL); <span class="comment">// final state</span></span><br><span class="line">        finishCompletion();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>setException</code>方法中，有以下流程：</p><ul><li>利用CAS操作将state状态由<code>NEW</code>改为<code>COMPLETING</code>，如果操作成功；</li><li>把异常原因保存在<code>outcome</code>字段中，<code>outcome</code>字段用来保存任务执行结果或者异常原因；</li><li>利用CAS把当前任务状态从<code>COMPLETING</code>变更为<code>EXCEPTIONAL</code>，可以参考上面转换的图；</li><li>调用<code>finishCompletion()</code>通知和移除等待线程</li></ul><p>如果没发生异常，任务执行结束，调用<code>set(result)</code>方法设置计算结果，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(V v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (STATE.compareAndSet(<span class="keyword">this</span>, NEW, COMPLETING)) &#123;</span><br><span class="line">        outcome = v;</span><br><span class="line">        STATE.setRelease(<span class="keyword">this</span>, NORMAL); <span class="comment">// final state</span></span><br><span class="line">        finishCompletion();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们发现<code>set()</code>方法实现流程和<code>setException()</code>真像，只不过是state状态变化的差异，流程如下：</p><ul><li>利用CAS操作将state状态由<code>NEW</code>改为<code>COMPLETING</code>，如果操作成功；</li><li>把计算结果保存在outcome字段中，outcome字段用来保存任务执行结果或者异常原因；</li><li>利用CAS把当前任务状态从<code>COMPLETING</code>变更为<code>NORMAL</code>，可以参考上面转换的图；</li><li>调用<code>finishCompletion()</code>通知和移除等待线程</li></ul><p>计算完后，无论是否发生异常，都要执行finally语句块的方法，首先将runner设置为<code>null</code>，释放值等待gc回收，同时判断state的状态是否为<code>INTERRUPTING</code>，如果任务被中断，执行中断处理。</p><p>看完了run方法的实现，总结来说，利用CAS根据任务的执行情况更改state的值，其他方法再根据state的值做出相应的处理。</p><h3 id="get"><a href="#get" class="headerlink" title="get"></a>get</h3><p>由于FutureTask是Future的一个实现，所以它提供了获取计算结果的<code>get()</code>方法，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> CancellationException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = state;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * state小于等于COMPLETING，表示计算任务还未完成，</span></span><br><span class="line"><span class="comment">     * 所以调用awaitDone方法，让当前线程等待</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (s &lt;= COMPLETING)</span><br><span class="line">        s = awaitDone(<span class="keyword">false</span>, <span class="number">0L</span>);</span><br><span class="line">    <span class="comment">// 返回计算结果或抛出异常</span></span><br><span class="line">    <span class="keyword">return</span> report(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>FutureTask运行在一个线程里来执行计算任务，由于Future设计的是异步计算模式，那么当然应该考虑其他线程获取计算的结果，从get方法看到，如果state的值如果小于等于<code>COMPLETING</code>，说明计算任务还没完成，那么获取计算结果的线程必须等待，也就是被阻塞，具体的实现在<code>awaitDone</code>方法里，该方法有两个参数，第一个参数为是否有超时限制timed，第二个为等待时间nanos，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">awaitDone</span><span class="params">(<span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// The code below is very delicate, to achieve these goals:</span></span><br><span class="line">    <span class="comment">// - call nanoTime exactly once for each call to park</span></span><br><span class="line">    <span class="comment">// - if nanos &lt;= 0L, return promptly without allocation or nanoTime</span></span><br><span class="line">    <span class="comment">// - if nanos == Long.MIN_VALUE, don't underflow</span></span><br><span class="line">    <span class="comment">// - if nanos == Long.MAX_VALUE, and nanoTime is non-monotonic</span></span><br><span class="line">    <span class="comment">//   and we suffer a spurious wakeup, we will do no worse than</span></span><br><span class="line">    <span class="comment">//   to park-spin for a while</span></span><br><span class="line">    <span class="keyword">long</span> startTime = <span class="number">0L</span>;    <span class="comment">// Special value 0L means not yet parked</span></span><br><span class="line">    WaitNode q = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">boolean</span> queued = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> s = state;</span><br><span class="line">        <span class="comment">// 计算已完成，直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (s &gt; COMPLETING) &#123;</span><br><span class="line">            <span class="keyword">if</span> (q != <span class="keyword">null</span>)</span><br><span class="line">                q.thread = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;<span class="comment">// 正在计算，让出时间片等待计算完成</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s == COMPLETING)</span><br><span class="line">            <span class="comment">// We may have already promised (via isDone) that we are done</span></span><br><span class="line">            <span class="comment">// so never return empty-handed or throw InterruptedException</span></span><br><span class="line">            Thread.yield();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">            <span class="comment">//  当前线程被中断（中断标志位为true），</span></span><br><span class="line">            <span class="comment">//  那么从列表中移除节点q，并抛出InterruptedException异常</span></span><br><span class="line">            removeWaiter(q);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125; <span class="comment">// 判断当前线程包装的等待节点是否为空</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (q == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果设置等待，但等待时间为0，直接返回</span></span><br><span class="line">            <span class="keyword">if</span> (timed &amp;&amp; nanos &lt;= <span class="number">0L</span>)</span><br><span class="line">                <span class="keyword">return</span> s;</span><br><span class="line">            <span class="comment">// 新建等待节点</span></span><br><span class="line">            q = <span class="keyword">new</span> WaitNode();</span><br><span class="line">        &#125;<span class="comment">// 判断是否入队</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!queued)</span><br><span class="line">            <span class="comment">//未入队时，使用CAS将新节点添加到链表中，如果添加失败，那么queued为false</span></span><br><span class="line">            queued = WAITERS.weakCompareAndSet(<span class="keyword">this</span>, q.next = waiters, q);</span><br><span class="line">        <span class="comment">// 判断是否设置超时</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (timed) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> parkNanos;</span><br><span class="line">            <span class="comment">// 第一次执行，初始化 startTime</span></span><br><span class="line">            <span class="keyword">if</span> (startTime == <span class="number">0L</span>) &#123; <span class="comment">// first time</span></span><br><span class="line">                startTime = System.nanoTime();</span><br><span class="line">                <span class="keyword">if</span> (startTime == <span class="number">0L</span>)</span><br><span class="line">                    startTime = <span class="number">1L</span>;</span><br><span class="line">                parkNanos = nanos;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 计算当前已用时间</span></span><br><span class="line">                <span class="keyword">long</span> elapsed = System.nanoTime() - startTime;</span><br><span class="line">                <span class="comment">// 如果当前已用时间大于设置的超时时间，移除队列中的结点，直接返回</span></span><br><span class="line">                <span class="keyword">if</span> (elapsed &gt;= nanos) &#123;</span><br><span class="line">                    removeWaiter(q);</span><br><span class="line">                    <span class="keyword">return</span> state;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 计算剩余时间</span></span><br><span class="line">                parkNanos = nanos - elapsed;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// nanoTime may be slow; recheck before parking</span></span><br><span class="line">            <span class="comment">// 挂起当前线程，让当前线程等待nanos时间</span></span><br><span class="line">            <span class="keyword">if</span> (state &lt; COMPLETING)</span><br><span class="line">                LockSupport.parkNanos(<span class="keyword">this</span>, parkNanos);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">// 未设置等待时间，那就等着吧</span></span><br><span class="line">            LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在FutureTask类中有一个成员变量<code>waiters</code>，声明如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Treiber stack of waiting threads */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> WaitNode waiters;</span><br></pre></td></tr></table></figure><p><code>WaitNode</code>是一个静态内部类，数据结构为单链表，用来记录等待的线程，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Simple linked list nodes to record waiting threads in a Treiber</span></span><br><span class="line"><span class="comment"> * stack.  See other classes such as Phaser and SynchronousQueue</span></span><br><span class="line"><span class="comment"> * for more detailed explanation.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">WaitNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">volatile</span> Thread thread;</span><br><span class="line">    <span class="keyword">volatile</span> WaitNode next;</span><br><span class="line">    WaitNode() &#123; thread = Thread.currentThread(); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的代码来看，在<code>awaitDone</code>方法内部存在着一个死循环，死循环内部流程如下：</p><ol><li>首先判断state的值，<ul><li>如果值大于<code>COMPLETING</code>，代表计算已完成（包括抛出异常等），直接返回；</li><li>如果值等于<code>COMPLETING</code>，代表正在执行计算，调用<code>Thread.yield()</code>让出时间片等待计算完成</li></ul></li><li>如果当前线程被中断（中断标志位为true），那么从列表中移除节点q，并抛出<code>InterruptedException</code>；</li><li>如果当前线程包装的等待节点为空，判断是否设置等待，并且等待时间为0，直接返回，否则创建等待节点；</li><li>如果没有入队，使用CAS将新节点添加到链表中，如果添加失败，那么queued为false</li><li>如果设置超时，判断当前计算任务是否在超时时间内，<ul><li>如果不在，移除队列中的结点，直接返回</li><li>如果在，计算剩余时间，挂起当前线程，让当前线程等待剩下的时间</li></ul></li><li>未设置等待时间，直接进行线程挂起操作，线程状态变为等待。</li></ol><p>当线程被解除挂起，或计算已经完成后，在<code>get</code>方法中将会调用<code>report</code>方法返回结果，其实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns result or throws exception for completed task.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> s completed state value</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="function"><span class="keyword">private</span> V <span class="title">report</span><span class="params">(<span class="keyword">int</span> s)</span> <span class="keyword">throws</span> ExecutionException </span>&#123;</span><br><span class="line">    Object x = outcome;</span><br><span class="line">    <span class="keyword">if</span> (s == NORMAL)</span><br><span class="line">        <span class="keyword">return</span> (V)x;</span><br><span class="line">    <span class="keyword">if</span> (s &gt;= CANCELLED)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> CancellationException();</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ExecutionException((Throwable)x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>如果state等于<code>NORMAL</code>，代表计算正常结束，返回结果；</li><li>如果state等于<code>CANCELLED</code>，代表计算被取消，抛出<code>CancellationException</code>；</li><li>如果计算以异常结束，即状态是<code>EXCEPTIONAL</code>，那么抛出<code>ExecutionException</code>。</li></ol><h3 id="finishCompletion"><a href="#finishCompletion" class="headerlink" title="finishCompletion"></a>finishCompletion</h3><p>在<code>run</code>方法中调用<code>set</code>和<code>setException</code>时最后一步是执行<code>finishCompletion</code>方法，那么这个方法是来干什么的呢？我们来看看它的实现吧：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Removes and signals all waiting threads, invokes done(), and</span></span><br><span class="line"><span class="comment"> * nulls out callable.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">finishCompletion</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert state &gt; COMPLETING;</span></span><br><span class="line">    <span class="keyword">for</span> (WaitNode q; (q = waiters) != <span class="keyword">null</span>;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (WAITERS.weakCompareAndSet(<span class="keyword">this</span>, q, <span class="keyword">null</span>)) &#123;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                Thread t = q.thread;</span><br><span class="line">                <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    q.thread = <span class="keyword">null</span>;</span><br><span class="line">                    LockSupport.unpark(t);</span><br><span class="line">                &#125;</span><br><span class="line">                WaitNode next = q.next;</span><br><span class="line">                <span class="keyword">if</span> (next == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                q.next = <span class="keyword">null</span>; <span class="comment">// unlink to help gc</span></span><br><span class="line">                q = next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    done();</span><br><span class="line"></span><br><span class="line">    callable = <span class="keyword">null</span>;        <span class="comment">// to reduce footprint</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>刚才我们看<code>get</code>方法的实现时，发现有一个<code>WaitNode</code>的单链表结构，里面存储着等待着的线程，所以在计算完成时，需要唤醒那些还在等待着的线程，毕竟计算任务都做完了（异常也算结束），总不能让那些阻塞的线程干等着吧，所以在<code>finishCompletion</code>方法中就遍历单链表，利用CAS将FutureTask中的waiters设置为<code>null</code>，调用<code>LockSupport.unpark</code>唤醒线程，当线程被释放后，那么在awaitDone的死循环中就会进入下一个循环，由于状态已经变成了<code>NORMAL</code>或者<code>EXCEPTIONAL</code>，将会直接跳出循环。</p><p>当所有等待线程都唤醒后，直接调用<code>done</code>方法，<code>done</code>方法是个<code>protected</code>修饰的方法，FutureTask没有做相关实现，所以如果在计算完成后需要特殊处理，子类可以重写<code>done</code>方法。</p><h3 id="cancel"><a href="#cancel" class="headerlink" title="cancel"></a>cancel</h3><p>从Future接口的描述来看，它提供了<code>cancel</code>方法来取消正在执行的任务，FutureTask实现了<code>cancel</code>方法，我们来看看它的代码吧：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> mayInterruptIfRunning)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!(state == NEW &amp;&amp; STATE.compareAndSet</span><br><span class="line">          (<span class="keyword">this</span>, NEW, mayInterruptIfRunning ? INTERRUPTING : CANCELLED)))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;    <span class="comment">// in case call to interrupt throws exception</span></span><br><span class="line">        <span class="keyword">if</span> (mayInterruptIfRunning) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread t = runner;</span><br><span class="line">                <span class="keyword">if</span> (t != <span class="keyword">null</span>)</span><br><span class="line">                    t.interrupt();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123; <span class="comment">// final state</span></span><br><span class="line">                STATE.setRelease(<span class="keyword">this</span>, INTERRUPTED);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        finishCompletion();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参数<code>mayInterruptIfRunning</code>指明是否应该中断正在运行的任务，</p><ul><li>如果参数为false，代表不需要中断，那么state的转换过程由<code>NEW-&gt;CANCELLED</code></li><li>如果参数为true，代表需要中断，那么state的转换过程将为<code>NEW-&gt;INTERRPUTING-&gt;INTERRUPTED</code>，并给当前线程设中断标志。</li></ul><p>无论是否中断，最终都会调用<code>finishCompletion()</code>方法来释放等待线程。</p><p>参考：</p><ul><li><a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/concurrent/Callable.html" target="_blank" rel="noopener">Callable DOC</a></li><li><a href="http://www.importnew.com/25286.html" target="_blank" rel="noopener">深入学习 FutureTask</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Callable&quot;&gt;&lt;a href=&quot;#Callable&quot; class=&quot;headerlink&quot; title=&quot;Callable&quot;&gt;&lt;/a&gt;Callable&lt;/h2&gt;&lt;p&gt;在Java中我们知道创建一个线程可以继承&lt;code&gt;Thread&lt;/code&gt;类或者实现&lt;code&gt;Runnable&lt;/code&gt;接口，JDK1.5之后在&lt;code&gt;java.util.concurrent&lt;/code&gt;提供了&lt;code&gt;Callable&lt;/code&gt;接口，该接口设计类似&lt;code&gt;Runnable&lt;/code&gt;接口，不过&lt;code&gt;Callable&lt;/code&gt;接口可以返回任务执行的结果，并且在执行任务过程中可能会抛出异常，而&lt;code&gt;Runnable&lt;/code&gt;却不会。下面是&lt;code&gt;Callable&lt;/code&gt;接口的定义：&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://mingshan.me/categories/Java/"/>
    
      <category term="JUC" scheme="http://mingshan.me/categories/Java/JUC/"/>
    
    
      <category term="java" scheme="http://mingshan.me/tags/java/"/>
    
      <category term="JUC" scheme="http://mingshan.me/tags/JUC/"/>
    
  </entry>
  
  <entry>
    <title>我读</title>
    <link href="http://mingshan.me/2018/10/07/%E6%88%91%E8%AF%BB/"/>
    <id>http://mingshan.me/2018/10/07/我读/</id>
    <published>2018-10-06T16:00:00.000Z</published>
    <updated>2018-12-02T10:39:19.683Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>以前喜欢买书来看，有空捧着一本书静静的读着，这种感觉仿佛时间都停止了，现在参加了工作，时间变得相对少些，所以看电子书的频率高些（微信读书和Kindle），因为电子书看着方便，但对眼睛有伤害，看时间长了会眼睛疲劳，不过能过看书的瘾，也挺好^_^</p><a id="more"></a><p>下面是我近几年来看过和正在看的亦准备看的书籍列表，不过有些已经忘记了。这些书藏匿着我旧日的时光，看到这些书，仿佛看到了过去的自己，为了避免以后忘却那些美好的旧日时光，亦是不对过去的背弃，记录下来吧。。</p><p>一个好的作品藏着作者的大悲大痛，大彻大悟，即使是最平淡的文字，也能体会到作者对生活、人性的思考，世上的一切本就平凡真切，或得道弃俗，或坠入俗世，也是我们的世界啊。</p><p>书富如入海，百货皆有。人之精力，不能兼收尽取，但得春所欲求者尔。故愿学者每次作一意求之。 —— 苏轼 《东坡文集事略》</p><p><strong>历史类：</strong></p><p>当年明月，《明朝那些事》<br>卢志丹，《毛泽东读二十四史》<br>高晓松，《鱼羊野史（全集）》（未读完）<br>王晓磊，《卑鄙的圣人：曹操（全集）》<br>洪钊，《明朝十讲》<br>张鸣，《大历史的边角料》（未读完）<br>吕思勉，《三国史话》<br>黄仁宇，《万历十五年（精装版）》<br>朱东润，《张居正大传》</p><p><strong>古代哲学</strong></p><p>孔子，《论语》<br>李耳，《道德经》<br>庄周，《庄子》<br>王阳明，《传习录》</p><p><strong>古代史书（未读完）</strong></p><p>司马迁，《史记》<br>陈寿，《三国志》<br>司马光，《资治通鉴》<br>张廷玉，《明史》</p><p><strong>明清书籍</strong></p><p>金圣叹，《贯华堂选批唐才子诗》（在读）<br>刘鹗，《老残游记》<br>罗贯中，《三国演义》<br>袁枚，《子不语》<br>袁了凡，《了凡四训》<br>李淳风和袁天罡，《推背图（金圣叹批）》<br>吴趼人，《二十年目睹之怪现状》<br>曾朴，《孽海花》<br>李伯元，《官场现形记》（在读）</p><p><strong>当代小说</strong></p><p>路遥，《平凡的世界》<br>路遥，《人生》<br>贾平凹，《商州》<br>贾平凹，《自在独行》（未读完）<br>慕容雪村，《多数人死于贪婪》<br>慕容雪村，《成都，今夜请将我遗忘》<br>慕容雪村，《天堂在左，深圳向右》<br>慕容雪村，《原谅我红尘颠倒》<br>刘同，《我在未来等你》<br>刘震云，《故乡天地黄花》<br>刘震云，《我叫刘跃进》<br>刘震云，《一句顶一万句》<br>刘震云，《故乡相处流传》<br>余华，《许三观卖血记》（未读完）</p><p><strong>随笔散文</strong></p><p>路遥，《早晨从中午开始》<br>刘瑜，《送你一颗子弹》<br>黄仁宇，《地北天南叙古今（精装版）》（在读）<br>慕容雪村，《中国，少了一味药》<br>慕容雪村，《慕容雪村随笔集》<br>梁晓声，《中国人的日常》<br>王蒙，《一辈子的活法：王蒙的人生历练》（在读）<br>廖一梅，《悲观主义的花朵》（在读）<br>梁文道，《我读 梁文道的开卷八分钟》（在读）</p><p><strong>科幻</strong></p><p>刘慈欣，《三体》</p><p><strong>外国文学</strong></p><p>培根，《培根随笔集》<br>圣埃克苏佩里，《小王子》（在读）</p><p><strong>技术书籍</strong></p><p>Joshua Bloch，《Effective Java 中文 第二版》<br>周志明，《深入理解Java虚拟机:JVM高级特性与最佳实践（第二版）》<br>刘欣，《码农翻身》<br>秦小波，《设计模式之禅》<br>啊哈磊，《啊哈！算法》<br>翟陆续 薛宾田，《Java并发编程之美》</p><blockquote><p>—— 更新于2018/12/02</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;以前喜欢买书来看，有空捧着一本书静静的读着，这种感觉仿佛时间都停止了，现在参加了工作，时间变得相对少些，所以看电子书的频率高些（微信读书和Kindle），因为电子书看着方便，但对眼睛有伤害，看时间长了会眼睛疲劳，不过能过看书的瘾，也挺好^_^&lt;/p&gt;
    
    </summary>
    
      <category term="书籍" scheme="http://mingshan.me/categories/%E4%B9%A6%E7%B1%8D/"/>
    
    
  </entry>
  
</feed>
