<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>Apache ServiceComb Saga分布式事务框架体验</title>
      <link href="/2018/11/07/Apache%20ServiceComb%20Saga%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E6%A1%86%E6%9E%B6%E4%BD%93%E9%AA%8C/"/>
      <url>/2018/11/07/Apache%20ServiceComb%20Saga%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E6%A1%86%E6%9E%B6%E4%BD%93%E9%AA%8C/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Apache ServiceComb (incubating) Saga 是一个微服务应用的数据最终一致性解决方案。</p><a id="more"></a><p>Saga Pack 架构是由 alpha 和 omega组成，其中：</p><ul><li>alpha充当协调者的角色，主要负责对事务进行管理和协调。</li><li>omega是微服务中内嵌的一个agent，负责对网络请求进行拦截并向alpha上报事务事件。</li></ul><p>下图展示了alpha, omega以及微服务三者的关系： </p><p><img src="https://github.com/ZZULI-TECH/interview/blob/master/images/pack.png?raw=true" alt="image"></p><p>看了它的架构方案，我们需要用例子来理解它的机制和使用方式，Saga为我们提供了一系列Demo，包含与Spring、Dubbo等结合使用的例子，下面就用与Spring结合的例子</p><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>首先我们需要从<a href="https://github.com/apache/incubator-servicecomb-saga" target="_blank" rel="noopener">github 仓库</a>克隆源代码到本地，然后在项目根目录执行如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn clean package -DskipTests -Pdemo</span><br></pre></td></tr></table></figure><p>该命令会编译源代码，跳过单元测试，并且编译demo项目。</p><h2 id="运行Alpha-Server"><a href="#运行Alpha-Server" class="headerlink" title="运行Alpha Server"></a>运行Alpha Server</h2><p>从上面的架构图看出，alpha充当协调者的角色，所以我们需要先运行Alpha Server，Alpha Server是需要数据库支持，默认用的PostgreSQL数据库，我们在项目中使用MySQL较多，所以需要切换为MySQL数据库。</p><p>先在<code>alpha/alpha-server/pom.xml</code> 文件中添加MySQL数据库驱动依赖，然后重新编译</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>接下来创建数据库<code>saga</code>和表，数据库Schema<a href="https://github.com/apache/incubator-servicecomb-saga/blob/master/alpha/alpha-server/src/main/resources/schema-mysql.sql" target="_blank" rel="noopener">在这里</a>，首先执行该数据库脚本，创建相应的表<br>，包括<code>TxEvent</code>、<code>Command</code>、<code>TxTimeout</code>、<code>tcc_global_tx_event</code>、<code>tcc_participate_event</code>、<code>tcc_tx_event</code>这几张表。</p><p>接下来运行Alpha Server，进入到<code>alpha\alpha-server\target\saga</code>文件夹，运行如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Dspring.profiles.active=mysql -D&quot;spring.datasource.url=jdbc:mysql://127.0.0.1:3306/saga?useSSL=false&amp;allowPublicKeyRetrieval=true&quot; -D&quot;spring.datasource.username=root&quot; -D&quot;spring.datasource.password=admin&quot; -jar alpha-server-0.3.0-SNAPSHOT-exec.jar</span><br></pre></td></tr></table></figure><p>该命令指明了数据库的<code>url</code>、<code>username</code>、<code>password</code>, 同时指定spring的profile为mysql，注意<code>alpha-server-0.3.0-SNAPSHOT-exec.jar</code> 该jar包为本目录下的jar包。</p><p> 默认情况下，8080端口用于处理omega处发起的gRPC的请求，而8090端口用于处理查询存储在alpha处的事件信息。</p><h2 id="运行Demo"><a href="#运行Demo" class="headerlink" title="运行Demo"></a>运行Demo</h2><p>由于上面我们已经对demo项目进行了编译，下面我们就可以来执行了，demo分为三个项目，booking、car、hotel，流程是通过booking可以预定车和房间，分别调用car和hotel两个服务，来模拟分布式事务的流程。</p><p>下面启动hotel服务，这里做个控制，不允许预定超过二个房间，否则报错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Dserver.port=8081 -Dalpha.cluster.address=127.0.0.1:8080 -jar hotel-0.3.0-SNAPSHOT-exec.jar</span><br></pre></td></tr></table></figure><p>然后启动car服务：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Dserver.port=8082 -Dalpha.cluster.address=127.0.0.1:8080 -jar car-0.3.0-SNAPSHOT-exec.jar</span><br></pre></td></tr></table></figure><p>最后启动booking服务：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Dserver.port=8083 -Dalpha.cluster.address=127.0.0.1:8080 -Dcar.service.address=127.0.0.1:8082 -Dhotel.service.address=127.0.0.1:8081 -jar booking-0.3.0-SNAPSHOT-exec.jar</span><br></pre></td></tr></table></figure><p>三个服务启动后，首先预定2个车和2个房间，用curl或者postman发送请求：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -X POST http://127.0.0.1:8083/booking/test/2/2</span><br></pre></td></tr></table></figure><p>结果会预定成功，分别查询car 和 hotel 均会返回预定成功：</p><p>[hotel]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">curl -X http://127.0.0.1:8081/bookings</span><br><span class="line"></span><br><span class="line">[&#123;&quot;name&quot;:&quot;test&quot;,&quot;amount&quot;:2,&quot;confirmed&quot;:true,&quot;cancelled&quot;:false&#125;]</span><br></pre></td></tr></table></figure><p>[car]<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">curl -X http://127.0.0.1:8082/bookings</span><br><span class="line"></span><br><span class="line">[&#123;&quot;name&quot;:&quot;test&quot;,&quot;amount&quot;:2,&quot;confirmed&quot;:true,&quot;cancelled&quot;:false&#125;</span><br></pre></td></tr></table></figure></p><p>接下来要预定2个车和3个房间，此时会预定失败</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -X POST http://127.0.0.1:8083/booking/test/3/2</span><br></pre></td></tr></table></figure><p>分别查询car 和 hotel ，如下所示：</p><p>[hotel]<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">curl -X http://127.0.0.1:8081/bookings</span><br><span class="line"></span><br><span class="line">[&#123;&quot;name&quot;:&quot;test&quot;,&quot;amount&quot;:2,&quot;confirmed&quot;:true,&quot;cancelled&quot;:false&#125;]</span><br></pre></td></tr></table></figure></p><p>[car]<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">curl -X http://127.0.0.1:8082/bookings</span><br><span class="line"></span><br><span class="line">[&#123;&quot;name&quot;:&quot;test&quot;,&quot;amount&quot;:2,&quot;confirmed&quot;:true,&quot;cancelled&quot;:false&#125;,</span><br><span class="line">&#123;&quot;name&quot;:&quot;test&quot;,&quot;amount&quot;:2,&quot;confirmed&quot;:false,&quot;cancelled&quot;:true&#125;]</span><br></pre></td></tr></table></figure></p><p>我们知道预定三个房间会失败报错，这是预定的car就要进行回滚，不能预定成功，因为这是在一个预定事务里，所以查询car的预定情况，第二条记录就会显示<strong>cancel:true</strong></p><p>下图是上面操作的结果界面：</p><p><img src="https://github.com/ZZULI-TECH/interview/blob/master/images/saga-demo-result.png?raw=true" alt="image"></p><h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><ol><li>在应用入口添加 <code>@EnableOmega</code> 的注解来初始化omega的配置并与alpha建立连接。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableOmega</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    SpringApplication.run(Application.class, args);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>在全局事务的起点添加 <code>@SagaStart</code> 的注解。这里是在booking项目的预定方法加此注解，该方法包括预定车和房间。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SagaStart</span></span><br><span class="line"><span class="meta">@PostMapping</span>(<span class="string">"/booking/&#123;name&#125;/&#123;rooms&#125;/&#123;cars&#125;"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">order</span><span class="params">(@PathVariable String name,  @PathVariable Integer rooms, @PathVariable Integer cars)</span> </span>&#123;</span><br><span class="line">    template.postForEntity(</span><br><span class="line">        carServiceUrl + <span class="string">"/order/&#123;name&#125;/&#123;cars&#125;"</span>,</span><br><span class="line">        <span class="keyword">null</span>, String.class, name, cars);</span><br><span class="line">    </span><br><span class="line">    postCarBooking();</span><br><span class="line">    </span><br><span class="line">    template.postForEntity(</span><br><span class="line">        hotelServiceUrl + <span class="string">"/order/&#123;name&#125;/&#123;rooms&#125;"</span>,</span><br><span class="line">        <span class="keyword">null</span>, String.class, name, rooms);</span><br><span class="line">    </span><br><span class="line">    postBooking();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> name + <span class="string">" booking "</span> + rooms + <span class="string">" rooms and "</span> + cars + <span class="string">" cars OK"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>在子事务处添加 <code>@Compensable</code> 的注解并指明其对应的补偿方法。注意这里两个子事务都要加。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Compensable</span>(compensationMethod = <span class="string">"cancel"</span>)</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">order</span><span class="params">(CarBooking booking)</span> </span>&#123;</span><br><span class="line">    booking.confirm();</span><br><span class="line">    bookings.put(booking.getId(), booking);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cancel</span><span class="params">(CarBooking booking)</span> </span>&#123;</span><br><span class="line">    Integer id = booking.getId();</span><br><span class="line">    <span class="keyword">if</span> (bookings.containsKey(id)) &#123;</span><br><span class="line">      bookings.get(id).cancel();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意:</strong> 实现的服务和补偿必须满足幂等的条件。</p><p><strong>注意:</strong> 默认情况下，超时设置需要显式声明才生效。</p><p><strong>注意:</strong> 若全局事务起点与子事务起点重合，需同时声明 <code>@SagaStart</code> 和 <code>@Compensable</code> 的注解。</p><h2 id="设计思路和运行机制"><a href="#设计思路和运行机制" class="headerlink" title="设计思路和运行机制"></a>设计思路和运行机制</h2><p>后面再深入研究(￣▽￣)~*</p><p>参考：</p><ul><li><a href="https://www.cnblogs.com/savorboard/p/distributed-system-transaction-consistency.html" target="_blank" rel="noopener">聊聊分布式事务，再说说解决方案</a></li><li><a href="https://docs.servicecomb.io/saga/en_US/index.html" target="_blank" rel="noopener">Saga DOC</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 分布式事务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式事务 </tag>
            
            <tag> Saga </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>分布式事务解决方案</title>
      <link href="/2018/11/06/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
      <url>/2018/11/06/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>分布式事务目前有以下几种解决方案：</p><a id="more"></a><p><strong>一. 两阶段提交（2PC）</strong></p><p>【强一致性】</p><p>2PC又叫做XA Transactions，XA是一个两阶段提交协议，该协议分为下面两个阶段：</p><ul><li>第一阶段：事务协调器要求每个涉及到事务的数据库预提交(precommit)此操作，并反映是否可以提交.</li><li>第二阶段：事务协调器要求每个数据库提交数据。 </li></ul><p>其中，如果有任何一个数据库否决此次提交，那么所有数据库都会被要求回滚它们在此事务中的那部分信息。</p><p><strong>二、补偿事务（TCC）</strong></p><p>【最终一致性】</p><p>TCC 其实就是采用的补偿机制，其核心思想是：针对每个操作，都要注册一个与其对应的确认和补偿（撤销）操作。它分为三个阶段：</p><ul><li>Try 阶段主要是对业务系统做检测及资源预留</li><li>Confirm 阶段主要是对业务系统做确认提交，Try阶段执行成功并开始执行 Confirm阶段时，默认 Confirm阶段是不会出错的。即：只要Try成功，Confirm一定成功。</li><li>Cancel 阶段主要是在业务执行错误，需要回滚的状态下执行的业务取消，预留资源释放。</li></ul><p>注意Confirm 和 Cancel要保证操作的幂等性。</p><p><strong>三、本地消息表（异步确保）</strong></p><p>【最终一致性】</p><p>将分布式事务拆分成本地事务进行处理</p><p>消息生产方，需要额外建一个消息表，并记录消息发送状态。消息表和业务数据要在一个事务里提交，也就是说他们要在一个数据库里面。然后消息会经过MQ发送到消息的消费方。如果消息发送失败，会进行重试发送。</p><p>消息消费方，需要处理这个消息，并完成自己的业务逻辑。此时如果本地事务处理成功，表明已经处理成功了，如果处理失败，那么就会重试执行。如果是业务上面的失败，可以给生产方发送一个业务补偿消息，通知生产方进行回滚等操作。</p><p>生产方和消费方定时扫描本地消息表，把还没处理完成的消息或者失败的消息再发送一遍。如果有靠谱的自动对账补账逻辑，这种方案还是非常实用的。</p><p><strong>四、Sagas 事务模型</strong></p><p>Saga事务模型又叫做长时间运行的事务（Long-running-transaction）</p><p><img src="https://github.com/ZZULI-TECH/interview/blob/master/images/saga.png?raw=true" alt="image"></p><p><a href="https://www.cs.cornell.edu/andru/cs711/2002fa/reading/sagas.pdf" target="_blank" rel="noopener">论文</a></p><p>参考：</p><ul><li><a href="https://www.cnblogs.com/savorboard/p/distributed-system-transaction-consistency.html" target="_blank" rel="noopener">聊聊分布式事务，再说说解决方案</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 分布式事务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式事务 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>循环队列结构分析</title>
      <link href="/2018/11/01/%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90/"/>
      <url>/2018/11/01/%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="ArrayQueue假溢出"><a href="#ArrayQueue假溢出" class="headerlink" title="ArrayQueue假溢出"></a>ArrayQueue假溢出</h2><p>我们在利用数组实现队列的时候，发现数组队列会出现假溢出问题，即队列还没有满，但不能再往队列中放入元素了，如下图所示：</p><a id="more"></a><p><img src="https://github.com/ZZULI-TECH/interview/blob/master/images/ArrayQueue_false_overflow.png?raw=true" alt="image"></p><p>在数据进行出队的时候，每一个元素出队，指向队列头元素的head就会向后移动，导致head之前的元素被“遗忘”了，无法再次利用，出队的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isEmpty()) &#123;</span><br><span class="line">        E value = (E) elements[head];</span><br><span class="line">        <span class="comment">// 移除头部元素</span></span><br><span class="line">        elements[head] = <span class="keyword">null</span>;</span><br><span class="line">        head++;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，我们可以对数组队列进行一些优化。在插入元素的时候，我们检查一下tail是否已经指向了队尾，如果指向了队尾并且head不等于0的情况下，说明发生了假溢出，需要进行元素迁移工作，将head和tail之间的元素整体移动到 0 到 <code>tail - head</code> 的位置，这样就可以避免假溢出问题了（还是上面的图），实现代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 由于数组队列存在假溢出问题，所谓要进行数据搬运</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(e);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (tail == capacity) &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 证明队列是满的</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Queue full"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果head 不等于0，证明head之前的空间是空着的，所以需要进行数据搬运</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head; i &lt; tail; i++) &#123;</span><br><span class="line">            elements[i - head] = elements[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 搬运完更新head 和 tail</span></span><br><span class="line">        head = <span class="number">0</span>;</span><br><span class="line">        tail -= head; <span class="comment">// tail = tail - head</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 正常操作</span></span><br><span class="line">    elements[tail++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h2><p>上面我们知道了假溢出问题，并且找到了解决方式，但在添加元素的时候可能会出现数据移动工作，并不是十分优雅，有没有一种比较好的方式去处理这个问题呢？既不出现假溢出问题，又不移动数据，还…（想的太多），答案是有的。仔细想想如果我们将数组队列收尾相连会出现什么情况，哈哈，根本不用管假溢出问题了，添加元素的时候直接往后移动tail（tail 加 1）就完事了，是不是很酷？大致结构如下图所示：</p><p><img src="https://github.com/ZZULI-TECH/interview/blob/master/images/CircularQueue.png?raw=true" alt="image"></p><h3 id="空和满队列判断"><a href="#空和满队列判断" class="headerlink" title="空和满队列判断"></a>空和满队列判断</h3><p>看完描述和图示，我们可能会有疑问，head 和 tail的位置一直是不固定的，那么该如何判断队列是否满的呢？</p><p>当<strong>循环队列为空</strong>时，很明显head 和 tail 是相等的，如下图所示：</p><p><img src="https://github.com/ZZULI-TECH/interview/blob/master/images/CircularQueue_empty.png?raw=true" alt="image"></p><p>那么如何判断队列是否满了呢？ 由于我们用head与tail相等来判断队列为空的情况，所以队列满时，必须有一个空位来由我们的tail指向，如下图所示：</p><p><img src="https://github.com/ZZULI-TECH/interview/blob/master/images/CircularQueue_full.png?raw=true" alt="image"></p><p>上图只是一种情况，总结来说，队头指针head在队尾指针tail的下一位置时，队满。由于是环形结构，所以需要进行求余运算，例如<code>（5 + 1） % 8 = 3</code>，总结规律下来，就是 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(head + 1） % capacity = tail</span><br></pre></td></tr></table></figure><p>由于这种机制的存在，当队列满时，总有一个位置是被浪费掉的。</p><p><strong>构造函数和成员变量</strong></p><p>循环队列默认把元素存到数组里，所以这里用数组来保存队列里的元素，在构造函数中初始化容量和数组，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 队列内部数组默认容量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 队列内部数组的容量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> capacity;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 保存元素的数组</span></span><br><span class="line"><span class="keyword">private</span> Object[] elements;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指向队列头部</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> head;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指向队列尾部</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> tail;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 默认构造函数初始化</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CircularQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    capacity =  DEFAULT_CAPACITY;</span><br><span class="line">    elements = <span class="keyword">new</span> Object[capacity];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定队列内部数组容量进行初始化</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> capacity 指定容量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CircularQueue</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">    elements = <span class="keyword">new</span> Object[capacity];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面就不废话了，直接看实现吧，通过上面的分析，代码没什么难度了。嘻嘻^_^</p><p><strong>入队</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public boolean add(E e) &#123;</span><br><span class="line">    Objects.requireNonNull(e);</span><br><span class="line">    // 判断队列是否满了</span><br><span class="line">    if ((tail + 1) % capacity == head) &#123;</span><br><span class="line">        throw new IllegalStateException(&quot;Queue full&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    elements[tail] = e;</span><br><span class="line">    tail = (tail + 1) % capacity;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>出队</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public E poll() &#123;</span><br><span class="line">    // 如果 head == tail, 队列就为null</span><br><span class="line">    if (isEmpty()) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    E value = (E) elements[head];</span><br><span class="line">    head = (head + 1) % capacity;</span><br><span class="line">    return value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>打印</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 打印</span><br><span class="line"> */</span><br><span class="line">public String toString() &#123;</span><br><span class="line">    if (isEmpty()) &#123;</span><br><span class="line">        return &quot;[]&quot;;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        StringBuilder sb = new StringBuilder(&quot;[&quot;);</span><br><span class="line">        for (int i = head; i != tail; i = (i + 1) % capacity) &#123;</span><br><span class="line">          sb.append(elements[i].toString() + &quot;, &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        int len = sb.length();  </span><br><span class="line">        return sb.delete(len - 2, len).append(&quot;]&quot;).toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>源代码在<a href="https://github.com/mstao/data-structures/blob/master/Queue/src/pers/mingshan/queue/CircularQueue.java" target="_blank" rel="noopener">这里</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> 队列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 队列 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java虚拟机的监控及诊断工具（命令行）</title>
      <link href="/2018/10/21/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7%EF%BC%88%E5%91%BD%E4%BB%A4%E8%A1%8C%EF%BC%89/"/>
      <url>/2018/10/21/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7%EF%BC%88%E5%91%BD%E4%BB%A4%E8%A1%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>对于普通的开发人员来说，可以阅读帮助文档或者源码来对JDK的设计以及JVM的内存管理获取一定的了解，但对于线上运行的程序，如何对程序进行监控和诊断呢？比如一个程序挂了，怎么通过分析堆栈信息、GC日志、线程快照等信息来快速定位问题？JDK的大佬早就为我们考虑到这一点，所以在JDK中包含了许多用于监控及诊断的工具，主要分为两类，<strong>命令行工具</strong>和<strong>GUI工具</strong>，这些工具在平时的开发中用到的频率非常高，我们一起来总结了解下。</p><a id="more"></a><p>常用的命令行工具以及作用：</p><table><thead><tr><th>名称</th><th>主要作用</th></tr></thead><tbody><tr><td>jps</td><td>JVM Process Status Tool,  列出指定系统内正在运行的虚拟机进程</td></tr><tr><td>jstat</td><td>JVM Statistics Monitoring Tool，允许用户查看目标 Java 进程的类加载、即时编译以及垃圾回收相关信息。常用来检测垃圾回收及内存泄露问题。</td></tr><tr><td>jinfo</td><td>打印目标 Java 进程的配置参数，并能够改动其中 manageabe 的参数。</td></tr><tr><td>jmap</td><td>统计用户统计目标 Java 进程的堆中存放的 Java 对象，生成堆转储快照（heapdump文件）</td></tr><tr><td>jstack</td><td>打印目标 Java 进程中各个线程的栈轨迹、线程状态、锁状况等信息，它还将自动检测死锁。</td></tr><tr><td>jcmd</td><td>实现前面除了jstat之外所有命令的功能</td></tr></tbody></table><h2 id="jps"><a href="#jps" class="headerlink" title="jps"></a>jps</h2><p>jps命令（<a href="https://docs.oracle.com/en/java/javase/11/tools/jps.html#GUID-6EB65B96-F9DD-4356-B825-6146E9EEC81E" target="_blank" rel="noopener">帮助文档</a>）用于列出正在运行的虚拟机进程信息，它的命令格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jps [ -q ] [ -mlvV ][hostid ]</span><br><span class="line">jps [ -help ]</span><br></pre></td></tr></table></figure><p>在默认情况下，jps的输出信息包括 Java 进程的进程ID以及主类名。jps还提供一些参数用于打印详细的信息。</p><p>其中 <code>-q</code>仅显示虚拟机的进程id， <code>-mlvV</code> 的意义如下：</p><ul><li><code>-m</code> 将打印传递给主类的参数</li><li><code>-l</code> 将打印模块名以及包名</li><li><code>-v</code> 将打印传递给虚拟机的参数</li><li><code>-V</code> 将打印传递给主类的参数、jar文件名等</li></ul><p>具体jps示例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ jps -l</span><br><span class="line">11988</span><br><span class="line">48932</span><br><span class="line">32696 org.jetbrains.idea.maven.server.RemoteMavenServer</span><br><span class="line">26140 jdk.jcmd/sun.tools.jps.Jps</span><br></pre></td></tr></table></figure><p>添加<code>-mlvV</code>打印更加详细的信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ jps -mlvV</span><br><span class="line">32696 org.jetbrains.idea.maven.server.RemoteMavenServer -Djava.awt.headless=true -Didea.version==2018.2.5 -Xmx768m -Didea.maven.embedder.version=3.5.4 -Dfile.encoding=GBK</span><br><span class="line">26924 jdk.jcmd/sun.tools.jps.Jps -mlvV -Dapplication.home=F:\develope\Java\Java11 -Xms8m -Djdk.module.main=jdk.jcmd</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure><h2 id="jstat"><a href="#jstat" class="headerlink" title="jstat"></a>jstat</h2><p><code>jstat</code>（<a href="https://docs.oracle.com/en/java/javase/11/tools/jstat.html#GUID-5F72A7F9-5D5A-4486-8201-E1D1BA8ACCB5" target="_blank" rel="noopener">帮助文档</a>）是用于监视虚拟机各种运行状态信息的命令行工具，它可以显示本地或者远程虚拟机进程中的类加载、内存、垃圾回收等信息，它的命令格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jstat generalOptions</span><br><span class="line">jstat -outputOptions [ -t] [-hlines] vmid [interval [count] ]</span><br></pre></td></tr></table></figure><p>其中<code>vmid</code>全称是Virtual Machine Identifier，就是<code>jps</code>命令显示的进程id，如果是远程虚拟机进程，<code>vmid</code>的格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[protocol:][//]lvmid[@hostname[:port]/servername]</span><br></pre></td></tr></table></figure><p><code>jstat</code>命令包含很多的子命令，主要分为3类：</p><ul><li>类加载（<code>-class</code>）</li><li>即时编译（<code>-compiler</code>和<code>-printcompilation</code>）</li><li>垃圾回收（<code>-gc*</code>）</li></ul><p>输入<code>jstat -options</code>显示如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ jstat -options</span><br><span class="line">-class</span><br><span class="line">-compiler</span><br><span class="line">-gc</span><br><span class="line">-gccapacity</span><br><span class="line">-gccause</span><br><span class="line">-gcmetacapacity</span><br><span class="line">-gcnew</span><br><span class="line">-gcnewcapacity</span><br><span class="line">-gcold</span><br><span class="line">-gcoldcapacity</span><br><span class="line">-gcutil</span><br><span class="line">-printcompilation</span><br></pre></td></tr></table></figure><p>参数<code>interval</code>和<code>count</code>代表查询间隔和次数，如果省略，默认查询一次。</p><p>现在我们要查询进程id 为26792的垃圾收集情况，并且是每隔2秒打印一次，共打印2次，命令和输出示例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ jstat -gc 26792 2s 2</span><br><span class="line"> S0C    S1C    S0U    S1U      EC       EU        OC         OU       MC     MU    CCSC   CCSU   YGC     YGCT    FGC    FGCT    CGC    CGCT     GCT</span><br><span class="line">5120.0 5120.0  0.0   5095.1 33280.0  30033.1   87552.0     2573.4   15232.0 14724.4 1920.0 1782.4      3    0.027   1      0.032   -          -    0.059</span><br><span class="line">5120.0 5120.0  0.0   5095.1 33280.0  30033.1   87552.0     2573.4   15232.0 14724.4 1920.0 1782.4      3    0.027   1      0.032   -          -    0.059</span><br></pre></td></tr></table></figure><p>在上面的示例中，输出了一大堆东西，那么这些是什么意思呢？前面说了，<code>jstat</code>有很多的关于垃圾回收的子命令，每个子命令的输出结果也不一样，具体可参考（<a href="https://docs.oracle.com/en/java/javase/11/tools/jstat.html#GUID-5F72A7F9-5D5A-4486-8201-E1D1BA8ACCB5" target="_blank" rel="noopener">帮助文档</a>）。我们知道JVM堆是分代的，前四个 表示Survivor 区的容量（Capacity）和已使用量（Utilization），EC表示当前Eden的容量，剩下的就不说了。</p><p>在翻阅文档的时候，发现没有CGC 和 CGCT的解释，它们分别代表并发 GC Stop-The-World 的次数和时间。</p><p><code>-t</code> 参数会显示时间戳列作为输出的第一列，它将在每行数据之前打印目标 Java 进程的启动以来的时间，示例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ jstat -gc -t 26792 2s 2</span><br><span class="line">Timestamp        S0C    S1C    S0U    S1U      EC       EU        OC         OU       MC     MU    CCSC   CCSU   YGC     YGCT    FGC    FGCT    CGC    CGCT     GCT</span><br><span class="line">         1949.1 5120.0 5120.0  0.0   5095.1 33280.0  31206.1   87552.0     2573.4   15232.0 14724.4 1920.0 1782.4      3    0.027   1      0.032   -          -   0.059</span><br><span class="line">         1951.1 5120.0 5120.0  0.0   5095.1 33280.0  31206.1   87552.0     2573.4   15232.0 14724.4 1920.0 1782.4      3    0.027   1      0.032   -          -   0.059</span><br></pre></td></tr></table></figure><h2 id="jmap"><a href="#jmap" class="headerlink" title="jmap"></a>jmap</h2><p><code>jmap</code>命令（<a href="https://docs.oracle.com/en/java/javase/11/tools/jmap.html#GUID-D2340719-82BA-4077-B0F3-2803269B7F41" target="_blank" rel="noopener">帮助文档</a>）用于生成堆转储快照，用于分析Java虚拟机堆中的对象。</p><p>它的命令格式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmap [options] pid</span><br></pre></td></tr></table></figure><p><code>jmap</code>命令的参数选项也包括很多种，具体如下：</p><p><strong>1. -clstats</strong></p><p>连接到正在运行的进程并打印Java堆被加载类的统计信息</p><p><strong>2. -finalizerinfo</strong></p><p>连接到正在运行的进程并打印所有待 finalize 的对象。</p><p><strong>3. -histo[:live]</strong></p><p>连接到正在运行的进程并统计各个类的实例数目以及占用内存，并按照内存使用量从多至少的顺序排列。此外，-histo:live只统计堆中还在存活的对象。</p><p><strong>4. -dump</strong></p><p>连接到正在运行的进程并导出Java虚拟机堆内存的快照。该子命令该包含如下参数：</p><ul><li>live  只保存堆中存活的对象</li><li>format=b 将使jmap导出与hprof（在 Java 9 中已被移除）-XX:+HeapDumpAfterFullGC、-XX:+HeapDumpOnOutOfMemoryError格式一样的文件</li><li>file=filename 指定导出堆内存快照的位置</li></ul><p>综合以上参数，示例命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmap -dump:live,format=b,file=heap.bin pid</span><br></pre></td></tr></table></figure><h2 id="jinfo"><a href="#jinfo" class="headerlink" title="jinfo"></a>jinfo</h2><p><code>jinfo</code>命令（<a href="https://docs.oracle.com/en/java/javase/11/tools/jinfo.html#GUID-69246B58-28C4-477D-B375-278F5F9830A5" target="_blank" rel="noopener">帮助文档</a>）用来实时地查看和调整虚拟机的各项参数。我们可以使用<code>jps -v</code>来查看传递给虚拟机的参数，即<code>System.getProperty</code>获取的<code>-D</code>参数，现在我们可以利用<code>jinfo</code>命令来获取了。</p><p>它的命令格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jinfo [option] pid</span><br></pre></td></tr></table></figure><p>它也包括了许多子命令，具体如下：</p><p><strong>1. -flag name</strong></p><p>打印指定的虚拟机参数的名称和值</p><p><strong>2. -flag [+|-]name</strong></p><p>用来修改目标 Java 进程的“manageable”虚拟机参数。其中<code>+</code>代表开启，<code>-</code>代表关闭。</p><p>输入<code>java -XX:+PrintFlagsFinal -version | grep manageable</code>来查看“manageable”虚拟机参数，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ java -XX:+PrintFlagsFinal -version | grep manageable</span><br><span class="line">     intx CMSAbortablePrecleanWaitMillis           = 100                                    &#123;manageable&#125; &#123;default&#125;</span><br><span class="line">     intx CMSTriggerInterval                       = -1                                     &#123;manageable&#125; &#123;default&#125;</span><br><span class="line">     intx CMSWaitDuration                          = 2000                                   &#123;manageable&#125; &#123;default&#125;</span><br><span class="line">     bool HeapDumpAfterFullGC                      = false                                  &#123;manageable&#125; &#123;default&#125;</span><br><span class="line">     bool HeapDumpBeforeFullGC                     = false                                  &#123;manageable&#125; &#123;default&#125;</span><br><span class="line">     bool HeapDumpOnOutOfMemoryError               = false                                  &#123;manageable&#125; &#123;default&#125;</span><br><span class="line">    ccstr HeapDumpPath                             =                                        &#123;manageable&#125; &#123;default&#125;</span><br><span class="line">    uintx MaxHeapFreeRatio                         = 70                                     &#123;manageable&#125; &#123;default&#125;</span><br><span class="line">    uintx MinHeapFreeRatio                         = 40                                     &#123;manageable&#125; &#123;default&#125;</span><br><span class="line">     bool PrintClassHistogram                      = false                                  &#123;manageable&#125; &#123;default&#125;</span><br><span class="line">     bool PrintConcurrentLocks                     = false                                  &#123;manageable&#125; &#123;default&#125;</span><br><span class="line">java version &quot;11&quot; 2018-09-25</span><br><span class="line">Java(TM) SE Runtime Environment 18.9 (build 11+28)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM 18.9 (build 11+28, mixed mode)</span><br></pre></td></tr></table></figure><p><strong>3. -flag name=value</strong></p><p>设置指定的虚拟机参数的值</p><p><strong>4. -flags</strong></p><p>打印全部的虚拟机参数，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ jinfo -flags 26792</span><br><span class="line">VM Flags:</span><br><span class="line">-XX:CICompilerCount=3 -XX:InitialHeapSize=134217728 -XX:MaxHeapSize=805306368 -XX:MaxNewSize=268435456 -XX:MinHeapDeltaBytes=524288 -XX:NewSize=44564480 -XX:OldSize=89653248 -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:-UseLargePagesIndividualAllocation -XX:+UseParallelGC</span><br></pre></td></tr></table></figure><p><strong>5. -sysprops</strong></p><p>打印java系统参数（Java System Properties）</p><h2 id="jstack"><a href="#jstack" class="headerlink" title="jstack"></a>jstack</h2><p><code>jstack</code>命令（<a href="https://docs.oracle.com/en/java/javase/11/tools/jstack.html#GUID-721096FC-237B-473C-A461-DBBBB79E4F6A" target="_blank" rel="noopener">帮助文档</a>）可以用来打印目标 Java 进程中各个线程的栈轨迹，以及这些线程所持有的锁。通过线程的栈轨迹可以定位线程长时间停顿的原因，如线程间死锁、死循环、请求外部资源导致长时间等待等。</p><p>它的命令格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jstack [options] pid</span><br></pre></td></tr></table></figure><p>它也有子命令：</p><p><strong>-l</strong></p><p>输出关于锁的附加信息，例如属于java.util.concurrent的ownable synchronizers列表</p><p>下面是一个示例，如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$ jstack -l 42680</span><br><span class="line">2018-10-21 23:09:17</span><br><span class="line">Full thread dump OpenJDK 64-Bit Server VM (25.152-b19 mixed mode):</span><br><span class="line"></span><br><span class="line">&quot;ApplicationImpl pooled thread 35&quot; #142 daemon prio=4 os_prio=-1 tid=0x0000000018422000 nid=0xafe8 waiting on condition [0x00000000458bf000]</span><br><span class="line">   java.lang.Thread.State: TIMED_WAITING (parking)</span><br><span class="line">        at sun.misc.Unsafe.park(Native Method)</span><br><span class="line">        - parking to wait for  &lt;0x00000000e1506488&gt; (a java.util.concurrent.SynchronousQueue$TransferStack)</span><br><span class="line">        at java.util.concurrent.locks.LockSupport.parkNanos(LockSupport.java:215)</span><br><span class="line">        at java.util.concurrent.SynchronousQueue$TransferStack.awaitFulfill(SynchronousQueue.java:460)</span><br><span class="line">        at java.util.concurrent.SynchronousQueue$TransferStack.transfer(SynchronousQueue.java:362)</span><br><span class="line">        at java.util.concurrent.SynchronousQueue.poll(SynchronousQueue.java:941)</span><br><span class="line">        at java.util.concurrent.ThreadPoolExecutor.getTask(ThreadPoolExecutor.java:1066)</span><br><span class="line">        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1127)</span><br><span class="line">        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)</span><br><span class="line">        at java.lang.Thread.run(Thread.java:745)</span><br><span class="line"></span><br><span class="line">   Locked ownable synchronizers:</span><br><span class="line">        - None</span><br></pre></td></tr></table></figure><p>在输出的信息中，会包含线程的状态，下面是常见的线程状态：</p><ol><li>RUNNABLE，线程处于执行中</li><li>BLOCKED，线程被阻塞</li><li>WAITING，线程正在等待</li><li>TIMED_WAITING 超时等待</li></ol><h2 id="jcmd"><a href="#jcmd" class="headerlink" title="jcmd"></a>jcmd</h2><p><code>jcmd</code>命令（<a href="https://docs.oracle.com/en/java/javase/11/tools/jcmd.html#GUID-59153599-875E-447D-8D98-0078A5778F05" target="_blank" rel="noopener">帮助文档</a>）可以向运行中的Java虚拟机(JVM)发送诊断命令。</p><p>它的命令格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jcmd &lt;pid | main class&gt; &lt;command ... | PerfCounter.print | -f  file&gt;</span><br><span class="line">jcmd -l</span><br><span class="line">jcmd -h</span><br></pre></td></tr></table></figure><p><strong>pid</strong></p><p>虚拟机的进程id</p><p><strong>main class</strong></p><p>接收诊断命令请求的进程的main类。</p><p><strong>command</strong></p><p>该命令必须是针对所选JVM的有效jcmd命令。jcmd的可用命令列表是通过运行help命令(jcmd pid help)获得的，其中pid是运行Java进程的进程ID。如果pid为0，命令将被发送到所有的Java进程。main class参数将用于部分或完全匹配用于启动Java的类。如果没有提供任何选项，它会列出正在运行的Java进程标识符以及用于启动进程的主类和命令行参数(与使用-l相同)。</p><p><strong>Perfcounter.print</strong></p><p>打印目标Java进程上可用的性能计数器。性能计数器的列表可能会随着Java进程的不同而产生变化。</p><p><strong>-f file</strong></p><p>从文件file中读取命令，然后在目标Java进程上调用这些命令。</p><p><strong>-l</strong></p><p>查看所有的进程列表信息。</p><p><strong>-h</strong><br>查看帮助信息。（同 -help）</p><p>jcmd的可用命令列表如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">$ jcmd 26792 help</span><br><span class="line">26792:</span><br><span class="line">The following commands are available:</span><br><span class="line">VM.native_memory</span><br><span class="line">ManagementAgent.stop</span><br><span class="line">ManagementAgent.start_local</span><br><span class="line">ManagementAgent.start</span><br><span class="line">GC.rotate_log</span><br><span class="line">Thread.print</span><br><span class="line">GC.class_stats</span><br><span class="line">GC.class_histogram</span><br><span class="line">GC.heap_dump</span><br><span class="line">GC.run_finalization</span><br><span class="line">GC.run</span><br><span class="line">VM.uptime</span><br><span class="line">VM.flags</span><br><span class="line">VM.system_properties</span><br><span class="line">VM.command_line</span><br><span class="line">VM.version</span><br><span class="line">help</span><br><span class="line"></span><br><span class="line">For more information about a specific command use &apos;help &lt;command&gt;&apos;.</span><br></pre></td></tr></table></figure><p>PS: 以后用到了再详细补充。。</p><p>参考：</p><ul><li><a href="https://docs.oracle.com/en/java/javase/11/tools/monitoring-tools-and-commands.html" target="_blank" rel="noopener">Monitoring Tools and Commands</a></li><li><a href="https://docs.oracle.com/en/java/javase/11/tools/troubleshooting-tools-and-commands.html" target="_blank" rel="noopener">Troubleshooting Tools and Commands</a></li><li><a href="https://time.geekbang.org/column/article/40520" target="_blank" rel="noopener">Java虚拟机的监控及诊断工具（命令行篇）</a></li><li>周志明，深入理解Java虚拟机:JVM高级特性与最佳实践（第二版）</li></ul>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ForkJoin实践及JMH基准测试其性能</title>
      <link href="/2018/10/19/ForkJoin%E5%AE%9E%E8%B7%B5%E5%8F%8AJMH%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95%E5%85%B6%E6%80%A7%E8%83%BD/"/>
      <url>/2018/10/19/ForkJoin%E5%AE%9E%E8%B7%B5%E5%8F%8AJMH%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95%E5%85%B6%E6%80%A7%E8%83%BD/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>熟悉Java Stream API的同学可能知道可以利用<code>parallelStream</code>来实现并行操作，而Stream的并行操作依赖JDK1.7引入的Fork/Join框架，提供实现并行编程的一种方案。下面是Doug Lea对并行编程的描述：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(recursively) splitting them into subtasks that are solved in</span><br><span class="line">parallel, waiting for them to complete, and then composing</span><br><span class="line">results.</span><br></pre></td></tr></table></figure><a id="more"></a><p>Fork/Join框架的主要设计思想是采用了类似分治算法（ divide−<br>and−conquer algorithms），将任务分割成许多小任务并行执行，最后合并计算结果，这比串行化执行效率提高不少。伪代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Result <span class="title">solve</span><span class="params">(Problem problem)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">if</span> (problem is small)</span><br><span class="line"> directly solve problem</span><br><span class="line"> <span class="keyword">else</span> &#123;</span><br><span class="line"> split problem into independent parts</span><br><span class="line"> fork <span class="keyword">new</span> subtasks to solve each part</span><br><span class="line"> join all subtasks</span><br><span class="line"> compose result from subresults</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里涉及到两个词，fork和join，在Doug Lea的论文中，有以下描述：</p><p>Fork：开启一个新的子任务进行计算</p><blockquote><p>The fork operation starts a new parallel fork/join subtask. </p></blockquote><p>Join: 导致当前任务等待直至被fork的线程计算完成</p><blockquote><p>The join operation causes the current task not to proceed until the<br>forked subtask has completed.</p></blockquote><p>从fork/join的描述来看，就是利用递归不断的划分子任务，直至任务被划分的足够小，直接串行执行足够简单，没有问题。</p><h2 id="测试和性能对比"><a href="#测试和性能对比" class="headerlink" title="测试和性能对比"></a>测试和性能对比</h2><p>我们通过计算1 ~ 100000000相加求和问题，来模拟fork/join并行执行，并通过与串行化for循环执行，利用线程池多线程并发执行 的时间对比，来推测fork/join的计算效率。</p><h3 id="FOR串行"><a href="#FOR串行" class="headerlink" title="FOR串行"></a>FOR串行</h3><p>先考虑最简单的情况，直接利用for循环执行上面的计算任务，这是在单线程情况下来执行的，也就是串行执行，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForLoopCalculatorImpl</span> <span class="keyword">implements</span> <span class="title">Calculator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">sum</span><span class="params">(<span class="keyword">long</span>[] numbers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> result = <span class="number">0L</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numbers.length; i++) &#123;</span><br><span class="line">            result += numbers[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码相当简单，无需多言。</p><h3 id="线程池并发"><a href="#线程池并发" class="headerlink" title="线程池并发"></a>线程池并发</h3><p>For循环执行时利用单线程来执行的，当计算任务较大时，我们可能会考虑使用多线程来处理计算任务，并且计算过程是异步的。首先考虑CPU核心数，将任务分割成与CPU核心数一样数量的子任务，避免CPU时间片的过度切换引起资源浪费。获取CPU核心数和初始化线程池的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> parallism = Runtime.getRuntime().availableProcessors();</span><br><span class="line"><span class="keyword">private</span> ExecutorService pool;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ExecutorServiceCalculatorImpl</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> corePoolSize = Math.max(<span class="number">2</span>, Math.min(parallism - <span class="number">1</span>, <span class="number">4</span>));</span><br><span class="line">    <span class="keyword">int</span> maximumPoolSize = parallism * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> keepAliveTime = <span class="number">30</span>;</span><br><span class="line">    System.out.println(String.format(<span class="string">"corePoolSize = %s, maximumPoolSize = %s"</span>, corePoolSize, maximumPoolSize));</span><br><span class="line">    BlockingQueue&lt;Runnable&gt; workQueue = <span class="keyword">new</span> LinkedBlockingDeque&lt;&gt;();</span><br><span class="line">    <span class="comment">// 线程的创建工厂</span></span><br><span class="line">    ThreadFactory threadFactory = <span class="keyword">new</span> ThreadFactory() &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger mCount = <span class="keyword">new</span> AtomicInteger(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Thread(r, <span class="string">"AdvacnedAsyncTask #"</span> + mCount.getAndIncrement());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线程池任务满载后采取的任务拒绝策略</span></span><br><span class="line">    RejectedExecutionHandler rejectHandler = <span class="keyword">new</span> ThreadPoolExecutor.DiscardOldestPolicy();</span><br><span class="line"></span><br><span class="line">    pool = <span class="keyword">new</span> ThreadPoolExecutor(corePoolSize,</span><br><span class="line">            maximumPoolSize,</span><br><span class="line">            keepAliveTime,</span><br><span class="line">            TimeUnit.SECONDS,</span><br><span class="line">            workQueue,</span><br><span class="line">            threadFactory,</span><br><span class="line">            rejectHandler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码是使用ThreadPoolExecutor来创建线程池的，这样会更加了解线程池使用的各种细节。</p><p>接下来我们就需要使用线程池，根据CPU核心数来划分一定数量的子任务，然后将这些子任务交给线程池里面的线程去执行。此时注意任务的划分不一定是均匀的，因为最后一份任务可能比其他的多或者少，需要特别处理一下，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">sum</span><span class="params">(<span class="keyword">long</span>[] numbers)</span> </span>&#123;</span><br><span class="line">    List&lt;Future&lt;Long&gt;&gt; futures = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把任务分解为 n 份，交给 n 个线程处理，</span></span><br><span class="line">    <span class="comment">// 此时由于int类型丢失精度</span></span><br><span class="line">    <span class="keyword">int</span> part = numbers.length / parallism;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; parallism; i++) &#123;</span><br><span class="line">        <span class="comment">// 进行任务分配</span></span><br><span class="line">        <span class="keyword">int</span> from = i * part;</span><br><span class="line">        <span class="comment">// 最后一份任务可能不均匀，直接分配给最后一个线程</span></span><br><span class="line">        <span class="keyword">int</span> to = (i == parallism - <span class="number">1</span>) ? numbers.length - <span class="number">1</span> : (i + <span class="number">1</span>) * part - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 提交计算任务</span></span><br><span class="line">        futures.add(pool.submit(<span class="keyword">new</span> SumTask(numbers, from, to)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把每个线程的结果相加，得到最终结果</span></span><br><span class="line">    <span class="keyword">long</span> total = <span class="number">0L</span>;</span><br><span class="line">    <span class="keyword">for</span> (Future&lt;Long&gt; future : futures) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            total += future.get();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ignore) &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    pool.shutdown();</span><br><span class="line">    <span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中涉及到一个计算任务<code>SumTask</code>，抽象出来用来计算从<code>from</code> 到 <code>to</code> 之间的数相加之和，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SumTask</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span>[] numbers;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> from;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> to;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SumTask</span><span class="params">(<span class="keyword">long</span>[] numbers, <span class="keyword">int</span> from, <span class="keyword">int</span> to)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.numbers = numbers;</span><br><span class="line">        <span class="keyword">this</span>.from = from;</span><br><span class="line">        <span class="keyword">this</span>.to = to;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> total = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = from; i &lt;= to; i++) &#123;</span><br><span class="line">            total += numbers[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> total;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看过上面的代码，我们主要是利用了线程池来并发来执行计算任务，同时利用了线程池异步的特性，从设计上来说比for循环串行执行要好，但由于涉及到CPU的时间片切换，执行耗时上可能会比串行执行要高。</p><h3 id="Fokr-Join"><a href="#Fokr-Join" class="headerlink" title="Fokr/Join"></a>Fokr/Join</h3><p>写完线程池并发执行计算任务，如果让我们来设计并行执行任务的框架，可能会想到用线程池来做，既然Doug Lea写出了Fork/Join框架，肯定不是利用我们现在的方式来做，那么他是如何实现的呢？</p><p>Fork/Join框架抽象出了<code>ForkJoinTask</code>来代表要执行的计算任务，该类实现了<code>Future</code>接口，比<code>Thread</code>更加轻量级。不过我们通常不需要直接继承该类，Fork/Join框架给我们提供了两个抽象类供我们继承：</p><ul><li><code>RecursiveTask</code> ：代表有返回值的计算任务 </li><li><code>RecursiveAction</code>：代表没有返回值的任务</li></ul><p>我们的计算任务有返回值，所以我们直接继承<code>RecursiveTask</code>就好了，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SumTask</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THRESHOLD = <span class="number">2000000</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span>[] numbers;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> start;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> end;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SumTask</span><span class="params">(<span class="keyword">long</span>[] numbers, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.numbers = numbers;</span><br><span class="line">        <span class="keyword">this</span>.start = start;</span><br><span class="line">        <span class="keyword">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Long <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断问题规模</span></span><br><span class="line">        <span class="keyword">if</span> ((end - start) &lt;= THRESHOLD) &#123;</span><br><span class="line">            <span class="keyword">long</span> result = <span class="number">0L</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt;= end; i++) &#123;</span><br><span class="line">                result += numbers[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将任务分割为多个小任务</span></span><br><span class="line">        <span class="keyword">int</span> middle = (start + end) / <span class="number">2</span>;</span><br><span class="line">        SumTask taskLeft = <span class="keyword">new</span> SumTask(numbers, start, middle);</span><br><span class="line">        SumTask taskRight = <span class="keyword">new</span> SumTask(numbers, middle + <span class="number">1</span>, end);</span><br><span class="line">        invokeAll(taskLeft, taskRight);</span><br><span class="line">        <span class="keyword">long</span> result = taskLeft.join() + taskRight.join();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们需要重写<code>RecursiveTask</code>类的<code>compute()</code>方法，在该方法中进行任务的分割操作。和开始我们见到的伪代码类似，先判断任务规模（其实也是递归终止条件），相当于一个阈值，任务规模小于这个阈值，直接进行计算；大于这个阈值，将任务一份为二，这样递归下去，直至任务不可再分。注意这里我们采用<code>invokeAll</code>来进行任务分割，不过很多网上的例子采用的是如下写法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 分别对子任务调用fork():</span><br><span class="line">subTask1.fork();</span><br><span class="line">subTask2.fork();</span><br></pre></td></tr></table></figure><p>在JDK官方例子中，这种写法是没有出现过的，也是不正确的，原因后面再分析。</p><p>Fork/Join框架提供了<code>ForkJoinPool</code>来执行我们分割好的任务，<code>pool.invoke(task)</code>来提交一个Fork/Join任务并发执行，然后获得异步执行的结果。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForkJoinCalculatorImpl</span> <span class="keyword">implements</span> <span class="title">Calculator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ForkJoinPool pool;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">sum</span><span class="params">(<span class="keyword">long</span>[] source)</span> </span>&#123;</span><br><span class="line">        pool = <span class="keyword">new</span> ForkJoinPool();</span><br><span class="line">        SumTask task = <span class="keyword">new</span> SumTask(source, <span class="number">0</span>, source.length - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> pool.invoke(task);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在利用Fork/Join计算任务时，可能会出现<code>StackOverflowError</code>，这是由于递归层数太深，导致超出JDK的设置，需要重新评估任务分割的程度或者调整大小。</p><p>如果任务分割不正确，还会抛出以下异常，需要关注：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.lang.NoClassDefFoundError: Could not initialize class java.util.concurrent.locks.AbstractQueuedSynchronizer$Node</span><br></pre></td></tr></table></figure><h3 id="计算耗时（基础测试）"><a href="#计算耗时（基础测试）" class="headerlink" title="计算耗时（基础测试）"></a>计算耗时（基础测试）</h3><p>上面三种计算方式究竟计算效率怎么样呢？我们来写个测试类测试一把，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">long[] numbers = LongStream.rangeClosed(1L, 100000000L).toArray();</span><br><span class="line"></span><br><span class="line">// 1 直接for循环</span><br><span class="line">Calculator calculator = new ForLoopCalculatorImpl();</span><br><span class="line">long currentTime1 = System.currentTimeMillis();</span><br><span class="line">long result1 = calculator.sum(numbers);</span><br><span class="line">long executedTime = System.currentTimeMillis() - currentTime1;</span><br><span class="line">System.out.println(&quot;直接循环计算结果：&quot; + result1 + &quot;, 耗时：&quot; + executedTime);</span><br><span class="line"></span><br><span class="line">// 2 利用线程池</span><br><span class="line">Calculator calculator2 = new ExecutorServiceCalculatorImpl();</span><br><span class="line">long currentTime2 = System.currentTimeMillis();</span><br><span class="line">long result2 = calculator2.sum(numbers);</span><br><span class="line">long executedTime2 = System.currentTimeMillis() - currentTime2;</span><br><span class="line">System.out.println(&quot;线程池计算结果：&quot; + result2 + &quot;, 耗时：&quot; + executedTime2);</span><br><span class="line"></span><br><span class="line">// 3 fork/join</span><br><span class="line">Calculator calculator3 = new ForkJoinCalculatorImpl();</span><br><span class="line">long currentTime3 = System.currentTimeMillis();</span><br><span class="line">long result3 = calculator3.sum(numbers);</span><br><span class="line">long executedTime3 = System.currentTimeMillis() - currentTime3;</span><br><span class="line">System.out.println(&quot;Fork/Join计算结果：&quot; + result3 + &quot;, 耗时：&quot; + executedTime3);</span><br></pre></td></tr></table></figure><p>计算结果如下：</p><p><img src="https://github.com/ZZULI-TECH/interview/blob/master/images/concurrency/fj_calculator_result.png?raw=true" alt="image"></p><p>我用的是Window10操作系统，CPU i5 7代、4核心，跑的时候CPU飙到了100%，由于是计算密集型任务，需要CPU的全力参与，也无可厚非。。如下：</p><p><img src="https://github.com/ZZULI-TECH/interview/blob/master/images/concurrency/fj_cpu.png?raw=true" alt="image"></p><p>从上面的计算结果来看，Fork/Join耗时最少，线程池次之，直接For循环是耗时最多的，简直是难以置信啊，不过这个结果可能不稳定，至少也说明了Fork/Join在某些场景下比较优秀的事实（结论未必正确）。</p><h3 id="基准测试（JMH）"><a href="#基准测试（JMH）" class="headerlink" title="基准测试（JMH）"></a>基准测试（JMH）</h3><p>上面我们是利用方法执行的开始与结束时间的差值来评估方法的执行性能，利用这种方式得出的结论往往是站不住脚的（不严谨），因为没有考虑到程序在运行时JVM所带来的影响，所以得出的结论未必可靠，我们也不能乱下结论。</p><p>那么有没有一个比较靠谱的性能测试框架呢？JMH（Java Microbenchmark Harness）是一个面向Java语言或JVM平台语言的性能基准测试框架，它针对的是纳秒级别、微秒级别、毫秒级别以及秒级别的性能测试。听上去是不是很叼？我们就用它来测试上面写的三个计算任务吧。</p><p>首先我们需要用<code>@Benchmark</code>来标识JMH基准测试的测试方法，用法和Junit的<code>@Test</code>类似，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span>[] numbers = LongStream.rangeClosed(<span class="number">1L</span>, <span class="number">100_000_000L</span>).toArray();</span><br><span class="line"></span><br><span class="line"><span class="meta">@Benchmark</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1 直接for循环</span></span><br><span class="line">    Calculator calculator = <span class="keyword">new</span> ForLoopCalculatorImpl();</span><br><span class="line">    calculator.sum(numbers);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Benchmark</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 2 利用线程池</span></span><br><span class="line">    Calculator calculator2 = <span class="keyword">new</span> ExecutorServiceCalculatorImpl();</span><br><span class="line">    calculator2.sum(numbers);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Benchmark</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 3 fork/join</span></span><br><span class="line">    Calculator calculator3 = <span class="keyword">new</span> ForkJoinCalculatorImpl();</span><br><span class="line">    calculator3.sum(numbers);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>别忘了添加相关依赖哦，目前最新版本已是<code>1.21</code>，由于JMH性能测试是运行其提供的Main方法，需要添加maven相关插件配置运行Main方法，如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.openjdk.jmh&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;jmh-core&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;$&#123;jmh.version&#125;&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.openjdk.jmh&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;jmh-generator-annprocess&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;$&#123;jmh.version&#125;&lt;/version&gt;</span><br><span class="line">  &lt;scope&gt;provided&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>maven插件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-shade-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">phase</span>&gt;</span>package<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">goal</span>&gt;</span>shade<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">finalName</span>&gt;</span>java11-tutorial<span class="tag">&lt;/<span class="name">finalName</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">transformers</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transformer</span> <span class="attr">implementation</span>=<span class="string">"org.apache.maven.plugins.shade.resource.ManifestResourceTransformer"</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">mainClass</span>&gt;</span>org.openjdk.jmh.Main<span class="tag">&lt;/<span class="name">mainClass</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">transformer</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">transformers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure><p>接下来在该项目主目录下运行<code>maven clean package</code>进行编译打包，然后运行<code>java -jar target/java11-tutorial.jar</code> 直接执行测试，它的输出如下（重复的省略）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"># JMH version: 1.21</span><br><span class="line"># VM version: JDK 11, Java HotSpot(TM) 64-Bit Server VM, 11+28</span><br><span class="line"># VM invoker: F:\develope\Java\Java11\bin\java.exe</span><br><span class="line"># VM options: &lt;none&gt;</span><br><span class="line"># Warmup: 5 iterations, 10 s each</span><br><span class="line"># Measurement: 5 iterations, 10 s each</span><br><span class="line"># Timeout: 10 min per iteration</span><br><span class="line"># Threads: 1 thread, will synchronize iterations</span><br><span class="line"># Benchmark mode: Throughput, ops/time</span><br><span class="line"># Benchmark: me.mingshan.demo.fj.Test.test1</span><br><span class="line"></span><br><span class="line"># Run progress: 0.00% complete, ETA 00:25:00</span><br><span class="line"># Fork: 1 of 5</span><br><span class="line"># Warmup Iteration   1: 11.702 ops/s</span><br><span class="line"># Warmup Iteration   2: 11.902 ops/s</span><br><span class="line"># Warmup Iteration   3: 11.014 ops/s</span><br><span class="line"># Warmup Iteration   4: 10.663 ops/s</span><br><span class="line"># Warmup Iteration   5: 11.611 ops/s</span><br><span class="line">Iteration   1: 11.615 ops/s</span><br><span class="line">Iteration   2: 11.981 ops/s</span><br><span class="line">Iteration   3: 13.429 ops/s</span><br><span class="line">Iteration   4: 12.363 ops/s</span><br><span class="line">Iteration   5: 10.350 ops/s</span><br><span class="line"></span><br><span class="line">...运行五次</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Result &quot;me.mingshan.demo.fj.Test.test1&quot;:</span><br><span class="line">  11.492 ±(99.9%) 0.864 ops/s [Average]</span><br><span class="line">  (min, avg, max) = (9.804, 11.492, 14.808), stdev = 1.154</span><br><span class="line">  CI (99.9%): [10.628, 12.356] (assumes normal distribution)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># JMH version: 1.21</span><br><span class="line"># VM version: JDK 11, Java HotSpot(TM) 64-Bit Server VM, 11+28</span><br><span class="line"># VM invoker: F:\develope\Java\Java11\bin\java.exe</span><br><span class="line"># VM options: &lt;none&gt;</span><br><span class="line"># Warmup: 5 iterations, 10 s each</span><br><span class="line"># Measurement: 5 iterations, 10 s each</span><br><span class="line"># Timeout: 10 min per iteration</span><br><span class="line"># Threads: 1 thread, will synchronize iterations</span><br><span class="line"># Benchmark mode: Throughput, ops/time</span><br><span class="line"># Benchmark: me.mingshan.demo.fj.Test.test2</span><br><span class="line"></span><br><span class="line"># Run progress: 33.33% complete, ETA 00:16:59</span><br><span class="line"># Fork: 1 of 5</span><br><span class="line"># Warmup Iteration   1: 17.420 ops/s</span><br><span class="line"># Warmup Iteration   2: 15.220 ops/s</span><br><span class="line"># Warmup Iteration   3: 15.497 ops/s</span><br><span class="line"># Warmup Iteration   4: 14.617 ops/s</span><br><span class="line"># Warmup Iteration   5: 17.724 ops/s</span><br><span class="line">Iteration   1: 18.410 ops/s</span><br><span class="line">Iteration   2: 18.326 ops/s</span><br><span class="line">Iteration   3: 16.326 ops/s</span><br><span class="line">Iteration   4: 15.471 ops/s</span><br><span class="line">Iteration   5: 15.603 ops/s</span><br><span class="line"></span><br><span class="line">...运行五次</span><br><span class="line"></span><br><span class="line">Result &quot;me.mingshan.demo.fj.Test.test2&quot;:</span><br><span class="line">  16.358 ±(99.9%) 1.549 ops/s [Average]</span><br><span class="line">  (min, avg, max) = (11.898, 16.358, 18.918), stdev = 2.068</span><br><span class="line">  CI (99.9%): [14.809, 17.907] (assumes normal distribution)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># JMH version: 1.21</span><br><span class="line"># VM version: JDK 11, Java HotSpot(TM) 64-Bit Server VM, 11+28</span><br><span class="line"># VM invoker: F:\develope\Java\Java11\bin\java.exe</span><br><span class="line"># VM options: &lt;none&gt;</span><br><span class="line"># Warmup: 5 iterations, 10 s each</span><br><span class="line"># Measurement: 5 iterations, 10 s each</span><br><span class="line"># Timeout: 10 min per iteration</span><br><span class="line"># Threads: 1 thread, will synchronize iterations</span><br><span class="line"># Benchmark mode: Throughput, ops/time</span><br><span class="line"># Benchmark: me.mingshan.demo.fj.Test.test3</span><br><span class="line"></span><br><span class="line"># Run progress: 66.67% complete, ETA 00:08:29</span><br><span class="line"># Fork: 1 of 5</span><br><span class="line"># Warmup Iteration   1: 14.169 ops/s</span><br><span class="line"># Warmup Iteration   2: 14.925 ops/s</span><br><span class="line"># Warmup Iteration   3: 14.652 ops/s</span><br><span class="line"># Warmup Iteration   4: 14.448 ops/s</span><br><span class="line"># Warmup Iteration   5: 14.090 ops/s</span><br><span class="line">Iteration   1: 14.948 ops/s</span><br><span class="line">Iteration   2: 15.234 ops/s</span><br><span class="line">Iteration   3: 15.371 ops/s</span><br><span class="line">Iteration   4: 15.451 ops/s</span><br><span class="line">Iteration   5: 18.772 ops/s</span><br><span class="line"></span><br><span class="line">...运行五次</span><br><span class="line"></span><br><span class="line">Result &quot;me.mingshan.demo.fj.Test.test3&quot;:</span><br><span class="line">  17.366 ±(99.9%) 0.902 ops/s [Average]</span><br><span class="line">  (min, avg, max) = (14.948, 17.366, 19.462), stdev = 1.204</span><br><span class="line">  CI (99.9%): [16.465, 18.268] (assumes normal distribution)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Run complete. Total time: 00:25:27</span><br><span class="line"></span><br><span class="line">REMEMBER: The numbers below are just data. To gain reusable insights, you need to follow up on</span><br><span class="line">why the numbers are the way they are. Use profilers (see -prof, -lprof), design factorial</span><br><span class="line">experiments, perform baseline and negative tests that provide experimental control, make sure</span><br><span class="line">the benchmarking environment is safe on JVM/OS/HW level, ask for reviews from the domain experts.</span><br><span class="line">Do not assume the numbers tell you what you want them to tell.</span><br><span class="line"></span><br><span class="line">Benchmark    Mode  Cnt   Score   Error  Units</span><br><span class="line">Test.test1  thrpt   25  11.492 ± 0.864  ops/s</span><br><span class="line">Test.test2  thrpt   25  16.358 ± 1.549  ops/s</span><br><span class="line">Test.test3  thrpt   25  17.366 ± 0.902  ops/s</span><br></pre></td></tr></table></figure><p>其中<code>Fork：1 of 5</code>指的是JMH会Fork出一个新的虚拟机，来运行基准测试，目的是获得一个相对干净的运行环境，每个 Fork 包含了 5 个预热迭代（warmup iteration，如# Warmup Iteration   1: 14.169 ops/s）和5个测试迭代（measurement iteration，如Iteration   5: 18.772 ops/s）。</p><p>每次迭代后面的数据代表本次迭代的吞吐量，即每秒运行的次数（ops/s），也就是一次操作调用了一次测试方法。</p><p>好了，我们直接来看性能测试结果吧，如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Benchmark    Mode  Cnt   Score   Error  Units</span><br><span class="line">Test.test1  thrpt   25  11.492 ± 0.864  ops/s</span><br><span class="line">Test.test2  thrpt   25  16.358 ± 1.549  ops/s</span><br><span class="line">Test.test3  thrpt   25  17.366 ± 0.902  ops/s</span><br></pre></td></tr></table></figure><p>上面的输出便是本次基准测试的结果，主要关注Score和Error，Socre代表本次基准测试的平均吞吐量（每秒运行test*的次数），Error代表误差范围，所以。。。test1代表For循环串性执行，test2代表线程池并发执行，test3代表Fork/Join执行，结果很明显，Fork/Join每秒执行次数最多，线程池并发执行次之，For循环串性执行最少。</p><p>综合以上，我们可以小心翼翼地得出结论（怕被打。。），Fork/Join在计算密集型任务执行效率上是很好的，推荐大家使用。（完毕）</p><h2 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h2><p>目前先不分析，后面再写一遍文章。</p><p>参考：</p><ul><li><a href="http://gee.cs.oswego.edu/dl/papers/fj.pdf" target="_blank" rel="noopener">A Java Fork/Join Framework</a></li><li><a href="https://www.oracle.com/technetwork/cn/articles/java/fork-join-422606-zhs.html" target="_blank" rel="noopener">分解和合并：Java 也擅长轻松的并行编程！</a></li><li><a href="https://docs.oracle.com/javase/tutorial/essential/concurrency/forkjoin.html" target="_blank" rel="noopener">Fork/Join tutorial</a></li><li><a href="https://www.jianshu.com/p/f777abb7b251" target="_blank" rel="noopener">jdk1.8-ForkJoin框架剖析</a></li><li><a href="http://blog.dyngr.com/blog/2016/09/15/java-forkjoinpool-internals/" target="_blank" rel="noopener">Java 并发编程笔记：如何使用 ForkJoinPool 以及原理</a></li><li><a href="http://openjdk.java.net/projects/code-tools/jmh/" target="_blank" rel="noopener">Code Tools: jmh</a></li><li><a href="https://time.geekbang.org/column/article/40275" target="_blank" rel="noopener">基准测试框架JMH（上）</a></li><li><a href="https://time.geekbang.org/column/article/40281" target="_blank" rel="noopener">基准测试框架JMH（下）</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> JUC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> JUC </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Callable&amp;Future及FutureTask实现分析(JDK11)</title>
      <link href="/2018/10/13/Callable&amp;Future%E5%8F%8AFutureTask%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90(JDK11)/"/>
      <url>/2018/10/13/Callable&amp;Future%E5%8F%8AFutureTask%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90(JDK11)/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Callable"><a href="#Callable" class="headerlink" title="Callable"></a>Callable</h2><p>在Java中我们知道创建一个线程可以继承<code>Thread</code>类或者实现<code>Runnable</code>接口，JDK1.5之后在<code>java.util.concurrent</code>提供了<code>Callable</code>接口，该接口设计类似<code>Runnable</code>接口，不过<code>Callable</code>接口可以返回任务执行的结果，并且在执行任务过程中可能会抛出异常，而<code>Runnable</code>却不会。下面是<code>Callable</code>接口的定义：</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callable</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Computes a result, or throws an exception if unable to do so.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> computed result</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception if unable to compute a result</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">V <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Callable</code>接口中只定义了一个<code>call()</code>方法，该方法会返回一个计算结果，类型与传入的泛型一致。既然是接口，那么在哪里用到呢？下面是一个与<code>FutureTask</code>结合的例子，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallableTest</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException,</span></span><br><span class="line"><span class="function">        ExecutionException </span>&#123;</span><br><span class="line">        FutureTask&lt;String&gt; future = <span class="keyword">new</span> FutureTask&lt;&gt;(<span class="keyword">new</span> CallableTest());</span><br><span class="line">        <span class="keyword">new</span> Thread(future).start();</span><br><span class="line">        System.out.println(future.get());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以发现将 <code>Callable</code>的实现类传给<code>FutureTask</code>，然后利用线程来运行<code>FutureTask</code>，最终调用<code>get()</code>方法获取计算结果。</p><h2 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h2><p><code>FutureTask</code>是一个可取消的异步计算，该类提供了<code>Future</code>的基本实现，那么<code>Future</code>是怎么回事呢？<code>Future</code>接口提供了如下方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Future</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 试图取消此任务的执行。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> mayInterruptIfRunning)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果此任务在正常完成之前被取消，则返回true。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isCancelled</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果任务完成，返回true。完成可能是由于正常终止、异常或取消——在所有这些情况下，该方法将返回true。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isDone</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 等待计算完成，返回计算结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在给定的时间内等待计算完成，然后返回计算结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">V <span class="title">get</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Future</code>表示异步计算的结果，同时提供了用于检查计算是否完成、等待其完成以及检索计算结果的方法。下面是对这些方面的具体描述：</p><ul><li><code>cancel(boolean mayInterruptIfRunning)</code>：试图取消任务的执行。如果任务已经完成、已被取消或由于其他原因无法取消，则此尝试将失败。如果成功，并且在调用cancel时该任务尚未启动，则该任务永远不会运行。参数mayInterruptIfRunning表示是否允许取消正在执行却没有执行完毕的任务。在此方法返回后，对<code>isDone</code>的后续调用将始终返回<code>true</code>。如果该方法返回<code>true</code>，则对<code>isCancelled</code>的后续调用将始终返回<code>true</code>。</li><li><code>isCancelled</code> : 如果此任务在正常完成之前被取消，则返回true。</li><li><code>isDone</code>：如果任务完成，返回true。在正常终止、异常或取消情况下导致任务完成，该方法将返回true。</li><li><code>get</code>：等待计算完成，返回计算结果，期间会被阻塞。注意该方法会抛出异常，<ul><li>CancellationException - 如果计算被取消</li><li>ExecutionException - 如果在计算抛出异常</li><li>InterruptedException - 如果当前线程在等待时被中断</li></ul></li><li><code>get(long timeout, TimeUnit unit)</code>：在给定的时间内等待计算完成，然后返回计算结果。注意该方法也会抛出异常：<ul><li>CancellationException - 如果计算被取消</li><li>ExecutionException - 如果在计算抛出异常</li><li>InterruptedException - 如果当前线程在等待时被中断</li><li>TimeoutException - 等待超时</li></ul></li></ul><p>感觉<code>Future</code>的API设计的十分简洁明了，定义了对异步计算的常用操作，由于<code>Future</code>只是接口，刚才提到的<code>FutureTask</code>是JDK提供的一种实现，所以我们需要了解一下<code>Future</code>接口的方法是如何实现异步计算并拿到结果的。</p><h2 id="FutureTask"><a href="#FutureTask" class="headerlink" title="FutureTask"></a>FutureTask</h2><p><code>FutureTask</code>的类图如下所示，该类实现了<code>RunnableFuture</code><br>接口，<code>RunnableFuture</code>接口继承自<code>Runnable</code>和<code>Future</code>，所以该类既可以交给Thread去执行，又可以作为<code>Future</code>来获取计算结果。</p><p><img src="https://github.com/ZZULI-TECH/interview/blob/master/images/FutureTask_class.png?raw=true" alt="image"></p><h3 id="构造函数及state"><a href="#构造函数及state" class="headerlink" title="构造函数及state"></a>构造函数及state</h3><p>打开<code>FutureTask</code>类的源码，我们首先来看看其构造函数的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FutureTask</span><span class="params">(Callable&lt;V&gt; callable)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (callable == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">this</span>.callable = callable;</span><br><span class="line">    <span class="keyword">this</span>.state = NEW;       <span class="comment">// ensure visibility of callable</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FutureTask</span><span class="params">(Runnable runnable, V result)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.callable = Executors.callable(runnable, result);</span><br><span class="line">    <span class="keyword">this</span>.state = NEW;       <span class="comment">// ensure visibility of callable</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于第一个构造函数，传入Callable的实现类，将其赋给FutureTask成员变量<code>callable</code>，同时设置state为<code>NEW</code>，state字段用来保存FutureTask内部的任务执行状态，一共有7中状态，每种状态及其对应的值如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NEW          = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COMPLETING   = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NORMAL       = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EXCEPTIONAL  = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED    = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INTERRUPTING = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INTERRUPTED  = <span class="number">6</span>;</span><br></pre></td></tr></table></figure><p>注意state是用<code>volatile</code>修饰，保证其在线程之间的可见性。在源码注释中，我们可以发现state所代表状态转换如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NEW -&gt; COMPLETING -&gt; NORMAL</span><br><span class="line">NEW -&gt; COMPLETING -&gt; EXCEPTIONAL</span><br><span class="line">NEW -&gt; CANCELLED</span><br><span class="line">NEW -&gt; INTERRUPTING -&gt; INTERRUPTED</span><br></pre></td></tr></table></figure><p>用图表示如下：<br><img src="https://github.com/ZZULI-TECH/interview/blob/master/images/FutureTask_state_transitions.png?raw=true" alt="image"></p><p>从图中仿佛可以看出该类通过改变state的状态来反映最后计算的结果。</p><h3 id="run"><a href="#run" class="headerlink" title="run"></a>run</h3><p>在创建了一个FutureTask实例之后，接下来就是在另一个线程中执行此Task，无论是直接创建Thead还是通过线程池，执行的都是<code>run()</code>方法，该方法代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (state != NEW ||</span><br><span class="line">        !RUNNER.compareAndSet(<span class="keyword">this</span>, <span class="keyword">null</span>, Thread.currentThread()))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Callable&lt;V&gt; c = callable;</span><br><span class="line">        <span class="keyword">if</span> (c != <span class="keyword">null</span> &amp;&amp; state == NEW) &#123;</span><br><span class="line">            V result;</span><br><span class="line">            <span class="keyword">boolean</span> ran;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                result = c.call();</span><br><span class="line">                ran = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                result = <span class="keyword">null</span>;</span><br><span class="line">                ran = <span class="keyword">false</span>;</span><br><span class="line">                setException(ex);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (ran)</span><br><span class="line">                set(result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// runner must be non-null until state is settled to</span></span><br><span class="line">        <span class="comment">// prevent concurrent calls to run()</span></span><br><span class="line">        runner = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// state must be re-read after nulling runner to prevent</span></span><br><span class="line">        <span class="comment">// leaked interrupts</span></span><br><span class="line">        <span class="keyword">int</span> s = state;</span><br><span class="line">        <span class="keyword">if</span> (s &gt;= INTERRUPTING)</span><br><span class="line">            handlePossibleCancellationInterrupt(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在run方法中，首先会判断state是否等于<code>NEW</code>，如果不等于<code>NEW</code>，说明此任务已经被执行过，或者由于其他原因被取消了，直接返回；</p><p>接下来会利用CAS将该类<code>volatile</code>修饰的<code>runner</code>成员变量设置为当前线程，注意在设置之前<code>runner</code>必须为null，设置失败也直接返回。由于我看的版本是JDK11，所以这里的CAS操作用的是JDK9引入的<code>VarHandle</code>(方法句柄)，用来代替<code>UnSafe</code>类，详情参考：<a href="http://mingshan.me/2018/10/05/%E7%94%A8Variable%20Handles%E6%9D%A5%E6%9B%BF%E6%8D%A2Unsafe/">用Variable Handles来替换Unsafe</a>，在FutureTask类中实现代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// VarHandle mechanics</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> VarHandle STATE;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> VarHandle RUNNER;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> VarHandle WAITERS;</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        MethodHandles.Lookup l = MethodHandles.lookup();</span><br><span class="line">        STATE = l.findVarHandle(FutureTask.class, <span class="string">"state"</span>, <span class="keyword">int</span>.class);</span><br><span class="line">        RUNNER = l.findVarHandle(FutureTask.class, <span class="string">"runner"</span>, Thread.class);</span><br><span class="line">        WAITERS = l.findVarHandle(FutureTask.class, <span class="string">"waiters"</span>, WaitNode.class);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ReflectiveOperationException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ExceptionInInitializerError(e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Reduce the risk of rare disastrous classloading in first call to</span></span><br><span class="line">    <span class="comment">// LockSupport.park: https://bugs.openjdk.java.net/browse/JDK-8074773</span></span><br><span class="line">    Class&lt;?&gt; ensureLoaded = LockSupport.class;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>检测过<code>state</code>和<code>runner</code>后，接着会调用传入的callable的<code>call()</code>方法，执行任务。如果抛出异常，将结果设置为<code>null</code>，调用<code>setException()</code>方法保存异常信息，下面是代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">setException</span><span class="params">(Throwable t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (STATE.compareAndSet(<span class="keyword">this</span>, NEW, COMPLETING)) &#123;</span><br><span class="line">        outcome = t;</span><br><span class="line">        STATE.setRelease(<span class="keyword">this</span>, EXCEPTIONAL); <span class="comment">// final state</span></span><br><span class="line">        finishCompletion();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>setException</code>方法中，有以下流程：</p><ul><li>利用CAS操作将state状态由<code>NEW</code>改为<code>COMPLETING</code>，如果操作成功；</li><li>把异常原因保存在<code>outcome</code>字段中，<code>outcome</code>字段用来保存任务执行结果或者异常原因；</li><li>利用CAS把当前任务状态从<code>COMPLETING</code>变更为<code>EXCEPTIONAL</code>，可以参考上面转换的图；</li><li>调用<code>finishCompletion()</code>通知和移除等待线程</li></ul><p>如果没发生异常，任务执行结束，调用<code>set(result)</code>方法设置计算结果，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(V v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (STATE.compareAndSet(<span class="keyword">this</span>, NEW, COMPLETING)) &#123;</span><br><span class="line">        outcome = v;</span><br><span class="line">        STATE.setRelease(<span class="keyword">this</span>, NORMAL); <span class="comment">// final state</span></span><br><span class="line">        finishCompletion();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们发现<code>set()</code>方法实现流程和<code>setException()</code>真像，只不过是state状态变化的差异，流程如下：</p><ul><li>利用CAS操作将state状态由<code>NEW</code>改为<code>COMPLETING</code>，如果操作成功；</li><li>把计算结果保存在outcome字段中，outcome字段用来保存任务执行结果或者异常原因；</li><li>利用CAS把当前任务状态从<code>COMPLETING</code>变更为<code>NORMAL</code>，可以参考上面转换的图；</li><li>调用<code>finishCompletion()</code>通知和移除等待线程</li></ul><p>计算完后，无论是否发生异常，都要执行finally语句块的方法，首先将runner设置为<code>null</code>，释放值等待gc回收，同时判断state的状态是否为<code>INTERRUPTING</code>，如果任务被中断，执行中断处理。</p><p>看完了run方法的实现，总结来说，利用CAS根据任务的执行情况更改state的值，其他方法再根据state的值做出相应的处理。</p><h3 id="get"><a href="#get" class="headerlink" title="get"></a>get</h3><p>由于FutureTask是Future的一个实现，所以它提供了获取计算结果的<code>get()</code>方法，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> CancellationException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = state;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * state小于等于COMPLETING，表示计算任务还未完成，</span></span><br><span class="line"><span class="comment">     * 所以调用awaitDone方法，让当前线程等待</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (s &lt;= COMPLETING)</span><br><span class="line">        s = awaitDone(<span class="keyword">false</span>, <span class="number">0L</span>);</span><br><span class="line">    <span class="comment">// 返回计算结果或抛出异常</span></span><br><span class="line">    <span class="keyword">return</span> report(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>FutureTask运行在一个线程里来执行计算任务，由于Future设计的是异步计算模式，那么当然应该考虑其他线程获取计算的结果，从get方法看到，如果state的值如果小于等于<code>COMPLETING</code>，说明计算任务还没完成，那么获取计算结果的线程必须等待，也就是被阻塞，具体的实现在<code>awaitDone</code>方法里，该方法有两个参数，第一个参数为是否有超时限制timed，第二个为等待时间nanos，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">awaitDone</span><span class="params">(<span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// The code below is very delicate, to achieve these goals:</span></span><br><span class="line">    <span class="comment">// - call nanoTime exactly once for each call to park</span></span><br><span class="line">    <span class="comment">// - if nanos &lt;= 0L, return promptly without allocation or nanoTime</span></span><br><span class="line">    <span class="comment">// - if nanos == Long.MIN_VALUE, don't underflow</span></span><br><span class="line">    <span class="comment">// - if nanos == Long.MAX_VALUE, and nanoTime is non-monotonic</span></span><br><span class="line">    <span class="comment">//   and we suffer a spurious wakeup, we will do no worse than</span></span><br><span class="line">    <span class="comment">//   to park-spin for a while</span></span><br><span class="line">    <span class="keyword">long</span> startTime = <span class="number">0L</span>;    <span class="comment">// Special value 0L means not yet parked</span></span><br><span class="line">    WaitNode q = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">boolean</span> queued = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> s = state;</span><br><span class="line">        <span class="comment">// 计算已完成，直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (s &gt; COMPLETING) &#123;</span><br><span class="line">            <span class="keyword">if</span> (q != <span class="keyword">null</span>)</span><br><span class="line">                q.thread = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;<span class="comment">// 正在计算，让出时间片等待计算完成</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s == COMPLETING)</span><br><span class="line">            <span class="comment">// We may have already promised (via isDone) that we are done</span></span><br><span class="line">            <span class="comment">// so never return empty-handed or throw InterruptedException</span></span><br><span class="line">            Thread.yield();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">            <span class="comment">//  当前线程被中断（中断标志位为true），</span></span><br><span class="line">            <span class="comment">//  那么从列表中移除节点q，并抛出InterruptedException异常</span></span><br><span class="line">            removeWaiter(q);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125; <span class="comment">// 判断当前线程包装的等待节点是否为空</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (q == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果设置等待，但等待时间为0，直接返回</span></span><br><span class="line">            <span class="keyword">if</span> (timed &amp;&amp; nanos &lt;= <span class="number">0L</span>)</span><br><span class="line">                <span class="keyword">return</span> s;</span><br><span class="line">            <span class="comment">// 新建等待节点</span></span><br><span class="line">            q = <span class="keyword">new</span> WaitNode();</span><br><span class="line">        &#125;<span class="comment">// 判断是否入队</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!queued)</span><br><span class="line">            <span class="comment">//未入队时，使用CAS将新节点添加到链表中，如果添加失败，那么queued为false</span></span><br><span class="line">            queued = WAITERS.weakCompareAndSet(<span class="keyword">this</span>, q.next = waiters, q);</span><br><span class="line">        <span class="comment">// 判断是否设置超时</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (timed) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> parkNanos;</span><br><span class="line">            <span class="comment">// 第一次执行，初始化 startTime</span></span><br><span class="line">            <span class="keyword">if</span> (startTime == <span class="number">0L</span>) &#123; <span class="comment">// first time</span></span><br><span class="line">                startTime = System.nanoTime();</span><br><span class="line">                <span class="keyword">if</span> (startTime == <span class="number">0L</span>)</span><br><span class="line">                    startTime = <span class="number">1L</span>;</span><br><span class="line">                parkNanos = nanos;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 计算当前已用时间</span></span><br><span class="line">                <span class="keyword">long</span> elapsed = System.nanoTime() - startTime;</span><br><span class="line">                <span class="comment">// 如果当前已用时间大于设置的超时时间，移除队列中的结点，直接返回</span></span><br><span class="line">                <span class="keyword">if</span> (elapsed &gt;= nanos) &#123;</span><br><span class="line">                    removeWaiter(q);</span><br><span class="line">                    <span class="keyword">return</span> state;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 计算剩余时间</span></span><br><span class="line">                parkNanos = nanos - elapsed;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// nanoTime may be slow; recheck before parking</span></span><br><span class="line">            <span class="comment">// 挂起当前线程，让当前线程等待nanos时间</span></span><br><span class="line">            <span class="keyword">if</span> (state &lt; COMPLETING)</span><br><span class="line">                LockSupport.parkNanos(<span class="keyword">this</span>, parkNanos);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">// 未设置等待时间，那就等着吧</span></span><br><span class="line">            LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在FutureTask类中有一个成员变量<code>waiters</code>，声明如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Treiber stack of waiting threads */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> WaitNode waiters;</span><br></pre></td></tr></table></figure><p><code>WaitNode</code>是一个静态内部类，数据结构为单链表，用来记录等待的线程，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Simple linked list nodes to record waiting threads in a Treiber</span></span><br><span class="line"><span class="comment"> * stack.  See other classes such as Phaser and SynchronousQueue</span></span><br><span class="line"><span class="comment"> * for more detailed explanation.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">WaitNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">volatile</span> Thread thread;</span><br><span class="line">    <span class="keyword">volatile</span> WaitNode next;</span><br><span class="line">    WaitNode() &#123; thread = Thread.currentThread(); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的代码来看，在<code>awaitDone</code>方法内部存在着一个死循环，死循环内部流程如下：</p><ol><li>首先判断state的值，<ul><li>如果值大于<code>COMPLETING</code>，代表计算已完成（包括抛出异常等），直接返回；</li><li>如果值等于<code>COMPLETING</code>，代表正在执行计算，调用<code>Thread.yield()</code>让出时间片等待计算完成</li></ul></li><li>如果当前线程被中断（中断标志位为true），那么从列表中移除节点q，并抛出<code>InterruptedException</code>；</li><li>如果当前线程包装的等待节点为空，判断是否设置等待，并且等待时间为0，直接返回，否则创建等待节点；</li><li>如果没有入队，使用CAS将新节点添加到链表中，如果添加失败，那么queued为false</li><li>如果设置超时，判断当前计算任务是否在超时时间内，<ul><li>如果不在，移除队列中的结点，直接返回</li><li>如果在，计算剩余时间，挂起当前线程，让当前线程等待剩下的时间</li></ul></li><li>未设置等待时间，直接进行线程挂起操作，线程状态变为等待。</li></ol><p>当线程被解除挂起，或计算已经完成后，在<code>get</code>方法中将会调用<code>report</code>方法返回结果，其实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns result or throws exception for completed task.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> s completed state value</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="function"><span class="keyword">private</span> V <span class="title">report</span><span class="params">(<span class="keyword">int</span> s)</span> <span class="keyword">throws</span> ExecutionException </span>&#123;</span><br><span class="line">    Object x = outcome;</span><br><span class="line">    <span class="keyword">if</span> (s == NORMAL)</span><br><span class="line">        <span class="keyword">return</span> (V)x;</span><br><span class="line">    <span class="keyword">if</span> (s &gt;= CANCELLED)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> CancellationException();</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ExecutionException((Throwable)x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>如果state等于<code>NORMAL</code>，代表计算正常结束，返回结果；</li><li>如果state等于<code>CANCELLED</code>，代表计算被取消，抛出<code>CancellationException</code>；</li><li>如果计算以异常结束，即状态是<code>EXCEPTIONAL</code>，那么抛出<code>ExecutionException</code>。</li></ol><h3 id="finishCompletion"><a href="#finishCompletion" class="headerlink" title="finishCompletion"></a>finishCompletion</h3><p>在<code>run</code>方法中调用<code>set</code>和<code>setException</code>时最后一步是执行<code>finishCompletion</code>方法，那么这个方法是来干什么的呢？我们来看看它的实现吧：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Removes and signals all waiting threads, invokes done(), and</span></span><br><span class="line"><span class="comment"> * nulls out callable.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">finishCompletion</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert state &gt; COMPLETING;</span></span><br><span class="line">    <span class="keyword">for</span> (WaitNode q; (q = waiters) != <span class="keyword">null</span>;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (WAITERS.weakCompareAndSet(<span class="keyword">this</span>, q, <span class="keyword">null</span>)) &#123;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                Thread t = q.thread;</span><br><span class="line">                <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    q.thread = <span class="keyword">null</span>;</span><br><span class="line">                    LockSupport.unpark(t);</span><br><span class="line">                &#125;</span><br><span class="line">                WaitNode next = q.next;</span><br><span class="line">                <span class="keyword">if</span> (next == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                q.next = <span class="keyword">null</span>; <span class="comment">// unlink to help gc</span></span><br><span class="line">                q = next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    done();</span><br><span class="line"></span><br><span class="line">    callable = <span class="keyword">null</span>;        <span class="comment">// to reduce footprint</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>刚才我们看<code>get</code>方法的实现时，发现有一个<code>WaitNode</code>的单链表结构，里面存储着等待着的线程，所以在计算完成时，需要唤醒那些还在等待着的线程，毕竟计算任务都做完了（异常也算结束），总不能让那些阻塞的线程干等着吧，所以在<code>finishCompletion</code>方法中就遍历单链表，利用CAS将FutureTask中的waiters设置为<code>null</code>，调用<code>LockSupport.unpark</code>唤醒线程，当线程被释放后，那么在awaitDone的死循环中就会进入下一个循环，由于状态已经变成了<code>NORMAL</code>或者<code>EXCEPTIONAL</code>，将会直接跳出循环。</p><p>当所有等待线程都唤醒后，直接调用<code>done</code>方法，<code>done</code>方法是个<code>protected</code>修饰的方法，FutureTask没有做相关实现，所以如果在计算完成后需要特殊处理，子类可以重写<code>done</code>方法。</p><h3 id="cancel"><a href="#cancel" class="headerlink" title="cancel"></a>cancel</h3><p>从Future接口的描述来看，它提供了<code>cancel</code>方法来取消正在执行的任务，FutureTask实现了<code>cancel</code>方法，我们来看看它的代码吧：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> mayInterruptIfRunning)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!(state == NEW &amp;&amp; STATE.compareAndSet</span><br><span class="line">          (<span class="keyword">this</span>, NEW, mayInterruptIfRunning ? INTERRUPTING : CANCELLED)))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;    <span class="comment">// in case call to interrupt throws exception</span></span><br><span class="line">        <span class="keyword">if</span> (mayInterruptIfRunning) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread t = runner;</span><br><span class="line">                <span class="keyword">if</span> (t != <span class="keyword">null</span>)</span><br><span class="line">                    t.interrupt();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123; <span class="comment">// final state</span></span><br><span class="line">                STATE.setRelease(<span class="keyword">this</span>, INTERRUPTED);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        finishCompletion();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参数<code>mayInterruptIfRunning</code>指明是否应该中断正在运行的任务，</p><ul><li>如果参数为false，代表不需要中断，那么state的转换过程由<code>NEW-&gt;CANCELLED</code></li><li>如果参数为true，代表需要中断，那么state的转换过程将为<code>NEW-&gt;INTERRPUTING-&gt;INTERRUPTED</code>，并给当前线程设中断标志。</li></ul><p>无论是否中断，最终都会调用<code>finishCompletion()</code>方法来释放等待线程。</p><p>参考：</p><ul><li><a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/concurrent/Callable.html" target="_blank" rel="noopener">Callable DOC</a></li><li><a href="http://www.importnew.com/25286.html" target="_blank" rel="noopener">深入学习 FutureTask</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> JUC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> JUC </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>IDEA中Maven配置JDK11进行编译</title>
      <link href="/2018/10/13/IDEA%E4%B8%ADMaven%E9%85%8D%E7%BD%AEJDK11%E8%BF%9B%E8%A1%8C%E7%BC%96%E8%AF%91/"/>
      <url>/2018/10/13/IDEA%E4%B8%ADMaven%E9%85%8D%E7%BD%AEJDK11%E8%BF%9B%E8%A1%8C%E7%BC%96%E8%AF%91/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>前几天JDK11发布了不是，所以赶紧下载体验一番，我用的是IDEA编辑器(IntelliJ IDEA 2018.2.4 x64)，注意IDEA也要更新到最新版，用Maven编译的话需要进行相关配置，在此记录一下。</p><a id="more"></a><p>首先需要配置JDK的环境变量，配置好了显示如下：</p><p><img src="https://github.com/ZZULI-TECH/interview/blob/master/images/jdk11-version.png?raw=true" alt="image"></p><p>然后进入到IDEA中，配置项目使用的JDK版本，依次点击<code>File -&gt; Project Structure</code>，然后找到<code>Project SDK</code>选项，配置如下：</p><p><img src="https://github.com/ZZULI-TECH/interview/blob/master/images/jdk11-project-structure.png?raw=true" alt="image"></p><p>接下来配置Maven的JDK版本，点击<code>File -&gt; Settings -&gt; Build, Execution, Deployment -&gt; Build Tools -&gt; Maven</code>，然后选择<code>Runner</code>，配置Maven使用的JDK版本，配置页面如下：</p><p><img src="https://github.com/ZZULI-TECH/interview/blob/master/images/jdk11-maven-settings.png?raw=true" alt="image"></p><p>最后配置下maven的pom.xml文件，将目标编译版本改为JDK11，配置如下</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>11<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>11<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">finalName</span>&gt;</span>java11-tutorial<span class="tag">&lt;/<span class="name">finalName</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">source</span>&gt;</span>11<span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">target</span>&gt;</span>11<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><p>刷新maven项目，试着编译下，可以看到已经使用JDK11编译了：</p><p><img src="https://github.com/ZZULI-TECH/interview/blob/master/images/jdk11-build-output.png?raw=true" alt="image"></p><p>看下编译后的字节码的大小版本号，利用HexPad编辑器打开class文件，如下。可以看到minor_version为 0x0000, major_version为0x0037，而0x0037的十进制表示为55，即用jdk11编译的，准确无误。</p><p><img src="https://github.com/ZZULI-TECH/interview/blob/master/images/jdk11-class-version.png?raw=true" alt="image"></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>读过几本书，还是菜</title>
      <link href="/2018/10/07/%E8%AF%BB%E8%BF%87%E5%87%A0%E6%9C%AC%E4%B9%A6%EF%BC%8C%E8%BF%98%E6%98%AF%E8%8F%9C/"/>
      <url>/2018/10/07/%E8%AF%BB%E8%BF%87%E5%87%A0%E6%9C%AC%E4%B9%A6%EF%BC%8C%E8%BF%98%E6%98%AF%E8%8F%9C/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>以前喜欢买书来看，有空捧着一本书静静的读着，这种感觉仿佛时间都停止了，现在参加了工作，时间变得相对少些，所以看电子书的频率高些，因为电子书看着方便，但对眼睛有伤害，看时间长了会眼睛疲劳，不过能过看书的瘾，也挺好^_^</p><a id="more"></a><p>下面是我近几年来看过和正在看的亦准备看到的书籍列表，不过有些已经忘记了。这些书藏匿着我旧日的时光，看到这些书，仿佛看到了过去的自己，为了避免以后忘却那些美好的旧日时光，亦是不对过去的背弃，记录下来吧。。</p><p>一个好的作品藏着作者的大悲大痛，大彻大悟，即使是最平淡的文字，也能体会到作者对生活、人性的思考，世上的一切本就平凡真切，或得道弃俗，或坠入俗世，也是我们的世界啊。</p><p>书富如入海，百货皆有。人之精力，不能兼收尽取，但得春所欲求者尔。故愿学者每次作一意求之。 —— 苏轼 《东坡文集事略》</p><p><strong>历史类：</strong></p><p>当年明月，《明朝那些事》<br>卢志丹，《毛泽东读二十四史》<br>高晓松，《鱼羊野史（全集）》（未读完）<br>王晓磊，《卑鄙的圣人：曹操（全集）》<br>洪钊，《明朝十讲》<br>张鸣，《大历史的边角料》（未读完）<br>吕思勉，《三国史话》<br>黄仁宇，《万历十五年（精装版）》<br>朱东润，《张居正大传》</p><p><strong>古代哲学</strong></p><p>孔子，《论语》<br>李耳，《道德经》<br>庄周，《庄子》<br>王阳明，《传习录》</p><p><strong>古代史书（未读完）</strong></p><p>司马迁，《史记》<br>陈寿，《三国志》<br>司马光，《资治通鉴》<br>张廷玉，《明史》</p><p><strong>明清书籍</strong></p><p>金圣叹，《贯华堂选批唐才子诗》（在读）<br>刘鹗，《老残游记》<br>罗贯中，《三国演义》<br>袁枚，《子不语》<br>袁了凡，《了凡四训》<br>李淳风和袁天罡，《推背图（金圣叹批）》<br>吴趼人，《二十年目睹之怪现状》（在读）</p><p><strong>当代小说</strong></p><p>路遥，《平凡的世界》<br>路遥，《人生》<br>贾平凹，《商州》<br>贾平凹，《自在独行》（未读完）<br>慕容雪村，《多数人死于贪婪》<br>慕容雪村，《成都，今夜请将我遗忘》<br>慕容雪村，《天堂在左，深圳向右》<br>慕容雪村，《原谅我红尘颠倒》<br>刘瑜，《我在未来等你》<br>刘震云，《故乡天地黄花》<br>刘震云，《我叫刘跃进》<br>刘震云，《一句顶一万句》<br>余华，《许三观卖血记》（未读完）</p><p><strong>随笔散文</strong></p><p>路遥，《早晨从中午开始》<br>刘瑜，《送你一颗子弹》<br>黄仁宇，《地北天南叙古今（精装版）》（在读）<br>慕容雪村，《中国，少了一味药》<br>慕容雪村，《慕容雪村随笔集》<br>梁晓声，《中国人的日常》<br>王蒙，《一辈子的活法：王蒙的人生历练》（在读）</p><p><strong>科幻</strong></p><p>刘慈欣，《三体》</p><p><strong>外国文学</strong></p><p>培根，《培根随笔集》<br>圣埃克苏佩里，《小王子》（在读）</p><p><strong>技术书籍</strong></p><p>Joshua Bloch，《Effective Java 中文 第二版》<br>周志明，《深入理解Java虚拟机:JVM高级特性与最佳实践（第二版）》<br>刘欣，《码农翻身》<br>秦小波，《设计模式之禅》<br>啊哈磊，《啊哈！算法》</p><blockquote><p>—— 更新于2018/10/19</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 书籍 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Optional使用姿势</title>
      <link href="/2018/10/06/Optional%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF/"/>
      <url>/2018/10/06/Optional%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Optional类是在JDK8引入的比较有用的一个类，主要用来解决空指针（NullPointerException）问题，我们知道在平时写代码的时候，首先就要避免代码中出现空指针异常，如下面的代码：</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Blog&gt; blogs = ...;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> (blogs != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (Blog blog : blogs) &#123;</span><br><span class="line">        List&lt;Image&gt; images = blog.getImages();</span><br><span class="line">        <span class="keyword">if</span> (images != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当代码层数多的时候，这种代码看着是极其难受的，所在就引入了Optional，该类结合函数式编程进行链式调用，用着那是十分爽的^_^</p><p>首先来看看Optional类的API，截图如下：</p><p><img src="https://github.com/ZZULI-TECH/interview/blob/master/images/Optionals-api.png?raw=true" alt="image"></p><p>我们先来关心这个类暴露的API，下面列举出该类常用的方法的签名，如下：</p><ul><li>public<u> Optional<u> map(Function&lt;? super T, ? extends U&gt; mapper)</u></u></li><li>public T orElse(T other)</li><li>public T orElseGet(Supplier&lt;? extends T&gt; other)</li><li>public void ifPresent(Consumer&lt;? super T&gt; consumer)</li><li>public Optional<t> filter(Predicate&lt;? super T&gt; predicate)</t></li><li>public<u> Optional<u> flatMap(Function&lt;? super T, Optional<u>&gt; mapper)</u></u></u></li><li>public <x extends="" throwable=""> T orElseThrow(Supplier&lt;? extends X&gt; exceptionSupplier) throws X</x></li><li>public Stream<t> stream()</t></li><li>public void ifPresentOrElse(Consumer&lt;? super T&gt; action, Runnable emptyAction) </li><li>public Optional<t> or(Supplier&lt;? extends Optional&lt;? extends T&gt;&gt; supplier)</t></li></ul><p>看到<code>Function</code>、<code>Supplier</code>、<code>Consumer</code>，如果对函数式编程熟悉的话就会知道Optional这个类的大部分方法支持lambda表达式，该类是经过官方精心设计的，目的是简化代码，优雅编程，哈哈，我们来看看该怎么用。</p><h2 id="创建Optional实例"><a href="#创建Optional实例" class="headerlink" title="创建Optional实例"></a>创建Optional实例</h2><p>要使用Optional，首先就要有一个Optional的实例，现在有三种方法获得该类的实例，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;User&gt; user = Optional.empty()</span><br><span class="line">Optional&lt;User&gt; user = Optional.of(user)</span><br><span class="line">Optional&lt;User&gt; user = Optional.ofNullable(user)</span><br></pre></td></tr></table></figure><p>在该类的源码中，调用<code>empty()</code>方法会返回一个不带值的Optional实例。可以使用<code>of()</code> 和 <code>ofNullable()</code> 方法创建包含值的 Optional，区别是如果传入的值是<code>null</code>，<code>of()</code>方法会抛出空指针异常（NullPointerException），而<code>ofNullable()</code>会调用<code>empty()</code>方法，返回一个不带值的Optional实例。</p><p>看到这我们会有疑惑，该类不是要解决空指针异常吗，为什么还要向外暴露<code>of()</code>方法呢？官方把这个方法暴露出来可能考虑到使用者已经确定传入的参数不可能为<code>null</code>，但又想使用该类的其他的API；或者使用者想提前处理空指针异常，不想让空指针异常藏匿于Optional中，这也是一种设计上的考虑，只不过使用者要注意两个方法的异同，不要使用错误即可。</p><h2 id="orElse-orElseGet-orElseThrow"><a href="#orElse-orElseGet-orElseThrow" class="headerlink" title="orElse / orElseGet / orElseThrow"></a>orElse / orElseGet / orElseThrow</h2><p>现在我们有了Optional实例，接下来我们可以通过<code>get()</code>访问Optional实例的值，如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Optional.of(user).get();</span><br></pre></td></tr></table></figure><p>我们也可以利用<code>ifPresent()</code>来判断Optional实例所携带的值是否为<code>null</code>，我们一拍脑袋，就可以能写出如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;User&gt; user = Optional.ofNullable(user);</span><br><span class="line"><span class="keyword">if</span> (user.isPresent()) &#123;</span><br><span class="line">    User result = user.get();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码貌似没什么问题，但仔细思考一下，这样写和直接进行空值判断有什么区别？答案是没区别，因为这样用完全没有体现到Optional的特性，JDK的作者肯定也不希望你这样用。所以<code>orElse</code> 和 <code>orElseGet</code>这两个方法就出现了，将上面的代码改写下，如果传入的值为<code>null</code>，就返回一个自己传入的值，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">User user = <span class="keyword">null</span>;</span><br><span class="line">User u = createNewUser();</span><br><span class="line"><span class="comment">// 使用orElse</span></span><br><span class="line">User result = Optional.ofNullable(user).orElse(u);</span><br><span class="line">assertEquals(u, result);</span><br><span class="line"><span class="comment">// 使用orElseGet</span></span><br><span class="line">User result2 = Optional.ofNullable(user).orElseGet(() -&gt; createNewUser());</span><br><span class="line">assertEquals(user, result2);</span><br></pre></td></tr></table></figure><p>这里有一点要注意，无论传入的值是否为<code>null</code>，<code>orElse</code>都会执行，但<code>orElseGet</code>只有在传入的值为<code>null</code>时才会执行，这也是两者大的区别，在执行相对耗时的任务时，注意不要用错，否则这个差异会对性能产生重大影响。</p><p>如果传入的值为<code>null</code>时还有抛出其他异常的需要，就可以使用<code>orElseThrow</code>，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">User user = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">User result = Optional.ofNullable(user)</span><br><span class="line">        .orElseThrow(() -&gt; <span class="keyword">new</span> IllegalArgumentException());</span><br></pre></td></tr></table></figure><h2 id="map-flatMap-转换值"><a href="#map-flatMap-转换值" class="headerlink" title="map / flatMap 转换值"></a>map / flatMap 转换值</h2><p>现在我们已经可以根据传入值是否为<code>null</code>来返回不同的值了，而且没有空指针异常，但像下面的代码，我们需要对值进行多层转换，这时我们就需要用到<code>map</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(user != <span class="keyword">null</span>) &#123;</span><br><span class="line">    String name = user.getName();</span><br><span class="line">    <span class="keyword">if</span> (name != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> name.toLowerCase();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码经过转换后，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">return Optional.ofNullable(user)</span><br><span class="line">        .map(u -&gt; u.getName())</span><br><span class="line">        .map(name -&gt; name.toLowerCase())</span><br><span class="line">        .orElse(null);</span><br></pre></td></tr></table></figure><p>是不是既简洁又很帅？<code>map</code>方法通过传入的lambda表达式对值进行处理，然后将返回的值包装在 Optional 中，所以<code>map</code>方法可以多次调用，真的很好用。</p><p><code>map</code>方法是把结果自动封装成一个Optional，但是<code>flatmap</code>方法需要你自己去封装，这是两者的区别，<code>flatmap</code>方法相对来说比较灵活。</p><h2 id="filter-过滤"><a href="#filter-过滤" class="headerlink" title="filter 过滤"></a>filter 过滤</h2><p>Optional提供过滤值功能，调用<code>filter</code>方法时传入过滤条件，返回测试结果为true的值。如果测试结果为false，会返回一个空的Optional。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">User user = <span class="keyword">new</span> User(<span class="number">22</span>, <span class="string">"walker"</span>);</span><br><span class="line">Optional&lt;User&gt; result = Optional.ofNullable(user)</span><br><span class="line">        .filter(u -&gt; u.getName().contains(<span class="string">"w"</span>) &amp;&amp; u.getAge() &gt; <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">assertTrue(result.isPresent());</span><br></pre></td></tr></table></figure><h2 id="Java-SE-9-Optional类改进"><a href="#Java-SE-9-Optional类改进" class="headerlink" title="Java SE 9:Optional类改进"></a>Java SE 9:Optional类改进</h2><p>在JDK9中，对Optional类进行增强，增加了如下几个方法：</p><ul><li>stream()</li><li>ifPresentOrElse()</li><li>or()</li></ul><h3 id="stream"><a href="#stream" class="headerlink" title="stream"></a>stream</h3><p>现在Optional可以直接转为stream 流来进行处理，这样我们就可以利用Stream对象强大丰富的API来实现我们的逻辑，示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">User user = <span class="keyword">new</span> User(<span class="number">22</span>, <span class="string">"walker"</span>);</span><br><span class="line">User user2 = <span class="keyword">new</span> User(<span class="number">19</span>, <span class="string">"walker2"</span>);</span><br><span class="line">List&lt;User&gt; users = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">users.add(user);</span><br><span class="line">users.add(user2);</span><br><span class="line"></span><br><span class="line">List&lt;String&gt; names = Optional.ofNullable(users)</span><br><span class="line">    .stream()</span><br><span class="line">    .flatMap(x -&gt; x.stream())</span><br><span class="line">    .filter(u -&gt; u.getName().contains(<span class="string">"w"</span>) &amp;&amp; u.getAge() &gt; <span class="number">19</span>)</span><br><span class="line">    .map(u -&gt; u.getName())</span><br><span class="line">    .collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">names.stream().forEach(System.out::println);</span><br></pre></td></tr></table></figure><h3 id="ifPresentOrElse"><a href="#ifPresentOrElse" class="headerlink" title="ifPresentOrElse()"></a>ifPresentOrElse()</h3><p><code>ifPresentOrElse()</code>方法需要两个参数：一个 Consumer 和一个 Runnable。如果对象包含值，会执行 Consumer 的动作，否则运行 Runnable。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">User user = <span class="keyword">null</span>;</span><br><span class="line">Optional.ofNullable(user)</span><br><span class="line">    .ifPresentOrElse(u -&gt; System.out.print(u), () -&gt; System.out.println(<span class="string">"User not found"</span>));</span><br></pre></td></tr></table></figure><h3 id="or"><a href="#or" class="headerlink" title="or()"></a>or()</h3><p><code>or()</code> 方法与 <code>orElse()</code> 和 <code>orElseGet()</code> 类似，它们都在传入值为空的时候提供了替代情况。但<code>or()</code>的返回值是由 Supplier 参数产生的另一个 Optional 对象。示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">User user = <span class="keyword">null</span>;</span><br><span class="line">User result = Optional.ofNullable(user)</span><br><span class="line">    .or(() -&gt; Optional.of(<span class="keyword">new</span> User(<span class="number">23</span>, <span class="string">"xcc"</span>))).get();</span><br><span class="line">assertEquals(<span class="number">23</span>, result.getAge());</span><br></pre></td></tr></table></figure><h2 id="使用注意"><a href="#使用注意" class="headerlink" title="使用注意"></a>使用注意</h2><ol><li>调用<code>get()</code>注意要用<code>isPresent()</code>方法进行检测，否则会抛出异常</li><li>不要将Optional 类型用作属性或是方法参数，Optional 类型不可被序列化, 用作字段类型会出问题的</li><li>尽量进行链式调用，这也是简化我们代码的利器。</li></ol><p>参考：</p><ul><li><a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Optional.html" target="_blank" rel="noopener">Optional Doc</a></li><li><a href="https://www.nurkiewicz.com/2013/08/optional-in-java-8-cheat-sheet.html" target="_blank" rel="noopener">Optional in Java 8 cheat sheet</a></li><li><a href="https://www.cnblogs.com/zhangboyu/p/7580262.html" target="_blank" rel="noopener">理解、学习与使用 JAVA 中的 OPTIONAL</a></li><li><a href="https://yanbin.blog/proper-ways-of-using-java8-optional/" target="_blank" rel="noopener">使用 Java8 Optional 的正确姿势</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> Optional </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>用Variable Handles来替换Unsafe</title>
      <link href="/2018/10/05/%E7%94%A8Variable%20Handles%E6%9D%A5%E6%9B%BF%E6%8D%A2Unsafe/"/>
      <url>/2018/10/05/%E7%94%A8Variable%20Handles%E6%9D%A5%E6%9B%BF%E6%8D%A2Unsafe/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在JDK9中，包含了一个叫Variable Handles的新功能，下面是该功能的描述：</p><a id="more"></a><blockquote><p>Define a standard means to invoke the equivalents of various java.util.concurrent.atomic and sun.misc.Unsafe operations upon object fields and array elements, a standard set of fence operations for fine-grained control of memory ordering, and a standard reachability-fence operation to ensure that a referenced object remains strongly reachable.</p></blockquote><p>从这段官方描述中我们可以得知，Variable Handles主要是提供<code>java.util.concurrent.atomic</code> 和 <code>sun.misc.Unsafe</code>相似的功能，但会更加安全和易用，并且在并发方面提高了性能。在Java并发包中，由于包中的类大量调用<code>sun.misc.Unsafe</code>提供的功能，官方现在已不推荐再使用<code>sun.misc.Unsafe</code>这个类了，所以看看这个功能十分有必要，例如在<code>AtomicIntegerArray</code>这个类中已经用Variable Handles替换了<code>sun.misc.Unsafe</code>，并且在CAS中也会用到。</p><p>说到CAS的应用，我们需要对某一字段进行原子更新，可能会用到以下几种方式：</p><ol><li>使用AtomicInteger类来更新，但会带来额外的内存消耗以及因引用替换带来的新的并发问题；</li><li>使用Atomic*FieldUpdater类来完成字段的原子更新，其是基于反射来实现的，对字段和包装类型有一定的限制，操作开销比较大；</li><li>使用<code>sun.misc.Unsafe</code>提供的JVM内置函数API，这个类提供不安全的操作，损害安全性和移植性，官方不允许开发者使用，以后也会被替代掉。</li></ol><p>变量句柄是对变量的类型化引用，它支持在各种访问模式下对变量的读写访问。支持的变量类型包括实例字段、静态字段和数组元素。下面我们来看看它的基础API如何使用。</p><p>创建VarHandle需要通过<code>MethodHandles</code>这个类调用其静态方法来实现，根据要访问类的不同类型的成员变量调用不同的静态方法：</p><ul><li><code>MethodHandles.lookup</code> 访问类非私有属性</li><li><code>MethodHandles.privateLookupIn</code> 访问类的私有属性</li><li><code>MethodHandles.arrayElementVarHandle</code> 访问类中的数组</li></ul><p>获取到Lookup，然后通过调用<code>findVarHandle</code>方法来获取<code>VarHandle</code>实例，在JDK9中，</p><ul><li><code>findVarHandle</code>：用于创建对象中非静态字段的VarHandle。接收参数有三个，第一个为接收者的Class对象，第二个是字段名称，第三个是字段类型。</li><li><code>findStaticVarHandle</code>：用于创建对象中静态字段的VarHandle，接收参数与findVarHandle一致。</li><li><code>unreflectVarHandle</code>：通过反射字段创建VarHandle。</li></ul><p>为了保证效率，VarHandle类的实例通常需要被声明为static final变量（其实就是常量），这样可以在编译期对它进行优化。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> VarHandle VH_TEST_FIELD_I;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> VarHandle VH_TEST_ARRAY;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> VarHandle VH_TEST_FIELD_J;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> j = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        VH_TEST_FIELD_I = MethodHandles.lookup()</span><br><span class="line">                .in(Test.class)</span><br><span class="line">                .findVarHandle(Test.class, <span class="string">"i"</span>, <span class="keyword">int</span>.class);</span><br><span class="line"></span><br><span class="line">        VH_TEST_ARRAY = MethodHandles.arrayElementVarHandle(<span class="keyword">int</span>[].class);</span><br><span class="line"></span><br><span class="line">        VH_TEST_FIELD_J = MethodHandles.privateLookupIn(Test.class, MethodHandles.lookup())</span><br><span class="line">                .findVarHandle(Test.class, <span class="string">"j"</span>, <span class="keyword">int</span>.class);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ReflectiveOperationException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Error(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取到了<code>VarHandle</code>实例，接下来可以做些什么呢？<code>VarHandle</code>提供了几种访问模式（access modes）：</p><ol><li>read access modes, such as reading a variable with volatile memory ordering effects;</li><li>write access modes, such as updating a variable with release memory ordering effects;</li><li>atomic update access modes, such as a compare-and-set on a variable with volatile memory order effects for both read and writing;</li><li>numeric atomic update access modes, such as get-and-add with plain memory order effects for writing and acquire memory order effects for reading.</li><li>bitwise atomic update access modes, such as get-and-bitwise-and with release memory order effects for writing and plain memory order effects for reading.</li></ol><p>后面三个访问模式被称为 <code>read-modify-write</code>。从上面5个访问模式来看，主要包括普通变量读写、volatile变量读写和CAS操作。示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// read</span></span><br><span class="line">    System.out.println(VH_this_FIELD_I.get(<span class="keyword">this</span>)); <span class="comment">// 1</span></span><br><span class="line">    System.out.println(VH_this_ARRAY.get(arr, <span class="number">2</span>)); <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// write</span></span><br><span class="line">    VH_this_FIELD_I.set(<span class="keyword">this</span>, <span class="number">99</span>);</span><br><span class="line">    System.out.println(VH_this_FIELD_I.get(<span class="keyword">this</span>)); <span class="comment">// 99</span></span><br><span class="line"></span><br><span class="line">    VH_this_ARRAY.set(arr, <span class="number">2</span>, <span class="number">4</span>);</span><br><span class="line">    System.out.println(VH_this_ARRAY.get(arr, <span class="number">2</span>)); <span class="comment">// 4</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// CAS</span></span><br><span class="line">    System.out.println(VH_this_FIELD_I.compareAndSet(<span class="keyword">this</span>, <span class="number">99</span>, <span class="number">3</span>)); <span class="comment">// true</span></span><br><span class="line">    System.out.println(VH_this_FIELD_I.get(<span class="keyword">this</span>)); <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">    System.out.println(VH_this_ARRAY.compareAndSet(arr, <span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>)); <span class="comment">// true</span></span><br><span class="line">    System.out.println(VH_this_ARRAY.get(arr, <span class="number">2</span>)); <span class="comment">// 8</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Numeric Atomic Update</span></span><br><span class="line">    System.out.println(VH_this_FIELD_I.getAndAdd(<span class="keyword">this</span>, <span class="number">6</span>)); <span class="comment">// 3</span></span><br><span class="line">    System.out.println(VH_this_FIELD_I.get(<span class="keyword">this</span>)); <span class="comment">// 9</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了上面的五中访问模式外，在<a href="http://openjdk.java.net/jeps/193" target="_blank" rel="noopener">JEP 193</a>的描述中，还提供了一组内存屏障（Memory fences）方法，为内存排序提供更细粒度的控制。其中涉及到<code>memory order</code>的概念，与最近的c++ 11内存模型一致，详情请参考其相关概念。</p><p>在想要利用CAS去实现我们的逻辑，首先推荐使用VarHandle来实现，它提供了精细粒度的API，更加安全，相信在以后的产品中应用会非常广泛。</p><p>参考：</p><ul><li><a href="http://openjdk.java.net/jeps/193" target="_blank" rel="noopener">JEP 193: Variable Handles</a></li><li><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/invoke/VarHandle.html" target="_blank" rel="noopener">VarHandle Doc</a></li><li><a href="https://www.jianshu.com/p/e231042a52dd" target="_blank" rel="noopener">Java 9 变量句柄-VarHandle</a></li><li><a href="https://cloud.tencent.com/developer/article/1005903" target="_blank" rel="noopener">当我们在谈论 memory order 的时候，我们在谈论什么</a></li><li>杨晓峰，AtomicInteger底层实现原理是什么？如何在自己的产品代码中应用CAS操作？</li><li><a href="http://ifeve.com/memory-barriers-or-fences/" target="_blank" rel="noopener">内存屏障</a></li><li><a href="https://zh.cppreference.com/w/cpp/atomic/memory_order" target="_blank" rel="noopener">memory_order</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> VarHandle </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Use MethodHandles To Invoke</title>
      <link href="/2018/10/02/Use%20MethodHandles%20To%20Invoke/"/>
      <url>/2018/10/02/Use%20MethodHandles%20To%20Invoke/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在Java中，我们想在程序运行时调用其方法，可以用JDK提供的反射相关API来实现，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Class clazz = Demo.class;</span><br><span class="line">Method method = clazz.getMethod(<span class="string">"studyHard"</span>, <span class="keyword">new</span> Class[]&#123;String.class&#125;);</span><br><span class="line">Demo demo = clazz.newInstance();</span><br><span class="line">method.invoke(demo, <span class="string">"哈哈"</span>);</span><br></pre></td></tr></table></figure><a id="more"></a><p>这样的代码看起来也挺简洁，不过在JDK7之后，提供了<code>java.lang.invoke.MethodHandle</code>，它的功能与反射相似，下面是一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test1</span><span class="params">(<span class="keyword">int</span> a, String b)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"test1 -&gt; "</span> + a + b);</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">test2</span><span class="params">(<span class="keyword">int</span> a, String b)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"test2 -&gt; "</span> + a + b);</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        Class&lt;?&gt; clazz = Demo.class;</span><br><span class="line">        MethodType signature = MethodType.methodType(String.class, <span class="keyword">int</span>.class, String.class);</span><br><span class="line">        MethodHandle mh = MethodHandles.lookup().findVirtual(clazz, <span class="string">"test1"</span>, signature);</span><br><span class="line"></span><br><span class="line">        Object obj = clazz.getConstructor().newInstance();</span><br><span class="line">        System.out.println(mh.bindTo(obj).invoke(<span class="number">1</span>, <span class="string">"2"</span>));</span><br><span class="line">        System.out.println((String)mh.bindTo(obj).invokeExact(<span class="number">1</span>, <span class="string">"2"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//--------------静态方法</span></span><br><span class="line">        MethodHandle mh2 = MethodHandles.lookup().findStatic(clazz, <span class="string">"test2"</span>, signature);</span><br><span class="line">        System.out.println(mh.bindTo(obj).invoke(<span class="number">1</span>, <span class="string">"2"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从例子可以看出，我们先要通过<code>MethodType</code>来生成方法的签名，比如方法的参数类型，方法的返回值类型等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MethodType signature = MethodType.methodType(String.class, <span class="keyword">int</span>.class, String.class);</span><br></pre></td></tr></table></figure><p>有了方法的签名，我们就可以利用方法签名、方法名称以及该方法所在的类来获取方法句柄（MethodHandle），代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MethodHandle mh = MethodHandles.lookup().findVirtual(clazz, <span class="string">"test1"</span>, signature);</span><br></pre></td></tr></table></figure><p>此时需要MethodHandles.lookup()静态方法来查找上下文对象，查找上下文对象有一些以“find”开头的方法，例如，findVirtual()、findSpecial()、findStatic()等。这些方法将会返回实际的方法句柄。</p><p>MethodHandle要先bindTo到某个对象实例上，然后调用invoke方法，传入参数就可以调用了。注意还有一个invokeExact方法，该方法与invoke方法的区别是方法参数、返回值匹配非常严格，调用时如果有数值参数隐式转换（如short转int/子类转父类）、装箱拆箱，会直接抛异常。比如函数返回值没有强制转换为String类型，就会抛异常：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread <span class="string">"main"</span> java.lang.invoke.WrongMethodTypeException: expected (<span class="keyword">int</span>,String)<span class="function">String but <span class="title">found</span> <span class="params">(<span class="keyword">int</span>,String)</span>Object</span></span><br><span class="line"><span class="function">at java.base/java.lang.invoke.Invokers.<span class="title">newWrongMethodTypeException</span><span class="params">(Unknown Source)</span></span></span><br><span class="line"><span class="function">at java.base/java.lang.invoke.Invokers.<span class="title">checkExactType</span><span class="params">(Unknown Source)</span></span></span><br><span class="line"><span class="function">at MethodHandles/me.mingshan.demo.Demo.<span class="title">main</span><span class="params">(Demo.java:<span class="number">26</span>)</span></span></span><br></pre></td></tr></table></figure><p>从目前接触到的API来看，似乎和以前用的反射区别并不大，其实不然，上面的特性包含在<a href="https://jcp.org/en/jsr/detail?id=292" target="_blank" rel="noopener">JSR 292</a>中，提供了比反射API更加强大的动态方法调用能力，并且新增了一个java虚拟机指令<code>invokedynamic</code>，<code>invokedynamic</code>指令通过引导方法（bootstrap method，BSM）机制来使用方法句柄。有关该指令更详细的信息可以参考Java虚拟机规范。</p><p>另外，在JDK9中新增了<code>Variable Handles</code>（变量句柄）相关功能，主要是用来取代<code>java.util.concurrent.atomic</code>包以及<code>sun.misc.Unsafe</code>类的功能，在Lookup类中，新增了<code>findVarHandle</code>方法来获取变量句柄，提供了各种细粒度的原子或有序性操作，更加安全和性能更高，毕竟<code>sun.misc.Unsafe</code>以后不推荐使用了，不安全。</p><p>参考：</p><ul><li><a href="https://jcp.org/en/jsr/detail?id=292" target="_blank" rel="noopener">JSR 292</a></li><li><a href="https://zhuanlan.zhihu.com/p/28124632" target="_blank" rel="noopener">Invokedynamic：Java的秘密武器</a></li><li><a href="https://www.infoq.com/articles/Invokedynamic-Javas-secret-weapon" target="_blank" rel="noopener">Invokedynamic - Java’s Secret Weapon</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> MethodHandles </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>CAS小窥</title>
      <link href="/2018/10/01/CAS%E5%B0%8F%E7%AA%A5/"/>
      <url>/2018/10/01/CAS%E5%B0%8F%E7%AA%A5/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在JDK 1.5之后Java提供了并发包（<code>java.util.concurrent</code>）,加强对并发的支持。该包下的类大量使用 CAS（Compare and Swap）来实现原子操作、锁优化等。在<code>java.util.concurrent.atomic</code>包中，提供了对基本类型的原子封装，比如AtomicInteger，用来原子性访问和更新。我们十分熟悉的++i操作，在多线程环境下并非是线程安全的，因为它包含取值、相加与赋值三步操作，所以整体不是原子操作。</p><a id="more"></a><p>CAS是Java中所谓lock-free的基础。CAS有3个操作数，内存值V，旧的预期值A，要修改的新值B。当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做。CAS的描述如下（返回布尔值是为了让调用者知道是否更新成功）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">compareAndSwap</span><span class="params">(<span class="keyword">int</span> destValue, <span class="keyword">int</span> expectedValue, <span class="keyword">int</span> newValue)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (destValue == expectedValue) &#123;  </span><br><span class="line">        destValue = newValue;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么在JDK源码中是如何使用CAS的呢？我们先来看看AtomicInteger(JDK10)的源码实现。在JDK10版本中，CAS这部分操作是在<code>jdk.internal.misc.Unsafe</code>这个类中提供的，所以在AtomicInteger源码中，自增一是调用了Unsafe 的 getAndAddInt 方法。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> jdk.internal.misc.Unsafe U = jdk.internal.misc.Unsafe.getUnsafe();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> VALUE = U.objectFieldOffset(AtomicInteger.class, <span class="string">"value"</span>);</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> value;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">incrementAndGet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> U.getAndAddInt(<span class="keyword">this</span>, VALUE, <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>VALUE</code> 代表AtomicInteger对象value成员变量在内存中的偏移量，因为Unsafe是根据内存偏移地址获取数据的。<code>value</code>代表当前值，使用volatile修饰，保证多线程环境下值一致。</p><p>Unsafe这个类比较厉害，提供一些低级、不安全操作的方法， JDK不推荐我们直接调用这个类。下面getAndAddInt的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@HotSpotIntrinsicCandidate</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAddInt</span><span class="params">(Object o, <span class="keyword">long</span> offset, <span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        v = getIntVolatile(o, offset);</span><br><span class="line">    &#125; <span class="keyword">while</span> (!weakCompareAndSetInt(o, offset, v, v + delta));</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法的执行流程如下：</p><ol><li>假设现在有两个线程同时进入getAndAddInt方法, 主内存的value假设为2，根据Java内存模型，线程A和线程B各自持有一份value的副本，值为2；</li><li>线程A 执行<code>getIntVolatile(o, offset)</code>方法，拿到value值为2，线程A被挂起了；</li><li>线程B执行<code>getIntVolatile(o, offset)</code>方法，拿到value值为2， 接着执行<code>weakCompareAndSetInt(o, offset, v, v + delta)</code>方法，发现内存值和获取的值都是2，成功修改value的值为1；</li><li>线程A继续执行<code>weakCompareAndSetInt(o, offset, v, v + delta)</code>方法，发现自己获取的值2和内存中的值1不一样了，修改失败，继续循环执行</li><li>继续上面同样的操作，由于value被volatile修饰，所以此时线程A的value的副本就为1了，执行<code>getIntVolatile(o, offset)</code>方法，获取的值也为1，最后执行<code>weakCompareAndSetInt(o, offset, v, v + delta)</code>，直至成功修改value的值。</li></ol><p><code>weakCompareAndSetInt</code>最终调用<code>compareAndSetInt</code>方法，注意该方法为本地方法，如下。该方法有四个参数，分别是对象（这里是AtomicInteger）、对象的偏移地址、预期值、修改值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@HotSpotIntrinsicCandidate</span><br><span class="line">public final native boolean compareAndSetInt(Object o, long offset,</span><br><span class="line">                                             int expected,</span><br><span class="line">                                             int x);</span><br></pre></td></tr></table></figure><p>该方法根据操作系统的不同有不同的实现。在openjdk调用的c++代码为：<a href="https://github.com/unofficial-openjdk/openjdk/blob/4fb6d169db9c9732929ebbd5df01075b29105275/src/hotspot/share/prims/unsafe.cpp#L907" target="_blank" rel="noopener">unsafe.cpp</a>。。我也看不懂</p><p><strong>ABA问题</strong></p><p>从上面的分析可以看出，CAS涉及到修改值操作，如果一个值先被修改然后再修改为原值，那么就出现了ABA问题。具体流程如下：</p><ol><li>线程P1读取指定内存的值为A</li><li>线程P1被挂起，线程P2运行</li><li>线程P2将指定内存的值从A修改为B，再改回A。</li><li>再次调度到线程P1</li><li>线程P1发现指定内存的值没有变，于是继续执行。</li></ol><p><code>java.util.concurrent.atomic</code>包中，JDK提供了AtomicStampedReference，在该类中提供stamp来记录每次对值修改的操作，通过判断stamp来解决ABA问题的发生。示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用版本号解决CAS中的ABA问题。</span></span><br><span class="line"><span class="comment"> * 每一次修改都记录下版本号, 此版本号+1.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicStampedReferenceDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AtomicStampedReference&lt;Integer&gt; atomicStampedRef =</span><br><span class="line">            <span class="keyword">new</span> AtomicStampedReference&lt;Integer&gt;(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Thread main = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">"操作线程"</span> + Thread.currentThread() +<span class="string">", 初始值 a = "</span> </span><br><span class="line">                    + atomicStampedRef.getReference());</span><br><span class="line">            <span class="comment">// 获取当前Stamp</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> stamp = atomicStampedRef.getStamp();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 等待2秒 ，以便让干扰线程执行</span></span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 此时stamp已经被修改了, 所以CAS失败</span></span><br><span class="line">            <span class="keyword">boolean</span> isCASSuccess = atomicStampedRef.compareAndSet(<span class="number">1</span>, <span class="number">2</span>, stamp, stamp + <span class="number">1</span>);</span><br><span class="line">            System.out.println(<span class="string">"操作线程"</span> + Thread.currentThread() +<span class="string">", CAS操作结果: "</span> + isCASSuccess);</span><br><span class="line">        &#125;, <span class="string">"主操作线程"</span>);</span><br><span class="line"></span><br><span class="line">        Thread other = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// 干扰线程让出自己的cpu时间片，回到Runnable状态，让自己或主操作线程先执行</span></span><br><span class="line">            Thread.yield();</span><br><span class="line">            <span class="comment">// 加一</span></span><br><span class="line">            atomicStampedRef.compareAndSet(<span class="number">1</span>, <span class="number">2</span>, </span><br><span class="line">                    atomicStampedRef.getStamp(),atomicStampedRef.getStamp() + <span class="number">1</span>);</span><br><span class="line">            System.out.println(<span class="string">"操作线程"</span> + Thread.currentThread() + <span class="string">", 【increment】, Reference = "</span> </span><br><span class="line">                    + atomicStampedRef.getReference() + <span class="string">", Stamp = "</span> + atomicStampedRef.getStamp());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 然后减一</span></span><br><span class="line">            atomicStampedRef.compareAndSet(<span class="number">2</span>, <span class="number">1</span>, atomicStampedRef.getStamp(), </span><br><span class="line">                    atomicStampedRef.getStamp() + <span class="number">1</span>);</span><br><span class="line">            System.out.println(<span class="string">"操作线程"</span> + Thread.currentThread() + <span class="string">", 【decrement】, Reference = "</span> </span><br><span class="line">                    + atomicStampedRef.getReference() + <span class="string">", Stamp = "</span> + atomicStampedRef.getStamp());</span><br><span class="line">        &#125;, <span class="string">"干扰线程"</span>);</span><br><span class="line"></span><br><span class="line">        main.start();</span><br><span class="line">        other.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">操作线程Thread[主操作线程,5,main], 初始值 a = 1</span><br><span class="line">操作线程Thread[干扰线程,5,main], 【increment】, Reference = 2, Stamp = 1</span><br><span class="line">操作线程Thread[干扰线程,5,main], 【decrement】, Reference = 1, Stamp = 2</span><br><span class="line">操作线程Thread[主操作线程,5,main], CAS操作结果: false</span><br></pre></td></tr></table></figure><p><strong>Variable Handles</strong> </p><p>在JDK9之前，JDK源码中在进行CAS操作时需要调用<code>sun.misc.Unsafe</code>类native修饰的方法，该类由于涉及到底层操作被JDK视为不安全，不推荐使用，在以后的版本中会被逐渐替代，所以在JDK9引入了Variable Handles（变量句柄）这个概念，主要提供<code>java.util.concurrent.atomic</code> 和 <code>sun.misc.Unsafe</code>相似的功能，但会更加安全和易用，并且在并发方面提高了性能。详细参考<a href="https://github.com/ZZULI-TECH/interview/blob/master/source/java/base/VariableHandles.md" target="_blank" rel="noopener">Variable Handles（变量句柄）</a></p><p>参考：</p><ul><li><a href="https://en.wikipedia.org/wiki/Non-blocking_algorithm" target="_blank" rel="noopener">Non-blocking algorithm</a></li><li><a href="http://gee.cs.oswego.edu/dl/papers/aqs.pdf" target="_blank" rel="noopener">The java.util.concurrent Synchronizer Framework</a></li><li><a href="http://www.berlinix.com/dev/lock-free.php" target="_blank" rel="noopener">无锁程序设计</a></li><li><a href="https://www.cnblogs.com/kisty/p/5408264.html" target="_blank" rel="noopener">JAVA CAS原理深度分析</a></li><li><a href="https://www.jianshu.com/p/8b227a8adbc1" target="_blank" rel="noopener">JAVA中CAS-ABA的问题解决方案AtomicStampedReference</a></li><li>杨晓峰，AtomicInteger底层实现原理是什么？如何在自己的产品代码中应用CAS操作？</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> JUC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> JUC </tag>
            
            <tag> CAS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Arthas的使用并对JVM监控</title>
      <link href="/2018/09/21/Arthas%E7%9A%84%E4%BD%BF%E7%94%A8%E5%B9%B6%E5%AF%B9JVM%E7%9B%91%E6%8E%A7/"/>
      <url>/2018/09/21/Arthas%E7%9A%84%E4%BD%BF%E7%94%A8%E5%B9%B6%E5%AF%B9JVM%E7%9B%91%E6%8E%A7/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Arthas 是Alibaba开源的Java诊断工具，可以查看Java进程的一些信息，例如运行情况、JVM相关参数、线程等信息，采用命令行交互模式，在Linux用着十分方便。</p><a id="more"></a><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>在Linux系统中，首先创建一个文件下，然后在该文件下执行如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -L https://alibaba.github.io/arthas/install.sh | sh</span><br></pre></td></tr></table></figure><p>该命令会下载<code>as.sh</code>脚本，执行该脚本的用户需要和目标进程具有相同的权限。比如以admin用户来执行： sudo su admin &amp;&amp; ./as.sh 或 sudo -u admin -EH ./as.sh。 详细的启动脚本说明，请参考<a href="https://alibaba.github.io/arthas/start-arthas.html" target="_blank" rel="noopener">这里</a>。 如果attatch不上目标进程，可以查看~/logs/arthas/ 目录下的日志。</p><h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><p>接下来就需要执行<code>/as.sh</code>脚本，注意后面传入java 进程id</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:/usr/soft/arthas# ./as.sh 2616</span><br></pre></td></tr></table></figure><p>启动画面如下图所示：</p><p><img src="https://github.com/ZZULI-TECH/interview/blob/master/images/arthas-start.png?raw=true" alt="image"></p><p><strong>查看dashboard</strong></p><p>输入<code>dashboard</code>可以查看当前进程的信息、JVM内存使用情况，还可以看到当前操作系统和Java的版本信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">$ dashboard</span><br><span class="line">ID     NAME                  GROUP          PRIORI STATE   %CPU   TIME   INTERRU DAEMON </span><br><span class="line">16     nioEventLoopGroup-3-1 system         10     RUNNABL 76     0:0    false   false  </span><br><span class="line">21     Timer-for-arthas-dash system         10     RUNNABL 23     0:0    false   true   </span><br><span class="line">12     AsyncAppender-Worker- system         9      WAITING 0      0:0    false   true   </span><br><span class="line">10     Attach Listener       system         9      RUNNABL 0      0:0    false   true   </span><br><span class="line">9      Common-Cleaner        InnocuousThrea 8      TIMED_W 0      0:0    false   true   </span><br><span class="line">3      Finalizer             system         8      WAITING 0      0:0    false   true   </span><br><span class="line">2      Reference Handler     system         10     RUNNABL 0      0:0    false   true   </span><br><span class="line">4      Signal Dispatcher     system         9      RUNNABL 0      0:0    false   true   </span><br><span class="line">20     as-command-execute-da system         10     TIMED_W 0      0:0    false   true   </span><br><span class="line">14     job-timeout           system         9      TIMED_W 0      0:0    false   true   </span><br><span class="line">Memory             used  total max    usage GC                                          </span><br><span class="line">heap               18M   39M   233M   7.90% gc.copy.count         24                    </span><br><span class="line">tenured_gen        16M   27M   161M         gc.copy.time(ms)      107                   </span><br><span class="line">eden_space         2M    11M   64M    4.22% gc.marksweepcompact.c 2                     </span><br><span class="line">survivor_space     0K    1408K 8256K  0.00% ount                                        </span><br><span class="line">nonheap            23M   27M   -1                                                       </span><br><span class="line">Runtime                                                                                 </span><br><span class="line">os.name               Linux                                                             </span><br><span class="line">os.version            4.15.0-29-generic                                                 </span><br><span class="line">java.version          10.0.2                                                            </span><br><span class="line">java.home             /usr/package/jdk-10.0                                             </span><br><span class="line">                      .2</span><br></pre></td></tr></table></figure><p><strong>查看JVM信息</strong></p><p>输入<code>JVM</code>参数可以查看JVM相关信息，这对JVM调试有很大帮助。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">$ jvm</span><br><span class="line"> RUNTIME                                                                                </span><br><span class="line">----------------------------------------------------------------------------------------</span><br><span class="line"> MACHINE-NAME             2616@ubuntu                                                   </span><br><span class="line"> JVM-START-TIME           2018-09-20 20:19:32                                           </span><br><span class="line"> MANAGEMENT-SPEC-VERSION  2.0                                                           </span><br><span class="line"> SPEC-NAME                Java Virtual Machine Specification                            </span><br><span class="line"> SPEC-VENDOR              Oracle Corporation                                            </span><br><span class="line"> SPEC-VERSION             10                                                            </span><br><span class="line"> VM-NAME                  Java HotSpot(TM) 64-Bit Server VM                             </span><br><span class="line"> VM-VENDOR                &quot;Oracle Corporation&quot;                                          </span><br><span class="line"> VM-VERSION               10.0.2+13                                                     </span><br><span class="line"> INPUT-ARGUMENTS          []                                                            </span><br><span class="line"> CLASS-PATH               .:/usr/package/jdk-10.0.2/lib/                                </span><br><span class="line"> BOOT-CLASS-PATH                                                                        </span><br><span class="line"> LIBRARY-PATH             /usr/java/packages/lib:/usr/lib64:/lib64:/lib:/usr/lib        </span><br><span class="line">                                                                                        </span><br><span class="line">----------------------------------------------------------------------------------------</span><br><span class="line"> CLASS-LOADING                                                                          </span><br><span class="line">----------------------------------------------------------------------------------------</span><br><span class="line"> LOADED-CLASS-COUNT       2818                                                          </span><br><span class="line"> TOTAL-LOADED-CLASS-COUN  2818                                                          </span><br><span class="line"> T                                                                                      </span><br><span class="line"> UNLOADED-CLASS-COUNT     0                                                             </span><br><span class="line"> IS-VERBOSE               false                                                         </span><br><span class="line">                                                                                        </span><br><span class="line">----------------------------------------------------------------------------------------</span><br><span class="line"> COMPILATION                                                                            </span><br><span class="line">----------------------------------------------------------------------------------------</span><br><span class="line"> NAME                     HotSpot 64-Bit Tiered Compilers                               </span><br><span class="line"> TOTAL-COMPILE-TIME       3875(ms)                                                      </span><br><span class="line">                                                                                        </span><br><span class="line">----------------------------------------------------------------------------------------</span><br><span class="line"> GARBAGE-COLLECTORS                                                                     </span><br><span class="line">----------------------------------------------------------------------------------------</span><br><span class="line"> Copy                     25/110(ms)                                                    </span><br><span class="line"> [count/time]                                                                           </span><br><span class="line"> MarkSweepCompact         2/108(ms)                                                     </span><br><span class="line"> [count/time]                                                                           </span><br><span class="line">                                                                                        </span><br><span class="line">----------------------------------------------------------------------------------------</span><br><span class="line"> MEMORY-MANAGERS                                                                        </span><br><span class="line">----------------------------------------------------------------------------------------</span><br><span class="line"> CodeCacheManager         CodeHeap &apos;non-nmethods&apos;                                       </span><br><span class="line">                          CodeHeap &apos;profiled nmethods&apos;                                  </span><br><span class="line">                          CodeHeap &apos;non-profiled nmethods&apos;                              </span><br><span class="line">                                                                                        </span><br><span class="line"> Metaspace Manager        Metaspace                                                     </span><br><span class="line">                          Compressed Class Space                                        </span><br><span class="line">                                                                                        </span><br><span class="line"> Copy                     Eden Space                                                    </span><br><span class="line">                          Survivor Space                                                </span><br><span class="line">                                                                                        </span><br><span class="line"> MarkSweepCompact         Eden Space                                                    </span><br><span class="line">                          Survivor Space                                                </span><br><span class="line">                          Tenured Gen                                                   </span><br><span class="line">                                                                                        </span><br><span class="line">                                                                                        </span><br><span class="line">----------------------------------------------------------------------------------------</span><br><span class="line"> MEMORY                                                                                 </span><br><span class="line">----------------------------------------------------------------------------------------</span><br><span class="line"> HEAP-MEMORY-USAGE        41689088/16777216/245301248/18364616                          </span><br><span class="line"> [committed/init/max/use                                                                </span><br><span class="line"> d]                                                                                     </span><br><span class="line"> NO-HEAP-MEMORY-USAGE     32047104/7667712/-1/27755016                                  </span><br><span class="line"> [committed/init/max/use                                                                </span><br><span class="line"> d]                                                                                     </span><br><span class="line"> PENDING-FINALIZE-COUNT   0                                                             </span><br><span class="line">                                                                                        </span><br><span class="line">----------------------------------------------------------------------------------------</span><br><span class="line"> OPERATING-SYSTEM                                                                       </span><br><span class="line">----------------------------------------------------------------------------------------</span><br><span class="line"> OS                       Linux                                                         </span><br><span class="line"> ARCH                     amd64                                                         </span><br><span class="line"> PROCESSORS-COUNT         1                                                             </span><br><span class="line"> LOAD-AVERAGE             0.53                                                          </span><br><span class="line"> VERSION                  4.15.0-29-generic                                             </span><br><span class="line">                                                                                        </span><br><span class="line">----------------------------------------------------------------------------------------</span><br><span class="line"> THREAD                                                                                 </span><br><span class="line">----------------------------------------------------------------------------------------</span><br><span class="line"> COUNT                    14                                                            </span><br><span class="line"> DAEMON-COUNT             8                                                             </span><br><span class="line"> LIVE-COUNT               15                                                            </span><br><span class="line"> STARTED-COUNT            17                                                            </span><br><span class="line">Affect(row-cnt:0) cost in 42 ms.</span><br></pre></td></tr></table></figure><p><strong>class/classloader相关</strong></p><ul><li>sc——查看JVM已加载的类信息</li><li>sm——查看已加载类的方法信息</li><li>dump——dump 已加载类的 byte code 到特定目录</li><li>redefine——加载外部的.class文件，redefine到JVM里</li><li>jad——反编译指定已加载类的源码</li><li>classloader——查看classloader的继承树，urls，类加载信息，使用classloader去getResource</li></ul><p>详细参考：</p><ul><li><a href="https://alibaba.github.io/arthas/index.html" target="_blank" rel="noopener">Arthas Doc</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> Arthas </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>全限定名、简单名称和描述符是什么东西？</title>
      <link href="/2018/09/18/%E5%85%A8%E9%99%90%E5%AE%9A%E5%90%8D%E3%80%81%E7%AE%80%E5%8D%95%E5%90%8D%E7%A7%B0%E5%92%8C%E6%8F%8F%E8%BF%B0%E7%AC%A6%E6%98%AF%E4%BB%80%E4%B9%88%E4%B8%9C%E8%A5%BF%EF%BC%9F/"/>
      <url>/2018/09/18/%E5%85%A8%E9%99%90%E5%AE%9A%E5%90%8D%E3%80%81%E7%AE%80%E5%8D%95%E5%90%8D%E7%A7%B0%E5%92%8C%E6%8F%8F%E8%BF%B0%E7%AC%A6%E6%98%AF%E4%BB%80%E4%B9%88%E4%B8%9C%E8%A5%BF%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在看Class文件的结构时，我们会遇到这样几个概念，全限定名（Fully Qualified Name）、简单名称（Simple Name）和描述符（Descriptor），那么这些是什么东东呢？</p><a id="more"></a><p>首先来说全限定名，一个类的全限定名是将类全名的<code>.</code>全部替换为<code>/</code>，示例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">me/mingshan/cglib/SampleClass</span><br></pre></td></tr></table></figure><p>简单名称是指没有类型和参数修饰的方法或字段名称，比如一个类的test()方法，它的简单名称是<code>test</code>。</p><p>那么描述符是什么呢？下面是JVM规范的定义：</p><blockquote><p>A descriptor is a string representing the type of a field or method. </p></blockquote><p>注意描述符的概念是针对Java字节码的。描述符的作用是用来描述字段的数据类型、方法的参数列表（包括数量、类型以及顺序）和返回值。在JVM规范中，定义了两种类型的描述符，Field Descriptors 和 Method Descriptors。</p><p><strong>Field Descriptors</strong></p><blockquote><p>A field descriptor represents the type of a class, instance, or local variable.</p></blockquote><p>字段描述符包含BaseType、ObjectType、ArrayType三部分，对于基本数据类型(byte、char、double、float、int、long、short、boolean)都用一个大写字母来表示，而对象用字符L加对象的全限定名和<code>；</code>来表示，具体表示如下：</p><table><thead><tr><th>FieldType term</th><th>Type</th><th>Interpretation </th></tr></thead><tbody><tr><td>B</td><td>byte</td><td>signed byte</td></tr><tr><td>C</td><td>char</td><td>Unicode character code point in the Basic Multilingual Plane, encoded with UTF-16</td></tr><tr><td>D</td><td>double</td><td>double-precision floating-point value</td></tr><tr><td>F</td><td>float</td><td>single-precision floating-point value</td></tr><tr><td>I</td><td>int</td><td>integer</td></tr><tr><td>J</td><td>long</td><td>long integer</td></tr><tr><td>L ClassName ;</td><td>reference</td><td>an instance of class ClassName</td></tr><tr><td>S</td><td>short</td><td>signed short</td></tr><tr><td>Z</td><td>boolean</td><td>true or false</td></tr><tr><td>[</td><td>reference</td><td>one array dimension</td></tr></tbody></table><p>对于数组类型，每一个维度使用一个前置的<code>[</code>来描述，如一个定义为java.lang.String[][]类型的二维数组，将被记录为<code>[[Ljava/lang/String;</code>，一个double型数组<code>double[][][]</code>将被记录为<code>[[[D</code>。</p><p><strong>Method Descriptors</strong></p><blockquote><p>A method descriptor contains zero or more parameter descriptors, representing the types of parameters that the method takes, and a return descriptor, representing the type of the value (if any) that the method returns.</p></blockquote><p>方法描述符用来描述方法，一个方法既有参数，又有返回值，那么在用描述符描述方法时，按照先参数列表，后返回值的顺序描述。参数列表按照参数的严格顺序放在一组小括号<code>()</code>内，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">( &#123;ParameterDescriptor&#125; ) ReturnDescriptor</span><br></pre></td></tr></table></figure><p>注意如果返回值为void，那么就是一个大写字母<code>V</code>表示。</p><p>例如，一个方法的定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object m(int i, double d, Thread t) &#123;...&#125;</span><br></pre></td></tr></table></figure><p>那么它的描述符就是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(IDLjava/lang/Thread;)Ljava/lang/Object;</span><br></pre></td></tr></table></figure><p>又如方法的参数列表和返回值为空，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void test()</span><br></pre></td></tr></table></figure><p>它的描述符为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">()V</span><br></pre></td></tr></table></figure><p><strong>最后上代码分析一波</strong></p><p>我们新建Test类，包含一个成员变量和方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> me.mingshan.cglib;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> a;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">inc</span><span class="params">(<span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> c = a + b;</span><br><span class="line">        <span class="keyword">return</span> c + <span class="string">"666"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用<code>javap -c Test</code>来查看字节码，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class me.mingshan.cglib.Test &#123;</span><br><span class="line">  public me.mingshan.cglib.Test();</span><br><span class="line">    Code:</span><br><span class="line">       0: aload_0</span><br><span class="line">       1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">       4: return</span><br><span class="line"></span><br><span class="line">  public java.lang.String inc(int);</span><br><span class="line">    Code:</span><br><span class="line">       0: aload_0</span><br><span class="line">       1: getfield      #2                  // Field a:I</span><br><span class="line">       4: iload_1</span><br><span class="line">       5: iadd</span><br><span class="line">       6: istore_2</span><br><span class="line">       7: iload_2</span><br><span class="line">       8: invokedynamic #3,  0              // InvokeDynamic #0:makeConcatWithConstants:(I)Ljava/lang/String;</span><br><span class="line">      13: areturn</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到<code>Field a:I</code>和<code>(I)Ljava/lang/String;</code>， 没什么错^_^</p><p><strong>参考：</strong></p><ul><li><a href="https://docs.oracle.com/javase/specs/jls/se10/html/jls-6.html#jls-6.7" target="_blank" rel="noopener">jls</a></li><li><a href="https://docs.oracle.com/javase/specs/jvms/se10/html/jvms-4.html#jvms-4.3" target="_blank" rel="noopener">JVM Descriptor</a></li><li>深入理解Java虚拟机：JVM高级特性与最佳实践（第2版）</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>NIO之Channels</title>
      <link href="/2018/09/10/NIO~Channels/"/>
      <url>/2018/09/10/NIO~Channels/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Channel介绍"><a href="#Channel介绍" class="headerlink" title="Channel介绍"></a>Channel介绍</h2><p>Channel? 我们在使用Buffer的时候，需要往Buffer中放数据，再从Buffer中取数据，那么在NIO体系中，与Buffer交互是什么呢，没错，就是Channel。所有的NIO的I/O操作都是从Channel 开始的，读操作的时候将Channel中的数据填充到Buffer 中，而写操作时将Buffer中的数据写入到Channel中。</p><a id="more"></a><p>下面Channel的官方解释：</p><blockquote><p>A channel represents an open connection to an entity such as a hardware device, a file, a network socket, or a program component that is capable of performing one or more distinct I/O operations, for example reading or writing. As specified in the Channel interface, channels are either open or closed, and they are both asynchronously closeable and interruptible.</p></blockquote><p>在官方文档中，Channels根据不同的使用场景实现不一样，官方文档Channels可以在以下场景使用：</p><ul><li>File channels</li><li>Multiplexed, non-blocking I/O</li><li>Asynchronous I/O</li></ul><p>FileChannel类支持从连接到文件的通道中读取字节和将字节写入到通道。</p><p>多路复用、非阻塞I/O由<code>selector</code>、<code>selectable channels</code>和<code>SelectionKey</code>提供，它比阻塞I/O更具可伸缩性。</p><p>异步通道是一种能够进行异步I/O操作的特殊通道。异步通道是非阻塞的，并定义方法来启动异步操作，返回表示每个操作的Future。</p><p>目前使用较多Channel的实现类有：</p><ul><li>FileChannel：文件通道，用于文件的读和写</li><li>DatagramChannel：用于 UDP 连接的接收和发送</li><li>SocketChannel：TCP通道，用于TCP数据传输</li><li>ServerSocketChannel：用于监听服务端某个端口进来的TCP请求</li></ul><h2 id="FileChannel"><a href="#FileChannel" class="headerlink" title="FileChannel"></a>FileChannel</h2><p>Java针对支持通道的类提供了<code>getChannel()</code>方法来获取<code>FileChannel</code>，<code>FileChannel</code>是一个用来写、读、映射和操作文件的通道。下面是利用<code>FileChannel</code>读写文件的一个例子:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">FileInputStream fis = <span class="keyword">null</span>;</span><br><span class="line">FileOutputStream fos = <span class="keyword">null</span>;</span><br><span class="line">FileChannel inChannel = <span class="keyword">null</span>;</span><br><span class="line">FileChannel outChannel = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    fis = <span class="keyword">new</span> FileInputStream(<span class="string">"1.png"</span>);</span><br><span class="line">    fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"2.png"</span>);</span><br><span class="line">    <span class="comment">// 获取通道</span></span><br><span class="line">    inChannel = fis.getChannel();</span><br><span class="line">    outChannel = fos.getChannel();</span><br><span class="line">    <span class="comment">// 创建缓冲区</span></span><br><span class="line">    ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">    <span class="keyword">while</span> (inChannel.read(buffer) != -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 切换到读数据模式</span></span><br><span class="line">        buffer.flip();</span><br><span class="line">        <span class="comment">// 将缓冲区的内容写入通道</span></span><br><span class="line">        outChannel.write(buffer);</span><br><span class="line">        <span class="comment">// 清空缓冲区</span></span><br><span class="line">        buffer.clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (inChannel != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            inChannel.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (outChannel != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            outChannel.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (fis != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            fis.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fos != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            fos.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于FileChannel是抽象类，它的read、write和map通过其实现类FileChannelImpl实现，注意<br><a href="https://github.com/unofficial-openjdk/openjdk/blob/531ef5d0ede6d733b00c9bc1b6b3c14a0b2b3e81/src/java.base/share/classes/sun/nio/ch/FileChannelImpl.java" target="_blank" rel="noopener">FileChannelImpl</a>是在sun.nio.ch包中的，这里类需要在openjdk源码中看到，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(ByteBuffer dst)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    ensureOpen();</span><br><span class="line">    <span class="keyword">if</span> (!readable)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NonReadableChannelException();</span><br><span class="line">    <span class="keyword">synchronized</span> (positionLock) &#123;</span><br><span class="line">        <span class="keyword">if</span> (direct)</span><br><span class="line">            Util.checkChannelPositionAligned(position(), alignment);</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ti = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            beginBlocking();</span><br><span class="line">            ti = threads.add();</span><br><span class="line">            <span class="keyword">if</span> (!isOpen())</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                n = IOUtil.read(fd, dst, -<span class="number">1</span>, direct, alignment, nd);</span><br><span class="line">            &#125; <span class="keyword">while</span> ((n == IOStatus.INTERRUPTED) &amp;&amp; isOpen());</span><br><span class="line">            <span class="keyword">return</span> IOStatus.normalize(n);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            threads.remove(ti);</span><br><span class="line">            endBlocking(n &gt; <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">assert</span> IOStatus.check(n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个方法中，会检测通道是否可用，如果操作position和size，会进行同步处理，加上对象锁，然后调用<a href="https://github.com/unofficial-openjdk/openjdk/blob/531ef5d0ede6d733b00c9bc1b6b3c14a0b2b3e81/src/java.base/share/classes/sun/nio/ch/IOUtil.java" target="_blank" rel="noopener">IOUtil</a>类的read方法，注意是while循环，条件IOStatus是INTERRUPTED（系统底层调用中断？），在<a href="https://github.com/unofficial-openjdk/openjdk/blob/531ef5d0ede6d733b00c9bc1b6b3c14a0b2b3e81/src/java.base/share/classes/sun/nio/ch/IOStatus.java" target="_blank" rel="noopener">IOStatus</a>类中，定义了一些常量，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Native</span> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EOF = -<span class="number">1</span>;              <span class="comment">// End of file</span></span><br><span class="line"><span class="meta">@Native</span> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNAVAILABLE = -<span class="number">2</span>;      <span class="comment">// Nothing available (non-blocking)</span></span><br><span class="line"><span class="meta">@Native</span> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INTERRUPTED = -<span class="number">3</span>;      <span class="comment">// System call interrupted</span></span><br><span class="line"><span class="meta">@Native</span> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNSUPPORTED = -<span class="number">4</span>;      <span class="comment">// Operation not supported</span></span><br><span class="line"><span class="meta">@Native</span> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THROWN = -<span class="number">5</span>;           <span class="comment">// Exception thrown in JNI code</span></span><br><span class="line"><span class="meta">@Native</span> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNSUPPORTED_CASE = -<span class="number">6</span>; <span class="comment">// This case not supported</span></span><br></pre></td></tr></table></figure><p>IOUtil的代码如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">static int read(FileDescriptor fd, ByteBuffer dst, long position,</span><br><span class="line">                    boolean directIO, int alignment, NativeDispatcher nd)</span><br><span class="line">        throws IOException</span><br><span class="line">    &#123;</span><br><span class="line">        if (dst.isReadOnly())</span><br><span class="line">            throw new IllegalArgumentException(&quot;Read-only buffer&quot;);</span><br><span class="line">        if (dst instanceof DirectBuffer)</span><br><span class="line">            return readIntoNativeBuffer(fd, dst, position, directIO, alignment, nd);</span><br><span class="line"></span><br><span class="line">        // Substitute a native buffer</span><br><span class="line">        ByteBuffer bb;</span><br><span class="line">        int rem = dst.remaining();</span><br><span class="line">        if (directIO) &#123;</span><br><span class="line">            Util.checkRemainingBufferSizeAligned(rem, alignment);</span><br><span class="line">            bb = Util.getTemporaryAlignedDirectBuffer(rem, alignment);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            bb = Util.getTemporaryDirectBuffer(rem);</span><br><span class="line">        &#125;</span><br><span class="line">        try &#123;</span><br><span class="line">            int n = readIntoNativeBuffer(fd, bb, position, directIO, alignment,nd);</span><br><span class="line">            bb.flip();</span><br><span class="line">            if (n &gt; 0)</span><br><span class="line">                dst.put(bb);</span><br><span class="line">            return n;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            Util.offerFirstTemporaryDirectBuffer(bb);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上面的代码可以大致了解到，FileChannel读取数据过程如下：</p><ol><li>判断用户传入的buffer是否是DirectBuffer，如果是直接由readIntoNativeBuffer进行读取</li><li>如果不是（directIO为false），申请一块和缓存同大小的DirectByteBuffer bb</li><li>读取数据到缓存bb，底层由NativeDispatcher的read实现</li><li>把bb的数据读取到dst（用户定义的ByteBuffer，在jvm中分配内存）</li></ol><p>其他方法的具体实现细节可参考openjdk的代码，就不再分析了。</p><h2 id="ServerSocketChannel和SocketChannel"><a href="#ServerSocketChannel和SocketChannel" class="headerlink" title="ServerSocketChannel和SocketChannel"></a>ServerSocketChannel和SocketChannel</h2><p>ServerSocketChannel可以监听新进来的TCP连接，主要用于处理网络连接。对每一个新进来的连接都会创建一个SocketChannel。ServerSocketChannel可以被设置为阻塞或者非阻塞，</p><p>如果设置为阻塞，那么通道的读写等操作是阻塞的，该线程被阻塞，直到有一些数据被读取或写入，该线程在此期间不能执行其他任务</p><p>如果设置为非阻塞，那么读写请求并不会阻塞当前线程，在数据可读/写前当前线程可以继续做其它事情，所以一个单独的线程可以管理多个输入和输出通道。需要结合Selector使用。</p><p>下面仅介绍阻塞式的写法，非阻塞在Selector中详细探讨下。代码如下：</p><p>Server端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建通道</span></span><br><span class="line">ServerSocketChannel server = ServerSocketChannel.open();</span><br><span class="line"><span class="comment">// 绑定端口</span></span><br><span class="line">server.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">9898</span>));</span><br><span class="line">FileChannel outChannel = FileChannel.open(Paths.get(<span class="string">"2.png"</span>), StandardOpenOption.WRITE,StandardOpenOption.READ,StandardOpenOption.CREATE);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取客户端连接的通道</span></span><br><span class="line">SocketChannel socketChannel = server.accept();</span><br><span class="line"><span class="comment">// 分配指定大小的缓冲区</span></span><br><span class="line">ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接受客户端的数据，并保存到本地</span></span><br><span class="line"><span class="keyword">while</span>(socketChannel.read(buffer) != -<span class="number">1</span>)&#123;</span><br><span class="line">    buffer.flip();</span><br><span class="line">    outChannel.write(buffer);</span><br><span class="line">    buffer.clear();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭通道</span></span><br><span class="line">socketChannel.close();</span><br><span class="line">outChannel.close();</span><br><span class="line">server.close();</span><br></pre></td></tr></table></figure><p>通过上面代码我们可以总结下Server端的流程：</p><ol><li>创建ServerSocketChannel通道</li><li>绑定ip地址和端口号</li><li>通过ServerSocketChannel的accept()方法创建一个SocketChannel对象，用户从客户端读/写数据</li><li>创建读数据/写数据缓冲区对象来读取客户端数据或向客户端发送数据</li><li>关闭SocketChannel和ServerSocketChannel</li></ol><p>Client端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取通道</span></span><br><span class="line">SocketChannel client = SocketChannel.open(<span class="keyword">new</span> InetSocketAddress(<span class="string">"127.0.0.1"</span>, <span class="number">9898</span>));</span><br><span class="line"><span class="comment">// 获取文件</span></span><br><span class="line">FileChannel inChannel = FileChannel.open(Paths.get(<span class="string">"1.png"</span>), StandardOpenOption.READ);</span><br><span class="line">        </span><br><span class="line"><span class="comment">// 分配缓冲区</span></span><br><span class="line">ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取本地文件</span></span><br><span class="line"><span class="keyword">while</span> (inChannel.read(buffer) != -<span class="number">1</span>) &#123;</span><br><span class="line">    buffer.flip();</span><br><span class="line">    client.write(buffer);</span><br><span class="line">    buffer.clear();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭</span></span><br><span class="line">inChannel.close();</span><br><span class="line">client.close();</span><br></pre></td></tr></table></figure><p>总结下Client端的流程：</p><ol><li>获取SocketChannel，绑定ip和端口</li><li>创建读数据/写数据缓冲区对象来读取服务端数据或向服务端发送数据</li><li>关闭SocketChannel</li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://docs.oracle.com/javase/10/docs/api/java/nio/channels/package-summary.html" target="_blank" rel="noopener">JDK API</a></li><li><a href="https://segmentfault.com/a/1190000014869494" target="_blank" rel="noopener">Java NIO 之 Channel（通道）</a></li><li><a href="https://www.jianshu.com/p/052035037297" target="_blank" rel="noopener">深入浅出NIO之Channel、Buffer</a></li><li><a href="http://www.jasongj.com/java/nio_reactor/" target="_blank" rel="noopener">Java进阶（五）Java I/O模型从BIO到NIO和Reactor模式 </a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> NIO </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Class类文件结构简单分析</title>
      <link href="/2018/09/08/Class%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90/"/>
      <url>/2018/09/08/Class%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>代码编译的结果从本地机器码转变为字节码，是存储格式发展的一小步，却是编程语言的一大步。</p></blockquote><p>在Java平台中，实现语言无关性基础是虚拟机和存储格式。Java虚拟机不和Java等运行在其上的语言绑定，它只是与Class文件这种特殊的字节码文件所关联，每一个类文件包含单个类、接口或模块的定义。（JDK11）</p><a id="more"></a><h2 id="ClassFile的structure"><a href="#ClassFile的structure" class="headerlink" title="ClassFile的structure"></a>ClassFile的structure</h2><p>Class文件由一组8位字节为基础的二进制流。在最新的Java虚拟机规范中，Class文件由叫做ClassFile的structure组成。class文件结构在JVM占有重要地位，具体位于第四章，标题是“The class File Format”，总共五百多页的虚拟机规范，类文件结构就写了三百多页，是不是很可怕^_^</p><p>那么这个东西长什么样呢？如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ClassFile &#123;</span><br><span class="line">    u4 magic;</span><br><span class="line">    u2 minor_version;</span><br><span class="line">    u2 major_version;</span><br><span class="line">    u2 constant_pool_count;</span><br><span class="line">    cp_info constant_pool[constant_pool_count-1];</span><br><span class="line">    u2 access_flags;</span><br><span class="line">    u2 this_class;</span><br><span class="line">    u2 super_class;</span><br><span class="line">    u2 interfaces_count;</span><br><span class="line">    u2 interfaces[interfaces_count];</span><br><span class="line">    u2 fields_count;</span><br><span class="line">    field_info fields[fields_count];</span><br><span class="line">    u2 methods_count;</span><br><span class="line">    method_info methods[methods_count];</span><br><span class="line">    u2 attributes_count;</span><br><span class="line">    attribute_info attributes[attributes_count];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>咦？怎么这么像C语言的结构体呢，说的没错，虚拟机规范这是这么描述的(pseudostructures 伪结构)，刚才说了，它的真实结构是一组以8位字节为基础单位的二进制流，包含多个数据项，各个数据项严格按照顺序紧凑的排列在Class文件中（后面再进行分析）。下面我们来看看这个伪结构包含了什么。</p><p>从上面的伪结构来看，u2、u4是什么鬼？后面的看着像是属性，那么u2、u4似乎是类型的样子，呃，，没错，这种东西被称为数据类型，而且在<strong>伪结构中只有两种数据类型，无符号数（unsigned quantity）和表（table）</strong>。</p><p>无符号数属于基本的数据类型，u2、u4分别代表2个字节、4个字节的无符号数。无符号数可以用来描述数字、索引引用、数量值或者按照UTF-8编码的字符串。</p><p>那么<code>cp_info</code>、<code>field_info</code>、<code>method_info</code>和<code>attribute_info</code>就是所谓的table了，可以看出都是以<code>_info</code>结尾，这些存些什么数据呢？在一个类中，总有字段吧，那么就存到<code>field_info</code>里面，总有些方法吧，存到<code>method_info</code>，或许还会有常量什么的，存到<code>cp_info</code>里面，在Class文件、字段表、方法表都可以携带自己的attribute_info，用于描述某些场景专有的信息。</p><p>说完了伪结构的数据类型，uX和*_info后面那些类似字段名称的东西是什么意思呢？在虚拟机规范中，被称作<code>item</code>，原话这么说的：</p><blockquote><p> the contents of the structures describing the class file format are<br>referred to as items</p></blockquote><p>好吧，不知道叫啥，就叫item吧，大家知道就行了(￣.￣)。</p><p>在介绍上面的<code>items</code>之前，我们先来一个简单的Java类编译后的Class的十六进制文件，源代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">inc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用<code>javac</code>编译后，我选择Hexpad这个编辑器来打开class文件，如下：</p><p><img src="https://github.com/ZZULI-TECH/interview/blob/master/images/class_16.png?raw=true" alt="image"></p><h2 id="magic与class文件的版本"><a href="#magic与class文件的版本" class="headerlink" title="magic与class文件的版本"></a>magic与class文件的版本</h2><p><strong>magic</strong></p><p>每个Class文件的头四个字节被称为魔数（Magic Number），默认值为<code>0xCAFEBABE</code>，用于确定一个文件是否能被JVM接受。</p><p><strong>minor_version, major_version</strong></p><p>紧接着四个字节就是<code>minor_version</code>和<code>major_version</code>，看着像是版本号的意思，没错，这四个字节存储的是Class文件的版本号，第5和6个字节存储的是次版本号（Minor Version），第7个和8个字节存储的是主版本号（Major Version）。由上面的图片可知，<code>minor_version</code>为0x0000，<code>major_version</code>为0x0036，转为是十进制为54，即我用JDK10编译的。下面为各个版本JVM能接受Class文件版本号的范围：</p><table><thead><tr><th>Java SE</th><th>class file format version range</th></tr></thead><tbody><tr><td>1.0.2</td><td>45.0 ≤ v ≤ 45.3</td></tr><tr><td>1.1</td><td>45.0 ≤ v ≤ 45.65535</td></tr><tr><td>1.2</td><td>45.0 ≤ v ≤ 46.0</td></tr><tr><td>1.3</td><td>45.0 ≤ v ≤ 47.0</td></tr><tr><td>1.4</td><td>45.0 ≤ v ≤ 48.0</td></tr><tr><td>5.0</td><td>45.0 ≤ v ≤ 49.0</td></tr><tr><td>6</td><td>45.0 ≤ v ≤ 50.0</td></tr><tr><td>7</td><td>45.0 ≤ v ≤ 51.0</td></tr><tr><td>8</td><td>45.0 ≤ v ≤ 52.0</td></tr><tr><td>9</td><td>45.0 ≤ v ≤ 53.0</td></tr><tr><td>10</td><td>45.0 ≤ v ≤ 54.0</td></tr><tr><td>11</td><td>45.0 ≤ v ≤ 55.0</td></tr></tbody></table><h2 id="constant-pool-count，constant-pool"><a href="#constant-pool-count，constant-pool" class="headerlink" title="constant_pool_count，constant_pool[]"></a>constant_pool_count，constant_pool[]</h2><p><strong>constant_pool_count</strong></p><p>接着主版本号之后是常量池容量计数值（constant_pool_count），由于常量池中常量的数量是不固定的，所以需要一个u2类型的数据来统计。注意该值计数从1开始而不是0。如上图所示，constant_pool_count值为0x0013，转为十进制为19，这就代表常量池中有18项常量，索引值范围为1~18（1 ~ constant_pool_count - 1）。</p><p>可能此时会有疑问，为啥我一个常量没定义，常量池这么多常量呢？有这个疑问就对了，原因是常量池中不仅存放<code>static final</code>修饰的字段，这个被称作字面量（Literal），还包括符号引用（Symbolic References），在虚拟机规范中是这样写的：</p><blockquote><p>constants, class and interface names, field names, and other constants that are<br>referred to within the ClassFile structure and its substructures. </p></blockquote><p>符号引用具体包括哪些呢？如下：</p><ul><li>类和接口的全限定名</li><li>字段的名称和描述符</li><li>方法的名称和描述符</li></ul><h2 id="access-flags"><a href="#access-flags" class="headerlink" title="access_flags"></a>access_flags</h2><p>在常量池结束之后，紧接着2个字节表示访问标志（access_flags），这个标志用于识别一些类和接口层次的访问信息。具体列表如下：</p><table><thead><tr><th>Flag Name</th><th>Value</th><th>Interpretation</th></tr></thead><tbody><tr><td>ACC_PUBLIC</td><td>0x0001</td><td>Declared public; may be accessed from outside its package.</td></tr><tr><td>ACC_FINAL</td><td>0x0010</td><td>Declared final; no subclasses allowed.</td></tr><tr><td>ACC_SUPER</td><td>0x0020</td><td>Treat superclass methods specially when invoked by the invokespecial instruction.</td></tr><tr><td>ACC_INTERFACE</td><td>0x0200</td><td>Is an interface, not a class.</td></tr><tr><td>ACC_ABSTRACT</td><td>0x0400</td><td>Declared abstract; must not be instantiated.</td></tr><tr><td>ACC_SYNTHETIC</td><td>0x1000</td><td>Declared synthetic; not present in the source code.</td></tr><tr><td>ACC_ANNOTATION</td><td>0x2000</td><td>Declared as an annotation type.</td></tr><tr><td>ACC_ENUM</td><td>0x4000</td><td>Declared as an enum type.</td></tr><tr><td>ACC_MODULE</td><td>0x8000</td><td>Is a module, not a class or interface.</td></tr></tbody></table><p><strong>ACC_MODULE</strong></p><p>需要注意ACC_MODULE，这个是新增的，ACC_MODULE标志表示这个Class文件定义了一个模块，而不是一个类或接口。</p><p><strong>ACC_SUPER</strong></p><p>在jdk1.02之前，有个叫invokenonvirtual的指令。在1.02后，这个指令被改名叫做invokespecial。invokenonvirtual的时候没有invokespecial那样只允许调用superclass、private方法或<init>方法。于是在所有的1.02后的class 都必须设置ACC_SUPER这个标志，来表明强加给invokespecial的新的约束必须要被遵守。</init></p><h2 id="this-class-super-class-interfaces-count-interfaces"><a href="#this-class-super-class-interfaces-count-interfaces" class="headerlink" title="this_class, super_class, interfaces_count, interfaces[]"></a>this_class, super_class, interfaces_count, interfaces[]</h2><p>this_class（类索引）、super_class（父类索引）都是一个u2类型的数据，而interfaces（接口索引集合）是一组u2类型的数据集合。Class文件由这三项来确定这个类的继承关系。</p><p><strong>this_class（类索引）和 super_class（父类索引）</strong></p><p>类索引和父类索引表示，它们各自指向一个类型为CONSTANT_Class_info的类描述符常量，通过CONSTANT_Class_info类型的常量中的索引值可以找到定义在CONSTANT_Utf8_info类型的常量的全限定名字符串。大致如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this_class  -&gt;  CONSTANT_Class_info  -&gt; CONSTANT_Utf8_info</span><br></pre></td></tr></table></figure><p><strong>interfaces_count（接口计数器）</strong></p><p>这个项的值表示当前类或接口的直接超接口的数量。</p><p><strong>interfaces[] （接口表）</strong></p><p>就是这个类所实现的接口。里边同样是常量池的索引值。接口表里边的顺序和源代码的接口顺序是一致的。</p><h2 id="fields-count，fields"><a href="#fields-count，fields" class="headerlink" title="fields_count，fields[]"></a>fields_count，fields[]</h2><p>field_info（字段表）用于描述接口或者类中声明的变量。fields表中只包含当前类或接口中的字段，不包含超类或super 接口中的字段，也不包括在方法内部声明的局部变量。</p><h2 id="methods-count，methods"><a href="#methods-count，methods" class="headerlink" title="methods_count，methods[]"></a>methods_count，methods[]</h2><p>method_info用来表示当前类或接口中的某个方法的完整描述。</p><h2 id="attributes-count-attributes"><a href="#attributes-count-attributes" class="headerlink" title="attributes_count, attributes[]"></a>attributes_count, attributes[]</h2><p>在Class文件、字段表、方法表都可以携带自己的attribute_info，用于描述某些场景专有的信息。</p><p>参考：</p><ul><li><a href="https://docs.oracle.com/javase/specs/jvms/se11/jvms11.pdf" target="_blank" rel="noopener">The Java® Virtual Machine Specification (Java SE 11 Edition)</a></li><li>深入理解Java虚拟机：JVM高级特性与最佳实践（第2版）</li><li><a href="https://mp.weixin.qq.com/s/e3_5okrgFTctBTikRuJvhA" target="_blank" rel="noopener">来自JVM的一封ClassFile介绍信</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>NIO之Buffers</title>
      <link href="/2018/08/29/NIO~Buffers/"/>
      <url>/2018/08/29/NIO~Buffers/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Buffer？我们很容易想到缓冲区的概念，在NIO中，它是直接和Channel打交道的缓冲区，通常场景或是从Buffer写入Channel，或是从Channel读入Buffer。Buffer是一个抽象类，Java提供如下图的实现类，我是直接在Eclipse截出来的^_^</p><a id="more"></a><p><img src="https://github.com/ZZULI-TECH/interview/blob/master/images/buffer_impl.png?raw=true" alt="image"></p><p>其实核心是ByteBuffer，除了布尔类型，所有原始类型都有相应的Buffer实现，只是包装了一下ByteBuffer而已，我们使用最多的通常是ByteBuffer。</p><p>我们应该将Buffer理解为一个数组，IntBuffer、CharBuffer、DoubleBuffer 等分别对应int[]、char[]、double[]等。</p><p>上图没有包括MappedByteBuffer，该类用户内存映射文件，放到最后再说吧。</p><p>Buffer有四个重要的属性，分别为：mark、position、limit、capacity，和两个重要方法分别为：flip和clear。Buffer的底层存储结构为数组。这四个属性有以下特点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mark &lt;= position &lt;= limit &lt;= capacity</span><br></pre></td></tr></table></figure><p>那么这几个属性分别起着什么作用呢？下面的介绍都以ByteBuffer为例，来分析ByteBuffer的使用流程和原理。</p><p>下面是这四个属性的简单介绍：</p><ul><li>capacity ：缓冲区的容量大小</li><li>limit ：界限，表示缓冲区可以操作数据的大小。 （limit后数据不能进行读写）</li><li>position: 位置，代表下一次的写入位置，初始值是 0，每往 Buffer 中写入一个值，position 就自动加 1</li><li>mark : 标记，表示记录当前position 的位置可以通过reset()来恢复到 mark的位置，初始为 -1</li></ul><p>对ByteBuffer操作主要包括读和写，向缓冲区写入数据和从缓冲区读取数据会影响以上四个属性的值的变化，我们分别对读和写以及之间切换进行分析。</p><p><strong>写操作</strong></p><p>首先分配1024字节的缓冲区，然后向缓冲区放入5字节的字符串“abcde”，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">String str=&quot;abcde&quot;;</span><br><span class="line"></span><br><span class="line">// 分配一个指定大小的缓冲区</span><br><span class="line">ByteBuffer buffer=ByteBuffer.allocate(1024);</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;---------allocate------&quot;);</span><br><span class="line">System.out.println(buffer.position());</span><br><span class="line">System.out.println(buffer.limit());</span><br><span class="line">System.out.println(buffer.capacity());</span><br><span class="line"></span><br><span class="line">// 利用put() 向缓冲区放数据</span><br><span class="line">buffer.put(str.getBytes());</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;--------放数据------&quot;);</span><br><span class="line">System.out.println(buffer.position());</span><br><span class="line">System.out.println(buffer.limit());</span><br><span class="line">System.out.println(buffer.capacity());</span><br></pre></td></tr></table></figure><p>初始化position，limit，capacity位置如下图所示</p><p><img src="https://github.com/ZZULI-TECH/interview/blob/master/images/bytebuffer_init.png?raw=true" alt="image"></p><p>我们发现position为0，而limit和capacity均指向内存区域最大位置，代表此时缓存区内是空的，已放入capacity大小的数据。</p><p>当我们向缓冲区放入5个字节的数据，position，limit，capacity位置发生了变化，如下图所示</p><p><img src="https://github.com/ZZULI-TECH/interview/blob/master/images/bytebuffer_put.png?raw=true" alt="image"></p><p>从上图可以看出，在写入数据后，position会向后移动5个位置，指向第六个位置，代表下次写数据的位置，limit和capacity没有改变。</p><p><strong>切换到读操作</strong></p><p>由写模式切换到读模式需要调用<code>flip</code>方法，这个方法是什么意思呢？在JDK源码中，此方法的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">flip</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    limit = position;</span><br><span class="line">    position = <span class="number">0</span>;</span><br><span class="line">    mark = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码中我们可以清晰的看出，limit被设置为当前position的大小，position归0，mark还是为默认值-1，我们还是看图比较直观，如下图所示：</p><p><img src="https://github.com/ZZULI-TECH/interview/blob/master/images/bytebuffer_flip.png?raw=true" alt="image"></p><p>和上一张图片进行对比，我们可以发现limit替换了position的位置，代表当前可以操作的位置，在写的时候，limit的值代表最大的可写位置，在读的时候，limit的值代表最大的可读位置。很明显我们现在是要读数据，就代表最大可读位置。</p><p><strong>读操作</strong></p><p>通过filp方法切换为读模式后，我们就可以从缓存区里面读取数据，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从缓冲区读数据</span></span><br><span class="line"><span class="keyword">byte</span>[] dst=<span class="keyword">new</span> <span class="keyword">byte</span>[buffer.limit()];</span><br><span class="line">buffer.get(dst);</span><br><span class="line">System.out.println(<span class="string">"------读取数据-------"</span>);</span><br><span class="line">System.out.println(<span class="keyword">new</span> String(dst,<span class="number">0</span>,dst.length));</span><br><span class="line"></span><br><span class="line">System.out.println(buffer.position());</span><br><span class="line">System.out.println(buffer.limit());</span><br><span class="line">System.out.println(buffer.capacity());</span><br></pre></td></tr></table></figure><p>此时position，limit，capacity位置如下图所示</p><p><img src="https://github.com/ZZULI-TECH/interview/blob/master/images/bytebuffer_read.png?raw=true" alt="image"></p><p>从上图可以看出，position的位置变成了5，由于我们将缓存区里面的数据读完了，就是这个情况，所以读操作的时候，每读一个值，position 就自动加 1。在HeapByteBuffer源码中，就是增加一个offset的偏移量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">ix</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> i + offset;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>重复读数据</strong></p><p>上一步读数据的操作已经将position移动了limit的位置，我们想读数据就读不到了，但能不能重复读取数据呢？肯定可以呀，这时我们就可以用<code>rewind</code>方法来重复读写，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//rewind  可重复读数据</span></span><br><span class="line">buffer.rewind();</span><br><span class="line">System.out.println(<span class="string">"------重复读取数据-------"</span>);</span><br><span class="line">System.out.println(buffer.position());</span><br><span class="line">System.out.println(buffer.limit());</span><br><span class="line">System.out.println(buffer.capacity());</span><br></pre></td></tr></table></figure><p>此时position，limit，capacity位置如下图所示</p><p><img src="https://github.com/ZZULI-TECH/interview/blob/master/images/bytebuffer_rewind.png?raw=true" alt="image"></p><p>有没有发现和flip操作后一致，此时肯定要一样了，这样我们才可以重复读取。</p><p><strong>清空缓冲区</strong></p><p>此时我们不想要缓冲区的数据了，需要清空掉，可以用<code>clear</code>方法来操作，代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 清空缓冲区，缓冲区的数据仍然存在，但处于被遗忘的状态，不能被读取</span></span><br><span class="line">buffer.clear();</span><br><span class="line">System.out.println(<span class="string">"------清空缓冲区-------"</span>);</span><br><span class="line">System.out.println(buffer.position());</span><br><span class="line">System.out.println(buffer.limit());</span><br><span class="line">System.out.println(buffer.capacity());</span><br></pre></td></tr></table></figure><p>此时position，limit，capacity位置如下图所示</p><p><img src="https://github.com/ZZULI-TECH/interview/blob/master/images/bytebuffer_clear.png?raw=true" alt="image"></p><p>注意缓冲区的数据仍然存在，但处于被遗忘的状态，不能被读取</p><p><strong>mark() &amp; reset()</strong></p><p>除了 position、limit、capacity 这三个基本的属性外，还有一个常用的属性就是 mark。</p><p>mark 用于临时保存 position 的值，每次调用 mark() 方法都会将 mark 设值为当前的 position，便于后续需要的时候使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">mark</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mark = position;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那到底什么时候用呢？考虑以下场景，我们在 position 为 5 的时候，先 mark() 一下，然后继续往下读，读到第 10 的时候，我想重新回到 position 为 5 的地方重新来一遍，那只要调一下 reset() 方法，position 就回到 5 了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">reset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = mark;</span><br><span class="line">    <span class="keyword">if</span> (m &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InvalidMarkException();</span><br><span class="line">    position = m;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>rewind() &amp; clear() &amp; compact()</strong></p><p>rewind()：会重置 position 为 0，通常用于重新从头读写 Buffer。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">rewind</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    position = <span class="number">0</span>;</span><br><span class="line">    mark = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>clear()：有点重置 Buffer 的意思，相当于重新实例化了一样。</p><p>通常，我们会先填充 Buffer，然后从 Buffer 读取数据，之后我们再重新往里填充新的数据，我们一般在重新填充之前先调用 clear()。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    position = <span class="number">0</span>;</span><br><span class="line">    limit = capacity;</span><br><span class="line">    mark = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>compact()：和 clear() 一样的是，它们都是在准备往 Buffer 填充新的数据之前调用。</p><p>前面说的 clear() 方法会重置几个属性，但是我们要看到，clear() 方法并不会将 Buffer 中的数据清空，只不过后续的写入会覆盖掉原来的数据，也就相当于清空了数据了。</p><p>而 compact() 方法有点不一样，调用这个方法以后，会先处理还没有读取的数据，也就是 position 到 limit 之间的数据（还没有读过的数据），先将这些数据移到左边，然后在这个基础上再开始写入。很明显，此时 limit 还是等于 capacity，position 指向原来数据的右边。</p><p><strong>参考：</strong></p><ul><li><a href="http://www.importnew.com/28007.html" target="_blank" rel="noopener">Java NIO：Buffer、Channel 和 Selector</a></li><li><a href="https://docs.oracle.com/javase/10/docs/api/java/nio/package-summary.html" target="_blank" rel="noopener">NIO API</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> NIO </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>SpringBoot应用被系统Kill相关问题分析</title>
      <link href="/2018/08/25/SpringBoot%E5%BA%94%E7%94%A8%E8%A2%AB%E7%B3%BB%E7%BB%9FKill%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/"/>
      <url>/2018/08/25/SpringBoot%E5%BA%94%E7%94%A8%E8%A2%AB%E7%B3%BB%E7%BB%9FKill%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>SpringBoot在启动的时候，有默认的JVM启动参数，在部署到Linux服务器上时，如果Linxus内存不够时，会导致应用被操作系统kill掉，导致部署的服务莫名其妙的挂掉，就我遇到的项目而言，记录SpringBoot的log如下：</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">2018-08-23 07:53:25.231  INFO [demo,,,,] 1 --- [           main] cn.com.superv.provider.Application       : Started Application in 5.655 seconds (JVM running for 6.124)</span><br><span class="line">2018-08-23 07:55:02.080  INFO [demo,,,,] 1 --- [       Thread-3] ConfigServletWebServerApplicationContext : Closing org.springframework.boot.web.servlet.context.AnnotationConfigServletWebServerApplicationContext@19dfb72a: startup date [Thu Aug 23 07:53:20 GMT 2018]; root of context hierarchy</span><br><span class="line">2018-08-23 07:55:02.087  INFO [demo,,,,] 1 --- [       Thread-3] o.s.c.support.DefaultLifecycleProcessor  : Stopping beans in phase 2147483647</span><br><span class="line">2018-08-23 07:55:02.087  INFO [demo,,,,] 1 --- [       Thread-3] o.s.j.e.a.AnnotationMBeanExporter        : Unregistering JMX-exposed beans on shutdown</span><br><span class="line">2018-08-23 07:55:02.088  INFO [demo,,,,] 1 --- [       Thread-3] o.s.j.e.a.AnnotationMBeanExporter        : Unregistering JMX-exposed beans</span><br><span class="line">2018-08-23 07:55:02.099  INFO [demo,,,,] 1 --- [       Thread-3] com.alibaba.druid.pool.DruidDataSource   : &#123;dataSource-1&#125; closed</span><br></pre></td></tr></table></figure><p>才开始我以为代码写错了，导致应用启动崩溃，但我这个应用在另一台Linux机器上跑的挺好的，没有出现上面的问题。其中log中有以下日志：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Unregistering JMX-exposed beans on shutdown</span><br><span class="line">Unregistering JMX-exposed beans</span><br></pre></td></tr></table></figure><p>在网上查的信息说SpringBoot内嵌的Tomcat无法正常启动才导致这个错误，结合这个项目在其他机器上能运行，就排除了Tomcat的问题。后来我想想会不会是跟Linux内存有关系呢？我赶紧用<code>top</code>命令查看了服务器的内存的使用情况，我檫，16G的内存只剩下三百多兆了，看来是我项目运行的时候请求内存导致系统内存不足，被系统kill掉。这时可以用<code>jinfo -flags &lt;pid&gt;</code>命令来查看当前应用的JVM参数。运行 <code>dmesg | grep &quot;(java)&quot;</code>命令看看是不是操作系统把我的应用给干掉了，结果屏幕输入类似如下日志：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Out of memory: Kill process[PID] [process name] score</span><br></pre></td></tr></table></figure><p>这又是什么意思呢？好像是内存溢出被操作系统干掉了，所以一查，还真是Out of memory 问题，这通常是因为某时刻应用程序大量请求内存导致系统内存不足造成的，这通常会触发 Linux 内核里的 Out of Memory (OOM) killer，OOM killer会杀掉某个进程以腾出内存留给系统用，不致于让系统立刻崩溃。详细原因分析参考：<a href="http://www.111cn.net/sys/CentOS/84755.htm" target="_blank" rel="noopener">linux 终端报错 Out of memory: Kill process[PID] [process name] score问题分析</a></p><p>我在网上发现一哥们和我遇到了一样的问题，链接：<a href="https://blog.csdn.net/qq_35981283/article/details/62233725" target="_blank" rel="noopener">项目连续几天突然挂掉</a>，不过他的比较严重，可能刚开始没有整明白这个问题发生的原因，内心慌乱，其实仔细分析就可以查到问题发生的蛛丝马迹，从而解决问题。</p><p>找到问题发生的原因，接下来就要思考如何解决了。既然是内存的问题，那我们来改变下JVM参数，将最大堆内存(<code>-Xmx</code>)调小点，并禁止伸缩，将<code>-Xms</code>和<code>-Xmx</code>设置一样大，项目就可以运行了，<code>-Xmx</code>和<code>-Xms</code>具体值根据服务器内存和项目运行占用内存进行优化设置。</p><p>另外这个问题我在用Docker启动SpringBoot应用中也遇到过，利用<code>docker ps</code>命令可以发现该容器正在运行，但外界就是无法通过开放的端口来访问，利用命令<code>docker logs -f container-id</code>来查看容器启动的log，发现日志和上述的一样，所以也需要设置JVM参数, 命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -e JAVA_OPTS=&apos;-Xmx512m&apos; -p 8080:8080 -t springboot/spring-boot-docker</span><br></pre></td></tr></table></figure><p>最后推荐一个JVM调优相关的网站： <a href="http://xxfox.perfma.com/" target="_blank" rel="noopener">一只懂JVM参数的狐狸</a>，非常好用，可以查看JVM参数介绍以及变迁，还可以根据机器生成推荐JVM参数，真好用啊^_^</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> java </tag>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Docker容器传递Spring Profile</title>
      <link href="/2018/08/22/Docker%E5%AE%B9%E5%99%A8%E5%90%AF%E7%94%A8Spring%20Profiles/"/>
      <url>/2018/08/22/Docker%E5%AE%B9%E5%99%A8%E5%90%AF%E7%94%A8Spring%20Profiles/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>我们在利用Docker启动SpringBoot应用时，需要在启动时指定Profile来确定运行环境，如果再需要指定其他参数，参数的传递就十分有必要了。下面是stackoverflow关于这方面的讨论，链接如下：</p><a id="more"></a><p><a href="https://stackoverflow.com/questions/46715072/passing-env-variables-to-docker-spring-boot" target="_blank" rel="noopener">Passing env variables to DOCKER Spring Boot</a></p><p><strong>通过Dockerfile定义Spring Profile</strong></p><p>通常在命令行中我们可以使用<code>java -jar</code> 运行 Spring Boot应用。<br>而Profiles信息可以作为额外参数传递，比如<code>-Dspring.profiles.active=dev</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Djava.security.egd=file:/dev/./urandom -Dspring.profiles.active=dev -jar app.jar</span><br></pre></td></tr></table></figure><p>相似的，我们可以在Dockerfile中将Profile的信息作为参数传递进去，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FROM openjdk:8-jdk-alpine</span><br><span class="line">VOLUME /tmp</span><br><span class="line">ADD spring-boot-docker-0.0.1-SNAPSHOT.jar app.jar</span><br><span class="line">ENTRYPOINT [&quot;java&quot;, &quot;-Djava.security.egd=file:/dev/./urandom&quot;,&quot;-Dspring.profiles.active=dev&quot;,&quot;-jar&quot;,&quot;/app.jar&quot;]</span><br></pre></td></tr></table></figure><p>需要注意最后的ENTRYPOINT一行，在这行中我们传递java命令以执行jar文件，所有需要的参数和值以逗号方式分隔传递。<br><code>-Dspring.profiles.active=dev</code> 是我们定义dev profile的地方，我们可以替换dev为任何需要的名字。</p><p><strong>通过Docker run命令定义Spring Profile</strong></p><p>可以将spring profile作为环境变量传递给docker run命令，使用 -e 标记。<br>例如<code>-e “SPRING_PROFILES_ACTIVE=dev”会将dev profile</code>传递给Docker容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 8080:8080 -e &quot;SPRING_PROFILES_ACTIVE=dev&quot; --name rest-api dockerImage:latest</span><br></pre></td></tr></table></figure><p>Dockerfile中改为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ENTRYPOINT [&quot;java&quot;, &quot;-Djava.security.egd=file:/dev/./urandom&quot;,&quot;-Dspring.profiles.active=$&#123;SPRING_PROFILES_ACTIVE&#125;&quot;,&quot;-jar&quot;,&quot;/app.jar&quot;]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JDK中的反射</title>
      <link href="/2018/08/19/JDK%E4%B8%AD%E7%9A%84%E5%8F%8D%E5%B0%84/"/>
      <url>/2018/08/19/JDK%E4%B8%AD%E7%9A%84%E5%8F%8D%E5%B0%84/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>反射是Java语言中一个比较重要的特性，它允许对正在运行的Java进行观测，甚至动态修改程序，即在运行态，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性。</p><a id="more"></a><h2 id="反射API介绍"><a href="#反射API介绍" class="headerlink" title="反射API介绍"></a>反射API介绍</h2><h3 id="获取Class对象"><a href="#获取Class对象" class="headerlink" title="获取Class对象"></a>获取Class对象</h3><p>通常来说，使用反射API的第一步是获取Class对象，在Java中比较常见的有以下几种：</p><ol><li>已知具体的类，通过类的class属性获取，对于基本类型来说，它们的包装类型（wrapper classes）拥有一个名为“TYPE”的final静态字段，指向该基本类型对应的Class对象</li><li>已知某个类的实例，调用对象的getClass()方法获取Class对象</li><li>已知一个类的全类名，使用静态方法Class.forName来获取</li></ol><p>例如，Integer.TYPE 指向 int.class。对于数组类型来说，可以使用类名 +“[ ].class”来访问，如 int[ ].class。</p><p>除此之外，Class 类和 java.lang.reflect 包中还提供了许多返回 Class 对象的方法。例如，对于数组类的 Class 对象，调用 Class.getComponentType() 方法可以获得数组元素的类型。</p><p>我们还可以利用自定义Classloader来加载我们的类，然后可以获取到该类的Class对象。类似于下面的代码，注意代码可能会抛出异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MyClassLoader classLoader = <span class="keyword">new</span> MyClassLoader(workspace + <span class="string">"/src/me/mingshan"</span>);</span><br><span class="line">Class&lt;?&gt; proxy0Class = classLoader.findClass(<span class="string">"$Proxy0"</span>);</span><br></pre></td></tr></table></figure><h3 id="其他操作"><a href="#其他操作" class="headerlink" title="其他操作"></a>其他操作</h3><p>拿到Class对象后，我们可以进行很多操作，比如生成该类的实例，访问字段的值，调用方法等。</p><h4 id="生成类的实例"><a href="#生成类的实例" class="headerlink" title="生成类的实例"></a>生成类的实例</h4><p>通过类的Class对象可以生成类的实例，有两种方式</p><ol><li>调用的是无参数的构造函数进行实例化</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clazz.newInstance();</span><br></pre></td></tr></table></figure><ol start="2"><li>可以选择调用哪个构造函数进行实例化，获取构造器可以传入参数来选择</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Constructor c = clazz.getConstructor();</span><br><span class="line">Object obj = c.newInstance();</span><br></pre></td></tr></table></figure><h4 id="访问类的成员"><a href="#访问类的成员" class="headerlink" title="访问类的成员"></a>访问类的成员</h4><p>通过调用<code>getFiles()/getgetConstructors()/getMethods()</code>来访问该类的成员。同时我们会发现有些方法会带上Declared，这表示调用该方法不会返回父类的成员。</p><p>当然我们也可以直接获取类的某个成员，比如成员和方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取字段</span></span><br><span class="line">Field field = clazz.getField(<span class="string">"name"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取方法</span></span><br><span class="line">Method method=clazz.getMethod(<span class="string">"studyHard"</span>, <span class="keyword">new</span> Class[]&#123;String.class&#125;);</span><br></pre></td></tr></table></figure><p>还有一点，我们可以获取该类实现的接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取该类所实现的所有接口</span></span><br><span class="line">Class&lt;?&gt; interfaces[] = clazz.getInterfaces();</span><br></pre></td></tr></table></figure><h5 id="对类成员操作"><a href="#对类成员操作" class="headerlink" title="对类成员操作"></a>对类成员操作</h5><p>当获取到类成员后，我们可以进行下一步操作。</p><ul><li>使用 Constructor/Field/Method.setAccessible(true) 来绕开 Java 语言的访问限制。</li><li>使用 Constructor.newInstance(Object[]) 来生成该类的实例。</li><li>使用 Field.get/set(Object) 来访问字段的值。</li><li>使用 Method.invoke(Object, Object[]) 来调用方法。</li></ul><h3 id="获取泛型"><a href="#获取泛型" class="headerlink" title="获取泛型"></a>获取泛型</h3><p>在Java中泛型有擦除机制，那么我们在运行时可不可以获取泛型的具体类型呢？答案是可以的。原因是Class类文件结构中有一个叫Signature的属性。它的作用是存储一个方法在字节码层面的特征签名。这个属性中保存的参数参数类型并不是原生类型，而是包括了参数化类型的信息。</p><h4 id="获取成员变量的泛型信息"><a href="#获取成员变量的泛型信息" class="headerlink" title="获取成员变量的泛型信息"></a>获取成员变量的泛型信息</h4><p>比如在一个类Test中，有一个成员变量list，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> List&lt;String&gt; list;</span><br></pre></td></tr></table></figure><p>现在我想直接想获取List的泛型，怎么获取呢？实现代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Type t = Test.class.getDeclaredField(<span class="string">"list"</span>).getGenericType();  </span><br><span class="line"><span class="keyword">if</span> (ParameterizedType.class.isAssignableFrom(t.getClass())) &#123;</span><br><span class="line">    <span class="keyword">for</span> (Type t1 : ((ParameterizedType) t).getActualTypeArguments()) &#123;</span><br><span class="line">        System.out.print(t1 + <span class="string">","</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于可能会有多个泛型参数，例如Map，所以返回是一个数组。</p><h4 id="获取类的泛型信息"><a href="#获取类的泛型信息" class="headerlink" title="获取类的泛型信息"></a>获取类的泛型信息</h4><p>一个类是泛型类，在该类中我们可能需要获取这个泛型到底是啥，然后继续进行下面的逻辑，一个应用是Hibernate动态拼接HQL，需要知道泛型信息。<br>那么如何操作？代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过反射获取泛型实例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Genericity</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"rawtypes"</span>)</span><br><span class="line">    <span class="keyword">protected</span> Class clazz;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 把泛型的参数提取出来的过程放入到构造函数中写，因为</span></span><br><span class="line"><span class="comment"> * 当子类创建对象的时候，直接调用父类的构造函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Genericity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 通过反射机制获取子类传递过来的实体类的类型信息</span></span><br><span class="line">        ParameterizedType type = (ParameterizedType) <span class="keyword">this</span>.getClass().getGenericSuperclass();</span><br><span class="line">        <span class="comment">//得到t的实际类型</span></span><br><span class="line">        clazz = (Class&lt;T&gt;) type.getActualTypeArguments()[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取指定实例的所有属性名及对应值的Map实例 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> entity 实例</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 字段名及对应值的Map实例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Map&lt;String, Object&gt; <span class="title">getFieldValueMap</span><span class="params">(T entity)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// key是属性名，value是对应值</span></span><br><span class="line">        Map&lt;String, Object&gt; fieldValueMap = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取当前加载的实体类中所有属性</span></span><br><span class="line">        Field[] fields = <span class="keyword">this</span>.clazz.getDeclaredFields();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; fields.length; i++) &#123;</span><br><span class="line">            Field f = fields[i];</span><br><span class="line">            <span class="comment">// 属性名 </span></span><br><span class="line">            String key = f.getName();</span><br><span class="line">            <span class="comment">//属性值 </span></span><br><span class="line">            Object value = <span class="keyword">null</span>; </span><br><span class="line">            <span class="comment">// 忽略序列化版本ID号</span></span><br><span class="line">            <span class="keyword">if</span> (! <span class="string">"serialVersionUID"</span>.equals(key)) &#123;</span><br><span class="line">            <span class="comment">// 取消Java语言访问检查</span></span><br><span class="line">            f.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    value =f.get(entity);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IllegalArgumentException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                fieldValueMap.put(key, value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fieldValueMap;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中，<code>this.getClass().getGenericSuperclass()</code>返回表示此 Class 所表示的实体（类、接口、基本类型或 void）的直接超类的Type，然后将其转换<code>ParameterizedType</code>。<br><code>getActualTypeArguments()</code>返回表示此类型实际类型参数的 Type 对象的数组。</p><h3 id="反射Array相关API"><a href="#反射Array相关API" class="headerlink" title="反射Array相关API"></a>反射Array相关API</h3><p>reflect.Array类位于java.lang.reflect包下,它是个反射工具包，全是静态方法。我们可以利用这个类来对数组进行操作。</p><p>调用Class.getComponentType()获取数组元素的类型，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">Class&lt;?&gt; c = arr.getClass().getComponentType();</span><br></pre></td></tr></table></figure><p>假设我们需要获取数组长度，用Array的静态方法获取：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> len = Array.getLength(arr);</span><br></pre></td></tr></table></figure><p>当然我们可以用Array类来创建数组，向数组添加元素，修改元素等，具体可以参考官方API。</p><p>最后推荐一个<a href="https://github.com/Blankj/AndroidUtilCode/blob/4b5d0852f8274583968a7fb36db3b25bf92aaa22/utilcode/src/main/java/com/blankj/utilcode/util/ReflectUtils.java" target="_blank" rel="noopener">反射工具类</a>，可以参考参考。</p><p><strong>反射API参考：</strong></p><ul><li><p><a href="https://docs.oracle.com/javase/tutorial/reflect/" target="_blank" rel="noopener">https://docs.oracle.com/javase/tutorial/reflect/</a></p></li><li><p><a href="http://hg.openjdk.java.net/jdk10/jdk10/jdk/file/777356696811/src/java.base/share/classes/jdk/internal/reflect/ReflectionFactory.java#l80" target="_blank" rel="noopener">http://hg.openjdk.java.net/jdk10/jdk10/jdk/file/777356696811/src/java.base/share/classes/jdk/internal/reflect/ReflectionFactory.java#l80</a></p></li><li><p><a href="http://hg.openjdk.java.net/jdk10/jdk10/jdk/file/777356696811/src/java.base/share/classes/jdk/internal/reflect/ReflectionFactory.java#l78" target="_blank" rel="noopener">http://hg.openjdk.java.net/jdk10/jdk10/jdk/file/777356696811/src/java.base/share/classes/jdk/internal/reflect/ReflectionFactory.java#l78</a></p></li><li><p><a href="https://docs.oracle.com/javase/tutorial/reflect/class/classMembers.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/tutorial/reflect/class/classMembers.html</a></p></li><li><p><a href="https://docs.oracle.com/javase/10/docs/api/java/lang/reflect/package-summary.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/10/docs/api/java/lang/reflect/package-summary.html</a></p></li></ul><p><strong>文章参考：</strong></p><ul><li>郑雨迪, JVM是如何实现反射的?</li><li>周志明，深入理解Java虚拟机:JVM高级特性与最佳实践（第2版）</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 反射 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>自己如何实现一个简单的动态代理？</title>
      <link href="/2018/08/19/%E8%87%AA%E5%B7%B1%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%EF%BC%9F/"/>
      <url>/2018/08/19/%E8%87%AA%E5%B7%B1%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>经过对JDK动态代理实现原理的解析，我们会对动态代理的实现流程有个根本的认识，具体分析过程参考<a href="http://mingshan.me/2018/07/10/JDK%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/#more">JDK动态代理实现原理</a>这篇文章，这里就不多谈了。这篇文章主要思考如何去实现一个简易的动态代理，以便加深对其的理解。</p><a id="more"></a><p>模仿着JDK动态代理，我们需要一个代理<code>Proxy</code>类，一个<code>InvocationHandler</code>接口，同时实现一个类加载器，下面为定义的类。</p><p><img src="https://github.com/ZZULI-TECH/interview/blob/master/images/my-dynamic-proxy-class.png?raw=true" alt="image"></p><p>具体实现流程为：</p><p>首先定义一个<code>InvocationHandler</code>接口，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyInvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * proxy: 正在返回的代理对象，一般情况下，都不使用该对象</span></span><br><span class="line"><span class="comment">     * method: 正在被调用的方法</span></span><br><span class="line"><span class="comment">     * args: 调用方法时传入的参数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口中有一个invoke方法，方法中有三个参数，分别是：</p><ul><li>proxy: 正在返回的代理对象，一般情况下，都不使用该对象</li><li>method: 正在被调用的方法</li><li>args: 调用方法时传入的参数</li></ul><p>下面就需要实现代理类<code>Proxy</code>，动态代理的核心就是在这个类中实现的，主要功能包括如下几点：</p><ul><li>动态生成代理类，类似<code>$Proxy0.java</code></li><li>调用Java编译器，编译生成的代理类</li><li>将生成的class文件利用类加载器加载到内存中，然后进行实例化</li><li>调用自定义<code>InvocationHandler</code>的invoke方法</li></ul><p>详细代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 定义自己的 Proxy代理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyProxy</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> MyInvocationHandler h;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义回车键</span></span><br><span class="line">    <span class="keyword">static</span> String rt = <span class="string">"\r\t"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用户的当前工作目录,包含项目名</span></span><br><span class="line">    <span class="keyword">static</span> String workspace = System.getProperty(<span class="string">"user.dir"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前类包名</span></span><br><span class="line">    <span class="keyword">static</span> String packageName = MyProxy.class.getPackage().getName();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 私有构造器，该类禁止被实例化</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unused"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">MyProxy</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 由于 MyProxy 内部从不直接调用构造函数，所以 protected 意味着只有子类可以调用</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> h</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">MyProxy</span><span class="params">(MyInvocationHandler h)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.h = h;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在内存中创建$proxy0 的实例</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> loader</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> interfaces</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> h</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(&#123; <span class="string">"rawtypes"</span>, <span class="string">"resource"</span>, <span class="string">"unchecked"</span> &#125;)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">createProxyInstance</span><span class="params">(ClassLoader loader,</span></span></span><br><span class="line"><span class="function"><span class="params">            Class interfaces,</span></span></span><br><span class="line"><span class="function"><span class="params">            MyInvocationHandler h)</span> <span class="keyword">throws</span> IllegalArgumentException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        Objects.requireNonNull(h);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//实际运行这个动态类构造一个对象</span></span><br><span class="line">        System.out.println(<span class="string">"=====自定义:类构造一个代理类的java对象"</span>);</span><br><span class="line">        Method[] methods = interfaces.getMethods();</span><br><span class="line"></span><br><span class="line">        String proxyClassString = <span class="string">"package pers.han;"</span> + rt</span><br><span class="line">                + <span class="string">"import java.lang.reflect.Method;"</span> + rt</span><br><span class="line">                + <span class="string">"public class $Proxy0 implements "</span> + interfaces.getName() + <span class="string">"&#123;"</span> + rt</span><br><span class="line">                + <span class="string">"protected MyInvocationHandler h;"</span> + rt</span><br><span class="line">                + <span class="string">"public $Proxy0(MyInvocationHandler h)&#123;"</span> + rt</span><br><span class="line">                + <span class="string">"this.h=h;"</span> + rt + <span class="string">"&#125;"</span> + rt + getMethodString(methods,interfaces)</span><br><span class="line">                + rt + <span class="string">"&#125;"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//我们将自定义的代理类转化为文件</span></span><br><span class="line">        String fileName = workspace+<span class="string">"/src/pers/han/$Proxy0.java"</span>;</span><br><span class="line">        File file = <span class="keyword">new</span> File(fileName);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//向文件写内容</span></span><br><span class="line">        FileWriter fw = <span class="keyword">new</span> FileWriter(file);</span><br><span class="line">        fw.write(proxyClassString);</span><br><span class="line">        fw.flush();</span><br><span class="line">        <span class="comment">//编译这个文件</span></span><br><span class="line">        JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();</span><br><span class="line">        System.out.println(<span class="string">"comiler-"</span> + compiler);</span><br><span class="line">        StandardJavaFileManager fileManager = compiler.getStandardFileManager(<span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        Iterable units = fileManager.getJavaFileObjects(fileName);</span><br><span class="line">        <span class="comment">//编译这个任务</span></span><br><span class="line">        CompilationTask compTask = compiler.getTask(<span class="keyword">null</span>, fileManager, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, units);</span><br><span class="line">        compTask.call();</span><br><span class="line">        fileManager.close();</span><br><span class="line">        <span class="comment">//编译完成后，是不是.java</span></span><br><span class="line">        file.delete();</span><br><span class="line">        <span class="comment">//编译后就是class文件，那么接下来就把这个class文件 加到内存</span></span><br><span class="line">        MyClassLoader classLoader = <span class="keyword">new</span> MyClassLoader(workspace + <span class="string">"/src/pers/han"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class&lt;?&gt; proxy0Class = classLoader.findClass(<span class="string">"$Proxy0"</span>);</span><br><span class="line">            <span class="comment">//等类加载完之后 ，删除</span></span><br><span class="line">            File classFile = <span class="keyword">new</span> File(workspace + <span class="string">"/src/pers/han/$Proxy0.class"</span>);</span><br><span class="line">            <span class="keyword">if</span> (classFile.exists()) &#123;</span><br><span class="line">                classFile.delete();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Constructor&lt;?&gt; m = proxy0Class.getConstructor(MyInvocationHandler.class);</span><br><span class="line">            Object object = m.newInstance(h);</span><br><span class="line">            <span class="keyword">return</span> object;</span><br><span class="line">        &#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 实现的方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> methods</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> interfaces</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">getMethodString</span><span class="params">(Method[] methods, Class&lt;?&gt; interfaces)</span> </span>&#123;</span><br><span class="line">        String proxyMe = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Method m : methods) &#123;</span><br><span class="line">            proxyMe += <span class="string">"public void "</span> + m.getName() + <span class="string">"() throws Throwable &#123;"</span> + rt</span><br><span class="line">                    + <span class="string">"Method md="</span> + interfaces.getName() + <span class="string">".class.getMethod(\""</span></span><br><span class="line">                    + m.getName() + <span class="string">"\", new Class[]&#123;&#125;);"</span> + rt</span><br><span class="line">                    + <span class="string">"this.h.invoke(this,md,null);"</span> + rt + <span class="string">"&#125;"</span> + rt;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> proxyMe;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将类加载到内存中需要自定义类加载器，这里继承<code>ClassLoader</code>类，然后重写<code>findClass</code>方法，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自己的类加载器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mingshan</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> File dir;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyClassLoader</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">        dir = <span class="keyword">new</span> File( path );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (dir != <span class="keyword">null</span>) &#123;</span><br><span class="line">            File classFile = <span class="keyword">new</span> File(dir, name + <span class="string">".class"</span>);</span><br><span class="line">            <span class="keyword">if</span> (classFile.exists()) &#123;</span><br><span class="line">                FileInputStream input = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    input = <span class="keyword">new</span> FileInputStream(classFile);</span><br><span class="line">                    ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">                    <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">                    <span class="keyword">int</span> len;</span><br><span class="line">                    <span class="keyword">while</span> ((len=input.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                        baos.write(buffer, <span class="number">0</span>, len);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> defineClass(<span class="string">"pers.han."</span> + name, baos.toByteArray(), <span class="number">0</span>, baos.size());</span><br><span class="line">                &#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (input != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            input.close();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>生成的代理类<code>$Proxy0.java</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">package pers.han;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line">public class $Proxy0 implements pers.han.Person&#123;</span><br><span class="line">protected MyInvocationHandler h;</span><br><span class="line">public $Proxy0(MyInvocationHandler h)&#123;</span><br><span class="line">this.h=h;</span><br><span class="line">&#125;</span><br><span class="line">public void say() throws Throwable &#123;</span><br><span class="line">Method md=pers.han.Person.class.getMethod(&quot;say&quot;, new Class[]&#123;&#125;);</span><br><span class="line">this.h.invoke(this,md,null);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 动态代理 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Jenkins自动构建SpringBoot应用部署到Docker</title>
      <link href="/2018/08/18/Jenkins%E8%87%AA%E5%8A%A8%E6%9E%84%E5%BB%BASpringBoot%E5%BA%94%E7%94%A8%E9%83%A8%E7%BD%B2%E5%88%B0Docker/"/>
      <url>/2018/08/18/Jenkins%E8%87%AA%E5%8A%A8%E6%9E%84%E5%BB%BASpringBoot%E5%BA%94%E7%94%A8%E9%83%A8%E7%BD%B2%E5%88%B0Docker/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在开发SpringCloud微服务时，各个服务需要独立部署，手动部署比较麻烦，所以需要引入持续集成，Jenkins是一个非常好用的持续集成工具，十分好用。在使用Jenkins自动构建源码时，需要按照一定的步骤进行，步骤如下：</p><a id="more"></a><ol><li>从Git获取源代码</li><li>代码审查</li><li>编译代码</li><li>打包文件</li><li>部署到Docker</li></ol><p>以上步骤我们手动也可以完成，但我们都喜欢自动化，自己点一点就能搞定，干嘛还要一步步来呢。</p><h2 id="配置Jenkins环境"><a href="#配置Jenkins环境" class="headerlink" title="配置Jenkins环境"></a>配置Jenkins环境</h2><p>我们直接使用Docker安装Jenkins，我是直接安装Jenkins每日更新的镜像，<a href="https://hub.docker.com/r/jenkinsci/jenkins/" target="_blank" rel="noopener">Jenkins地址</a>，操作如下：</p><p>拉取镜像：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull jenkinsci/jenkins</span><br></pre></td></tr></table></figure><p>修改文件夹的归属者和组：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chown -R 1000:1000 jenkins_home/</span><br></pre></td></tr></table></figure><p>启动Jenkins容器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -itd -p 8088:8080 -p 50000:50000 --name jenkins --privileged=true  -v /usr/jenkins_home:/var/jenkins_home docker.io/jenkinsci/jenkins</span><br></pre></td></tr></table></figure><p>然后再配置一些个人信息和插件。</p><h2 id="新建任务"><a href="#新建任务" class="headerlink" title="新建任务"></a>新建任务</h2><p>首先我们需要新建Jenkins任务，选择Pipeline类型的任务，如下</p><p><img src="/images/jenkins_springbootdemo_start.png" alt="image"></p><p>然后配置下git信息和构建参数信息</p><p>构建参数主要有以下几个：</p><ul><li><strong>BRANCH_NAME</strong> 分支名称</li><li><strong>ENV</strong> 环境</li><li><strong>TARGET_MACHINE_IP</strong> 部署集群IP</li><li><strong>SSH_PORT</strong> 部署机器SSH端口</li><li><strong>TARGET_PORT</strong> 项目启动端口</li></ul><p>说到SSH，不要忘了让jenkins服务器能够免密SSH访问目标机器，配置下authorized_key等信息。</p><p>接下来就需要编写Jenkinsfile文件了，这个文件需要放在项目主目录下，构建源码时Jenkins会读取该文件，按照该文件配置的步骤进行源码构建。</p><h2 id="编写Jenkinsfile文件"><a href="#编写Jenkinsfile文件" class="headerlink" title="编写Jenkinsfile文件"></a>编写Jenkinsfile文件</h2><p>在Jenkinsfile文件中，利用pipeline来编写步骤。pipeline支持将连续输送Pipeline实施和整合到Jenkins，所以我们可以将上面提到的流程写到pipeline中。这里主要分以下五部：</p><ul><li>git clone</li><li>check code</li><li>build code</li><li>release package</li><li>deploy</li></ul><p>前两步就不提了，编译用Maven构建代码，release package这一步为打包代码，将一些脚本和编译好的jar文件打包成压缩文件，等待部署。deploy需要将打包的压缩文件拷贝到目标机器上，再执行部署脚本。</p><p>详细的Jenkinsfile如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">pipeline &#123;</span><br><span class="line">    agent any</span><br><span class="line"></span><br><span class="line">    environment &#123;</span><br><span class="line">        REPOSITORY=&quot;https://github.com/mstao/spring-boot-learning.git&quot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    stages &#123;</span><br><span class="line">        stage(&apos;git clone&apos;) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                echo &quot;&lt;&lt;&lt; Starting fetch code from git:$&#123;REPOSITORY&#125;&quot;</span><br><span class="line">                git credentialsId: &quot;bd8b65ce-7fd2-4e57-a9fe-45d4fe2924bf&quot;, url: &quot;$&#123;REPOSITORY&#125;&quot;, branch: &quot;$BRANCH_NAME&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        stage(&apos;check code&apos;) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                // chek code</span><br><span class="line">                // Jenkins 集成 sonar 进行代码审查</span><br><span class="line">                echo &quot;&lt;&lt;&lt;Starting check and analytic code&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        stage(&apos;build code&apos;) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                echo &quot;&lt;&lt;&lt; Starting build code and docker image&quot;</span><br><span class="line">                withMaven (</span><br><span class="line">                    maven: &apos;Maven 3.5.4&apos;,</span><br><span class="line">                    mavenLocalRepo: &apos;.repository&apos;) &#123;</span><br><span class="line">                        sh &apos;mvn clean package -Dmaven.test.skip=true&apos;</span><br><span class="line">                    &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        stage(&apos;release package&apos;) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                echo &quot;&lt;&lt;&lt; release package to /var/jenkins_home/release/demo/$ENV/$BRANCH_NAME&quot;</span><br><span class="line">                sh &apos;&apos;&apos;</span><br><span class="line">                    if [ -d target/demo ]</span><br><span class="line">                        then</span><br><span class="line">                        rm -rf target/demo</span><br><span class="line">                    fi</span><br><span class="line">                    mkdir -p target/demo</span><br><span class="line">                &apos;&apos;&apos;</span><br><span class="line">                sh &apos;&apos;&apos;</span><br><span class="line">                    cp target/*.jar target/demo/demo-api.jar</span><br><span class="line">                    cp deploy.sh target/demo/</span><br><span class="line">                    cp Dockerfile target/demo/</span><br><span class="line">                    cd target</span><br><span class="line">                    tar zcvf demo.tar.gz demo</span><br><span class="line">                    exit</span><br><span class="line">                &apos;&apos;&apos;</span><br><span class="line">                sh &apos;&apos;&apos;</span><br><span class="line">                    if [ ! -d /var/jenkins_home/release/demo/$ENV/$BRANCH_NAME ]</span><br><span class="line">                        then</span><br><span class="line">                        mkdir -p /var/jenkins_home/release/demo/$ENV/$BRANCH_NAME</span><br><span class="line">                    fi</span><br><span class="line">                &apos;&apos;&apos;</span><br><span class="line">                sh &apos;cp -f target/*.tar.gz /var/jenkins_home/release/demo/$ENV/$BRANCH_NAME&apos;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        stage(&apos;deploy&apos;) &#123;</span><br><span class="line">            steps &#123;</span><br><span class="line">                echo &quot;&lt;&lt;&lt; Starting deploy code to docker&quot;</span><br><span class="line">                 script &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        sh &apos;&apos;&apos;</span><br><span class="line">                            ssh -p $SSH_PORT -o StrictHostKeyChecking=no mingshan@$TARGET_MACHINE_IP rm -rf /app/tmp/demo/package</span><br><span class="line">                            ssh -p $SSH_PORT mingshan@$TARGET_MACHINE_IP mkdir -p /app/tmp/demo/package</span><br><span class="line">                        &apos;&apos;&apos;</span><br><span class="line">                    &#125;</span><br><span class="line">                    catch(e) &#123;</span><br><span class="line">                        echo e</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                sh &apos;&apos;&apos;</span><br><span class="line">                    scp -P $SSH_PORT /var/jenkins_home/release/demo/$ENV/$BRANCH_NAME/*.tar.gz mingshan@$TARGET_MACHINE_IP:/app/tmp/demo/package/</span><br><span class="line">                    ssh -p $SSH_PORT mingshan@$TARGET_MACHINE_IP &quot;tar -zxf /app/tmp/demo/package/demo.tar.gz -C /app/tmp/demo/package&quot;</span><br><span class="line">                    ssh -p $SSH_PORT mingshan@$TARGET_MACHINE_IP &quot;cd /app/tmp/demo/package/demo &amp;&amp; chmod +x * &amp;&amp; sh deploy.sh $TARGET_PORT&quot;</span><br><span class="line">                    exit</span><br><span class="line">                &apos;&apos;&apos;</span><br><span class="line">                echo &quot;deploy done&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="部署到Docker"><a href="#部署到Docker" class="headerlink" title="部署到Docker"></a>部署到Docker</h2><p>由于需要将打包的文件部署到Docker，所以需要将部署脚本和压缩文件发送到目标机器，在目标机器上制作Docker镜像，然后运行Docker 容器。</p><p>由于Docker需要root用户进行运行，而对于一些机器而言，拿不到root权限，所以需要进行一些操作，参考：<br><a href="https://blog.csdn.net/baidu_36342103/article/details/69357438" target="_blank" rel="noopener">免sudo使用docker命令</a></p><p>在Jenkinsfile中deploy步骤中，执行了以下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -p $SSH_PORT mingshan@$TARGET_MACHINE_IP "cd /app/tmp/demo/package/demo &amp;&amp; chmod +x * &amp;&amp; sh deploy.sh $TARGET_PORT"</span><br></pre></td></tr></table></figure><p>这是到目标机器上执行deploy.sh脚本，该脚本的内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line">port=11001</span><br><span class="line">image=demo</span><br><span class="line">name=demo-service</span><br><span class="line"></span><br><span class="line">if [ -z $1 ]; then</span><br><span class="line">    echo &quot;&lt;&lt;&lt; Using default port $port&quot;</span><br><span class="line">else</span><br><span class="line">    echo &quot;&lt;&lt;&lt; Set port to $1&quot;</span><br><span class="line">    $port=$1</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">echo &quot;&lt;&lt;&lt; Fetch container id of $name&quot;</span><br><span class="line">CID=$(docker ps | grep &quot;demo-service&quot; | awk &apos;&#123;print $1&#125;&apos;)</span><br><span class="line"></span><br><span class="line">if [ &quot;$CID&quot; != &quot;&quot; ];then</span><br><span class="line">  echo &quot;&lt;&lt;&lt; Stop and remove old container for $name&quot;</span><br><span class="line">  docker stop $CID</span><br><span class="line">  docker rm $CID</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">echo &quot;&lt;&lt;&lt; Remove old image $image&quot;</span><br><span class="line">docker rmi $image</span><br><span class="line"></span><br><span class="line">echo &quot;&lt;&lt;&lt; Start to build docker image $image&quot;</span><br><span class="line">docker build -t $image .</span><br><span class="line"></span><br><span class="line">echo &quot;&lt;&lt;&lt; Start new container port: $port for $name&quot;</span><br><span class="line">docker run -d -p $port:8080 --name $name $image</span><br></pre></td></tr></table></figure><p>在<code>deploy.sh</code>脚本中，主要分为以下几步：</p><ol><li>停止和删除旧容器</li><li>删除旧镜像</li><li>构建新镜像</li><li>运行容器</li></ol><p>这个脚本比较简单，按照上面的几步编写就行了。</p><p>最后附上项目的Dockerfile，也没啥说的。</p><p><strong>Dockerfile</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FROM openjdk:8-jdk-alpine</span><br><span class="line">VOLUME /tmp</span><br><span class="line">ADD spring-boot-docker-0.0.1-SNAPSHOT.jar app.jar</span><br><span class="line">ENTRYPOINT [&quot;java&quot;,&quot;-Djava.security.egd=file:/dev/./urandom&quot;,&quot;-jar&quot;,&quot;/app.jar&quot;]</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> Jenkins </tag>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>利用Docker搭建Nexus3私服</title>
      <link href="/2018/08/05/%E5%88%A9%E7%94%A8Docker%E6%90%AD%E5%BB%BANexus3%E7%A7%81%E6%9C%8D/"/>
      <url>/2018/08/05/%E5%88%A9%E7%94%A8Docker%E6%90%AD%E5%BB%BANexus3%E7%A7%81%E6%9C%8D/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>搭建私服对于一个团队来说十分有必要，利用Nexus3搭建私服十分方便，结合Docker，那是相当快速。</p><a id="more"></a><h2 id="安装Nexus3"><a href="#安装Nexus3" class="headerlink" title="安装Nexus3"></a>安装Nexus3</h2><p>拉取Nexus3的镜像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull sonatype/nexus3</span><br></pre></td></tr></table></figure><p>创建文件夹，挂载目录<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir /var/nexus-data &amp;&amp; chown -R 200 /var/nexus-data</span><br></pre></td></tr></table></figure></p><p>启动容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 8081:8081 --name nexus -v /var/nexus-data:/nexus-data --restart=always sonatype/nexus3</span><br></pre></td></tr></table></figure><p>开启端口</p><p>如果让外网访问的话，需要开放8081端口，在CentOS7中，可以利用firewall-cmd来开放端口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#开放11001端口  permanent为永久开放</span><br><span class="line">firewall-cmd --zone=public --add-port=8081/tcp --permanent</span><br><span class="line">#重新读取配置</span><br><span class="line">firewall-cmd --reload</span><br><span class="line">#查看全部开放端口</span><br><span class="line">firewall-cmd --list-all</span><br></pre></td></tr></table></figure><p>接下来在浏览器中输入以下网址，就可以看到Nexus3界面了如下图所示，用户名和密码默认为admin，admin123</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://ip:port</span><br></pre></td></tr></table></figure><p><img src="/images/nexus3-dashboard.png" alt="image"></p><h2 id="配置阿里云仓库"><a href="#配置阿里云仓库" class="headerlink" title="配置阿里云仓库"></a>配置阿里云仓库</h2><p>启动Nexus后，需要将中央仓库配置为阿里云仓库，提高国内的访问速度。Nexus的仓库如下：</p><p><img src="/images/nexus3-repository.png" alt="image"></p><p>由上图看出，Nexus的仓库分为这么几类：</p><ul><li>hosted 宿主仓库：主要用于部署无法从公共仓库获取的包以及自己或第三方的包；</li><li>proxy 代理仓库：代理公共的远程仓库；</li><li>group 仓库组：Nexus 通过仓库组的概念统一管理多个仓库，这样我们在项目中直接请求仓库组即可请求到仓库组管理的多个仓库。</li></ul><p>示意图如下：</p><p><img src="/images/nexus3-repository-desc.png" alt="image"></p><p>现在点击“Create Repository”按钮，来添加阿里云仓库，Recipe选择<code>maven2(proxy)</code>，在具体配置页面取名aliyun-repository，这里建议用a开头(估计按字母排序将它排第一位)，URL输入：<code>http://maven.aliyun.com/nexus/content/groups/public/</code>，其他默认值即可。</p><h2 id="配置maven"><a href="#配置maven" class="headerlink" title="配置maven"></a>配置maven</h2><p>接下来我们需要配置maven，打开setting.xml文件，在mirrors节点下加入以下配置（根据自己的配置更改）：</p><p>将<code>&lt;mirror&gt;&lt;url&gt;</code>标签内的地址修改成nexus服务的地址。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>*<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>nexus maven<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://www.mingzhiwen.cn:8081/repository/maven-public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后在services节点下加入以下配置，<code>&lt;servers&gt;</code>标签内填写nexus服务的账号密码，发布maven项目到nexus时，需要用到。<code>&lt;server&gt;&lt;id&gt;</code>下id需要跟<code>&lt;mirror&gt;&lt;id&gt;</code>一致。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">server</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">username</span>&gt;</span>admin<span class="tag">&lt;/<span class="name">username</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">password</span>&gt;</span>admin123<span class="tag">&lt;/<span class="name">password</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">server</span>&gt;</span></span><br></pre></td></tr></table></figure><p>最后在项目中的<code>pom.xml</code>文件加入以下配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">distributionManagement</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>Releases<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">url</span>&gt;</span>http://&#123;your-nexus-ip&#125;:port/repository/maven-releases/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">snapshotRepository</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>Snapshot<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">url</span>&gt;</span>http://&#123;your-nexus-ip&#125;:port/repository/maven-snapshots/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">snapshotRepository</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">distributionManagement</span>&gt;</span></span><br></pre></td></tr></table></figure><p>运行maven命令，将编译好的Jar包上传到Nexus私服中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn clean deploy</span><br></pre></td></tr></table></figure><p>上传效果如下图所示：</p><p><img src="/images/nexus3-upload.png" alt="image"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.jianshu.com/p/dbeae430f29d" target="_blank" rel="noopener">https://www.jianshu.com/p/dbeae430f29d</a></li><li><a href="https://github.com/sonatype/docker-nexus3" target="_blank" rel="noopener">https://github.com/sonatype/docker-nexus3</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nexus3 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>像是昨天</title>
      <link href="/2018/08/01/%E5%83%8F%E6%98%AF%E6%98%A8%E5%A4%A9/"/>
      <url>/2018/08/01/%E5%83%8F%E6%98%AF%E6%98%A8%E5%A4%A9/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>半夜醒来，想起前尘往事，遂成比文。我一写东西大多是唠叨，夹杂着些许不成熟的想法，姑且记录下来吧。</p><a id="more"></a><p>2016年7月，我的好朋友给我打了个电话让我去武汉玩，从此我真切感受到世界的另一面。本来不想把这些东西写成文章记录下来，但一直在心中憋着，就像一团结在心中缠绕，勒得心中直疼。再加上最近另一个好朋友也遇到此事，自己却没帮上什么忙。虽说自己也不懂什么大道理，说不出让人顿悟警醒的话，但基本的做人做事原则我还是能说上两句。时隔两年，心中除了惆怅和遗憾，还多了些许的无助感。</p><p>那么，2016年7月我遇到了什么事情呢？我遇到了所谓被称为传销的东西。传销这个词现在被人说烂了，我们没接触过的人听到这个词不会大惊小怪，新闻经常报道，即使是里面的人，直接会拿这个词给你说道说道，用他们的一套说辞来给你解释这个东西，直到你信以为真。千万不要小看这个让你信以为真的过程，这个过程被称为洗脑，这个词也是很常见，他们用所谓的大道理，所谓的说了一百遍都狗屁不是的话让你确认他们说的是真理，是赚钱迈向成功的一条猛路子，以便达到他们不可告人、见不得光的目地。很多事情在暗地里表面上看起来还是那么一回事，但真正剖析这件事的前因后果，可能发现原来多美好的一件事情，背后指不定有什么道道。虽然结果令人沮丧，但还是要认真面对，因为这是对你人生成长极大的考验，不得不头脑清醒些。</p><p>才去的时候挺开心的，毕竟暑假没事在家待着无聊，出去转转散散心也挺好。当我好朋友带我去听人生中第一堂洗脑课时，整个人瞬间一愣，这是在讲什么，这么短时间就能赚这么多钱，不会是传销吧，这时我意识到我朋友可能被人拉进了传销。不过整个过程我十分镇定，依然笑容满面，谈笑风生，一点也没让人看出我内心的慌乱和翻腾。其实我内心早已翻江倒海了，我知道我是清醒的，我在听些什么，但我不确定我朋友内心此时是怎么想的，或者说我已经知道朋友内心是怎么想的，不过这是我最不愿看到的。但事实就是那么残酷，越不想相信的事情，现实就会逼着你去相信。但我看到我朋友坚定的眼神，决心似乎很大，这让我不由得担心起来了。我想劝劝我朋友，早日脱离苦海，但我们终是凡人，谁又能成了佛。</p><p>我接触了很多年纪轻轻的从业者，我始终相信他们是善良的，他们是被那些心中怀着鬼胎的垃圾利用了，被那些人操纵着思想，给他们一个光明的目标，他们就以为看到了太阳的曙光。不过他们又有什么错呢？他们只是想赚钱，或许是凭借着自己的“努力”吧，可惜努力用错了地方，光明也不是纯粹的光明。以前我最痛恨的是利用他人的无知来谋取利益，现在呢？把你思想先改变了，再利用你来赚钱，这是最无耻的，也是悄无声息的，所以很多人不知不觉走上了这样的道路，真是可惜可叹。</p><p>我不想发那么多的牢骚，因为没什么意思，但我还是愿意不厌其烦地告诫那么不愿意脚踏实地的同学，天下没那么多好事，不要以为自己走了好运而沾沾自喜，那很有可能是别人挖好了坑等着你跳。我们还太年轻，虽说吃点亏不算什么，但不能因为这个坑而改变了自己的所有。人时有穷尽，力所不能及，还是多想想吧。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>构建一个Tomcat的Docker镜像</title>
      <link href="/2018/07/28/%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AATomcat%E7%9A%84Docker%E9%95%9C%E5%83%8F/"/>
      <url>/2018/07/28/%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AATomcat%E7%9A%84Docker%E9%95%9C%E5%83%8F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>最近在看Docker，对一个事物由陌生到熟悉需要一个过程，而这个过程需要从动手实践开始，下面记录一下我从零开始构建centos7+jdk8+tomcat8.5的docker镜像。</p><a id="more"></a><p><img src="/images/docker.png" alt="image"></p><h2 id="CentOS7-Docker-安装"><a href="#CentOS7-Docker-安装" class="headerlink" title="CentOS7 Docker 安装"></a>CentOS7 Docker 安装</h2><p>Docker 要求 CentOS 系统的内核版本高于 3.10 ，查看本页面的前提条件来验证你的CentOS 版本是否支持 Docker。<br>通过 uname -r 命令查看你当前的内核版本 </p><p>利用yum安装docker</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install docker-io</span><br></pre></td></tr></table></figure><p>安装完成后，启动docker服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service docker start</span><br></pre></td></tr></table></figure><p>测试一下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run hello-world</span><br></pre></td></tr></table></figure><h2 id="准备文件和构建环境"><a href="#准备文件和构建环境" class="headerlink" title="准备文件和构建环境"></a>准备文件和构建环境</h2><p>本次需要构建Tomcat的Docker镜像，所以需要Tomcat和JDK安装包，版本分别是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">apache-tomcat-8.5.32.tar.gz</span><br><span class="line"></span><br><span class="line">jdk-8u172-linux-x64.tar.gz</span><br></pre></td></tr></table></figure><p>创建<code>/usr/docker-tomcat</code>文件夹，将以上两个文件解压到该文件夹中，分别重命名为tomcat和jdk文件夹。</p><p>创建<code>Dockerfile</code>和<code>run.sh</code>两个文件，最终<code>/usr/docker-tomcat</code>文件夹内容如下图所示：</p><p><img src="/images/docker-tomcat-folder.png" alt="image"></p><p>编辑<code>Dockerfile</code>文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim Dockerfile</span><br></pre></td></tr></table></figure><p>向该文件添加如下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"># 设置继承的镜像</span><br><span class="line">FROM registry.cn-hangzhou.aliyuncs.com/repos_zyl/centos:0.0.1</span><br><span class="line"></span><br><span class="line"># 创建者信息</span><br><span class="line">MAINTAINER mingshan &quot;walkerhan@126.com&quot;</span><br><span class="line"></span><br><span class="line"># 设置环境变量，所有操作都是非交互式的</span><br><span class="line">ENV DEBIAN_FRONTEND noninteractive</span><br><span class="line"></span><br><span class="line"># 设置tomcat的环境变量</span><br><span class="line">ENV CATALINA_HOME /tomcat</span><br><span class="line">ENV JAVA_HOME /jdk</span><br><span class="line"></span><br><span class="line"># 复制tomcat和jdk文件到镜像中</span><br><span class="line">ADD apache-tomcat /tomcat</span><br><span class="line">ADD jdk /jdk</span><br><span class="line"></span><br><span class="line"># 复制启动脚本至镜像，并赋予脚本可执行权限</span><br><span class="line">ADD run.sh /run.sh</span><br><span class="line">RUN chmod +x /*.sh</span><br><span class="line">RUN chmod +x /tomcat/bin/*.sh</span><br><span class="line"></span><br><span class="line"># 暴露接口8080，这是我的tomcat接口，默认为8080</span><br><span class="line">EXPOSE 8080</span><br><span class="line"></span><br><span class="line"># 设置自启动命令</span><br><span class="line">CMD [&quot;/run.sh&quot;]</span><br></pre></td></tr></table></figure><p>保存后，然后编辑<code>run.sh</code>文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim run.sh</span><br></pre></td></tr></table></figure><p>添加如下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"># 启动tomcat</span><br><span class="line">exec $&#123;CATALINA_HOME&#125;/bin/catalina.sh run</span><br></pre></td></tr></table></figure><p>保存后接下来就开始构建docker镜像文件</p><h2 id="构建docker镜像文件"><a href="#构建docker镜像文件" class="headerlink" title="构建docker镜像文件"></a>构建docker镜像文件</h2><p>我们可以利用<code>docker build</code>来构建Docker镜像，<br>-t 设置tag名称, 命名规则registry/image:tag<br>. 表示使用当前目录下的Dockerfile文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t tomcat:test .</span><br></pre></td></tr></table></figure><p>执行该命令后，Docker就会按照Dockerfile文件顺序执行，会有很多步骤，下面是输出日志：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">Sending build context to Docker daemon 403.1 MB</span><br><span class="line">Step 1/12 : FROM registry.cn-hangzhou.aliyuncs.com/repos_zyl/centos:0.0.1</span><br><span class="line"> ---&gt; e1e65df66640</span><br><span class="line">Step 2/12 : MAINTAINER mingshan &quot;walkerhan@126.com&quot;</span><br><span class="line"> ---&gt; Using cache</span><br><span class="line"> ---&gt; f030a7c09868</span><br><span class="line">Step 3/12 : ENV DEBIAN_FRONTEND noninteractive</span><br><span class="line"> ---&gt; Using cache</span><br><span class="line"> ---&gt; ef3f61db3034</span><br><span class="line">Step 4/12 : ENV CATALINA_HOME /tomcat</span><br><span class="line"> ---&gt; Running in 5145fe0de0d1</span><br><span class="line"> ---&gt; 9a4af98c3434</span><br><span class="line">Removing intermediate container 5145fe0de0d1</span><br><span class="line">Step 5/12 : ENV JAVA_HOME /jdk</span><br><span class="line"> ---&gt; Running in 8bac05b87945</span><br><span class="line"> ---&gt; f5b7eb8d180e</span><br><span class="line">Removing intermediate container 8bac05b87945</span><br><span class="line">Step 6/12 : ADD tomcat /tomcat</span><br><span class="line"> ---&gt; d68a1754c19e</span><br><span class="line">Removing intermediate container 29f7625a6b95</span><br><span class="line">Step 7/12 : ADD jdk /jdk</span><br><span class="line"> ---&gt; df1669bd68de</span><br><span class="line">Removing intermediate container dc7de6c936fa</span><br><span class="line">Step 8/12 : ADD run.sh /run.sh</span><br><span class="line"> ---&gt; 90a13284ec01</span><br><span class="line">Removing intermediate container 5bf2c6666a03</span><br><span class="line">Step 9/12 : RUN chmod +x /*.sh</span><br><span class="line"> ---&gt; Running in 7f22e7927ffb</span><br><span class="line"></span><br><span class="line"> ---&gt; 10fff91bfa16</span><br><span class="line">Removing intermediate container 7f22e7927ffb</span><br><span class="line">Step 10/12 : RUN chmod +x /tomcat/bin/*.sh</span><br><span class="line"> ---&gt; Running in 163f103fcc0a</span><br><span class="line"></span><br><span class="line"> ---&gt; da593ceeaa49</span><br><span class="line">Removing intermediate container 163f103fcc0a</span><br><span class="line">Step 11/12 : EXPOSE 8080</span><br><span class="line"> ---&gt; Running in d66d686928fe</span><br><span class="line"> ---&gt; e2d7f915335a</span><br><span class="line">Removing intermediate container d66d686928fe</span><br><span class="line">Step 12/12 : CMD /run.sh</span><br><span class="line"> ---&gt; Running in a7f9d1e9c9a0</span><br><span class="line"> ---&gt; a21030de3aac</span><br><span class="line">Removing intermediate container a7f9d1e9c9a0</span><br><span class="line">Successfully built a21030de3aac</span><br></pre></td></tr></table></figure><p>构建完成后，就可以启动容器啦</p><h3 id="启动容器"><a href="#启动容器" class="headerlink" title="启动容器"></a>启动容器</h3><p>我们利用<code>docker run</code>来新建并启动容器，这个命令有很多参数，-d: 后台运行容器，并返回容器ID；-p: 端口映射，格式为：主机(宿主)端口:容器端口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 11001:8080 tomcat:test</span><br></pre></td></tr></table></figure><p>然后使用 <code>docker ps</code> 命令查看正在运行的容器，如下图所示：</p><p><img src="/images/docker-tomcat-ps.png" alt="image"></p><h3 id="开启端口"><a href="#开启端口" class="headerlink" title="开启端口"></a>开启端口</h3><p>如果让外网访问的话，需要开放11001端口，在CentOS7中，可以利用firewall-cmd来开放端口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#开放11001端口  permanent为永久开放</span><br><span class="line">firewall-cmd --zone=public --add-port=11001/tcp --permanent</span><br><span class="line">#重新读取配置</span><br><span class="line">firewall-cmd --reload</span><br><span class="line">#查看全部开放端口</span><br><span class="line">firewall-cmd --list-all</span><br></pre></td></tr></table></figure><p>接下来就可在浏览器中看到Tomcat界面了，大功告成！</p><p><img src="/images/docke-tomcat-showpage.png" alt="image"></p><h3 id="镜像保存为本地离线文件"><a href="#镜像保存为本地离线文件" class="headerlink" title="镜像保存为本地离线文件"></a>镜像保存为本地离线文件</h3><p>将docker image保存为离线的本地文件，执行<code>docker save image_name &gt; ./save.tar</code>或者 <code>docker save -o filepath image_name</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_0_6_centos docker-tocmat]# docker images</span><br><span class="line">REPOSITORY                                           TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">tomcat                                               test                a21030de3aac        2 hours ago         593 MB</span><br><span class="line">registry.cn-hangzhou.aliyuncs.com/repos_zyl/centos   0.0.1               e1e65df66640        19 months ago       192 MB</span><br><span class="line">[root@VM_0_6_centos docker-tocmat]# docker save a21030de3aac &gt; ./up_tomcat.tar</span><br><span class="line">[root@VM_0_6_centos docker-tocmat]# ls</span><br><span class="line">Dockerfile  jdk  run.sh  tomcat  up_tomcat.tar</span><br></pre></td></tr></table></figure><h3 id="其他操作"><a href="#其他操作" class="headerlink" title="其他操作"></a>其他操作</h3><ol><li>停止容器</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stop tomcat:test</span><br></pre></td></tr></table></figure><ol start="2"><li>启动容器</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker start tomcat:test</span><br></pre></td></tr></table></figure><ol start="3"><li>删除容器</li></ol><p>删除一个容器：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm 278636f577a6</span><br></pre></td></tr></table></figure></p><p>停用全部运行中的容器:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stop $(docker ps -q)</span><br></pre></td></tr></table></figure><p>删除全部容器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm $(docker ps -aq)</span><br></pre></td></tr></table></figure><p>一条命令实现停用并删除容器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stop $(docker ps -q) &amp; docker rm $(docker ps -aq)</span><br></pre></td></tr></table></figure><ol start="4"><li>删除镜像</li></ol><p>删除镜像需要先删除使用该镜像的容器，然后再删除镜像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi 3ae3626adcfa</span><br></pre></td></tr></table></figure><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://www.jianshu.com/p/369e75f6303b" target="_blank" rel="noopener">https://www.jianshu.com/p/369e75f6303b</a></li><li><a href="https://www.cnblogs.com/zhouyalei/p/6390963.html" target="_blank" rel="noopener">https://www.cnblogs.com/zhouyalei/p/6390963.html</a></li><li><a href="http://www.dockerinfo.net/docker%e5%ae%b9%e5%99%a8-2" target="_blank" rel="noopener">http://www.dockerinfo.net/docker%e5%ae%b9%e5%99%a8-2</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hashtable结构分析</title>
      <link href="/2018/07/16/Hashtable%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90/"/>
      <url>/2018/07/16/Hashtable%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>哈希表（Hash Table，也叫散列表），是存储键值对（key-value）的数据结构，主要利用hash算法将key映射到表中，以便加快查找速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。对于数组而言，查找数据容易，但添加删除数据比较慢；对于链表来说，添加删除数据容易，但查找数据比较慢，所以哈希表结合数据和链表来实现数据快速的存取。</p><p>哈希表的实现主要需要解决两个问题，哈希函数和冲突解决。</p><a id="more"></a><h2 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h2><p>在哈希表内部，使用桶（bucket）来保存键值对，数组索引即为桶号，哈希函数决定了给定的键存于散列表的哪个桶中，例如下面的函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">index = f(key, array_size)</span><br></pre></td></tr></table></figure><p>其中需要先通过key计算hash值，然后再利用算法计算出index，在维基百科中，有如下介绍：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hash = hashfunc(key)</span><br><span class="line">index = hash % array_size</span><br></pre></td></tr></table></figure><p>哈希函数和计算index的算法可以有很多种实现，但最终目的是能够均匀并独立地将所有的键散布在数组范围内。</p><h2 id="冲突解决"><a href="#冲突解决" class="headerlink" title="冲突解决"></a>冲突解决</h2><p>即使采用的哈希算法能够使键值均匀分布，但避免不了“碰撞”的出现，当两个不同的键值产生了相同值，这时就需要解决冲突。</p><p>解决冲突有很多种方法，比如拉链法和开地址法，这里主要分析拉链法的具体实现。</p><p>采用拉链法的哈希表，每个桶里都存放了一个链表。初始时所有链表均为空，当一个键被散列到一个桶时，这个键就成为相应桶中链表的首结点，之后若再有一个键被散列到这个桶（即发生碰撞），第二个键就会成为链表的第二个结点，以此类推。采用拉链法解决冲突的哈希表如下图所示：</p><p><img src="https://github.com/ZZULI-TECH/interview/blob/master/images/hashtable.png?raw=true" alt="image"></p><h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><p>对于哈希表而言，主要有增，删，获取操作，我们先来定义一个接口：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K k,V v)</span></span>;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(K k)</span></span>;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(K k)</span></span>;</span><br><span class="line"></span><br><span class="line">      <span class="class"><span class="keyword">interface</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span>&#123;</span><br><span class="line">          <span class="function"><span class="keyword">public</span> K <span class="title">getKey</span><span class="params">()</span></span>;</span><br><span class="line">          <span class="function"><span class="keyword">public</span> V <span class="title">getValue</span><span class="params">()</span></span>;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在Map接口中，定义了三个方法<code>put</code>，<code>get</code>，<code>remove</code>三个方法，同时定义了一个内部接口Entry，用来表示key-value结构。</p><p>接下来我们就采用拉链法来实现上面的接口。首先定义一下常量，成员变量以及在类的构造函数初始化一些数据代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认大小</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">16</span>;</span><br><span class="line"><span class="comment">// 默认负载因子</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"><span class="comment">// 定义数组大小</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> length;</span><br><span class="line"><span class="comment">// 扩容标准 所使用的数组数量/数组长度 &gt; 0.75</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">float</span> loadFactor;</span><br><span class="line"><span class="comment">// 使用数组位置的总量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> useSize;</span><br><span class="line"><span class="comment">// 定义Map 骨架 只要数组</span></span><br><span class="line"><span class="keyword">private</span> Entry&lt;K, V&gt;[] table = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMapDemo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMapDemo</span><span class="params">(<span class="keyword">int</span> length, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (length &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"参数不能为负数"</span> + length);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"扩容标准必须为大于0的数字"</span> + length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.length = length;</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">    <span class="keyword">this</span>.table = (Entry&lt;K, V&gt;[])<span class="keyword">new</span> Entry[length];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来下类的内存实现静态内存类Entry，由于采用了拉链法，所以需要用链表来存储具有相同的index的节点。代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">static class Entry&lt;K, V&gt; implements Map.Entry&lt;K, V&gt; &#123;</span><br><span class="line">    K k;</span><br><span class="line">    V v;</span><br><span class="line">    Entry&lt;K, V&gt; next;</span><br><span class="line"></span><br><span class="line">    public Entry(K k,V v,Entry&lt;K, V&gt; next)&#123;</span><br><span class="line">        this.k = k;</span><br><span class="line">        this.v = v;</span><br><span class="line">        this.next = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public K getKey() &#123;</span><br><span class="line">        return k;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public V getValue() &#123;</span><br><span class="line">        return v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="hash算法"><a href="#hash算法" class="headerlink" title="hash算法"></a>hash算法</h3><p>那么如何实现hash算法呢？这个问题有点复杂，还是先看看jdk8中HashMap是如何实现的，下面是部分代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用来通过自身数组的长度和key来确定存储位置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> k</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> length</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getIndex</span><span class="params">(K k, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// hashCode 与运算</span></span><br><span class="line">    <span class="keyword">int</span> m = length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> index = hash(k.hashCode()) &amp; m;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 三元运算符处理</span></span><br><span class="line">    <span class="keyword">return</span> index &gt;= <span class="number">0</span> ? index : -index;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * jdk1.8中hashmap的hash算法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> hashCode</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码中可以看出，要获取索引位置需要以下步骤：</p><p>取 key 的 hashCode 值、高位运算、取模运算。</p><p>其中，key.hashCode()是Key自带的hashCode()方法，返回一个int类型的散列值。我们知道，32位带符号的int表值范围从-2147483648到2147483648。这样只要hash函数松散的话，一般是很难发生碰撞的，因为HashMap的初始容量只有16。但是这样的散列值我们是不能直接拿来用的。用之前需要对数组的长度取模运算。得到余数才是索引值。具体参看<a href="http://ibat.xyz/2017/02/16/%E6%B5%85%E8%81%8AHashMap%E4%B8%AD%E7%9A%84hash%E7%AE%97%E6%B3%95/" target="_blank" rel="noopener">浅谈HashMap中的hash算法</a></p><h3 id="快存"><a href="#快存" class="headerlink" title="快存"></a>快存</h3><p>将key-value数据存入到哈希表表中，首先需要判断是否需要扩容，这里需要利用负载因子(loadFactor)来判断，默认扩容两倍。然后利用哈希算法来获取索引位置index，判断当前位置是否有结点，如果没有结点，就将当前结点作为这个桶中链表的头结点；如果有节点，那么就将其放在链表的末尾。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 快存</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K k, V v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (useSize &gt; <span class="keyword">this</span>.length * <span class="keyword">this</span>.loadFactor) &#123;</span><br><span class="line">        <span class="comment">// 需要扩容</span></span><br><span class="line">        up2Size();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 通过key来存储位置</span></span><br><span class="line">    <span class="keyword">int</span> index = getIndex(k, table.length);</span><br><span class="line">    Entry&lt;K,V&gt; entry = table[index];</span><br><span class="line">    <span class="keyword">if</span> (entry == <span class="keyword">null</span>) &#123;</span><br><span class="line">        table[index] = <span class="keyword">new</span> Entry&lt;K, V&gt;(k, v, <span class="keyword">null</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (entry != <span class="keyword">null</span>) &#123;</span><br><span class="line">        table[index] = <span class="keyword">new</span> Entry&lt;K, V&gt;(k, v, entry);</span><br><span class="line">    &#125;</span><br><span class="line">    useSize++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> table[index].getValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>扩容代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 增大容量，这里扩容两倍</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">up2Size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Entry&lt;K, V&gt;[] newTable = (Entry&lt;K,V&gt;[])<span class="keyword">new</span> Entry[<span class="number">2</span> * <span class="keyword">this</span>.length];</span><br><span class="line">    <span class="comment">// 原来数组有非常多的Entry对象，由于Entry对象散列，需要再次散列</span></span><br><span class="line">    againHash(newTable);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 存储的对象存储到新数组中（再次散列）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> newTable</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">againHash</span><span class="params">(Entry&lt;K, V&gt;[] newTable)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 将数组里面的对象封装到List</span></span><br><span class="line">    List&lt;Entry&lt;K, V&gt;&gt; entryList = <span class="keyword">new</span> ArrayList&lt;Entry&lt;K, V&gt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; table.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (table[i] == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        foundEntryByNext(table[i], entryList);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (entryList.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        useSize = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>.length = <span class="number">2</span> * <span class="keyword">this</span>.length;</span><br><span class="line">        table = newTable;</span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;K, V&gt; entry : entryList) &#123;</span><br><span class="line">            <span class="keyword">if</span> (entry.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//形成链表关系取消掉</span></span><br><span class="line">                entry.next = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            put(entry.getKey(), entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 寻找entry对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> entry</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> entryList</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">foundEntryByNext</span><span class="params">(Entry&lt;K, V&gt; entry, List&lt;Entry&lt;K, V&gt;&gt; entryList)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (entry != <span class="keyword">null</span> &amp;&amp; entry.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 说明entry对象已经形成链表结构</span></span><br><span class="line">        entryList.add(entry);</span><br><span class="line">        <span class="comment">// 需要递归</span></span><br><span class="line">        foundEntryByNext(entry.next, entryList);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        entryList.add(entry);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="快取"><a href="#快取" class="headerlink" title="快取"></a>快取</h3><p>从哈希表中根据key来取出元素比较简单，利用哈希算法计算出索引位置index，然后遍历链表即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 快取</span><br><span class="line"> */</span><br><span class="line">@Override</span><br><span class="line">public V get(K k) &#123;</span><br><span class="line">    int index = getIndex(k, table.length);</span><br><span class="line">    if (table[index] == null) &#123;</span><br><span class="line">        throw new NullPointerException();</span><br><span class="line">    &#125;</span><br><span class="line">    return findValueByEntryKey(k, table[index]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private V findValueByEntryKey(K k, Entry&lt;K, V&gt; entry) &#123;</span><br><span class="line">    Entry&lt;K, V&gt; e = entry;</span><br><span class="line">    while (e != null) &#123;</span><br><span class="line">        if (k == e.getKey() || k.equals(e.getKey()))</span><br><span class="line">            return e.getValue();</span><br><span class="line">        e = e.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="移除"><a href="#移除" class="headerlink" title="移除"></a>移除</h3><p>根据key将元素从哈希表中移除需要考虑以下几种情况：</p><ol><li>该节点为链表头结点</li><li>该节点为链表中间节点</li><li>该节点为链表尾节点</li></ol><p>然后按照上面的情况分别处理即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 移除</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> k</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(K k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index = getIndex(k, table.length);</span><br><span class="line">    Entry&lt;K, V&gt; e = table[index];</span><br><span class="line">    Entry&lt;K, V&gt; prev = <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (e != <span class="keyword">null</span> &amp;&amp; (!(k == e.getKey() ||</span><br><span class="line">            (k != <span class="keyword">null</span> &amp;&amp; k.equals(e.getKey()))))) &#123;</span><br><span class="line">        prev = e;</span><br><span class="line">        e = e.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Entry&lt;K, V&gt; next = e.next;</span><br><span class="line">    <span class="keyword">if</span> (prev != <span class="keyword">null</span> &amp;&amp; next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        prev.next = next;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (prev != <span class="keyword">null</span> &amp;&amp; next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        prev.next = <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (prev == <span class="keyword">null</span> &amp;&amp; next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// Node is the head</span></span><br><span class="line">        table[index] = next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// prev==null &amp;&amp; next==null</span></span><br><span class="line">        table[index] = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    useSize--;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> e.v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://en.wikipedia.org/wiki/Hash_table" target="_blank" rel="noopener">Hash table维基百科</a><br><br><a href="https://www.cnblogs.com/absfree/p/5508570.html" target="_blank" rel="noopener">散列表的基本原理与实现</a><br><br><a href="http://ibat.xyz/2017/02/16/%E6%B5%85%E8%81%8AHashMap%E4%B8%AD%E7%9A%84hash%E7%AE%97%E6%B3%95/" target="_blank" rel="noopener">浅谈HashMap中的hash算法</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> 哈希表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 哈希表 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JDK动态代理实现原理</title>
      <link href="/2018/07/10/JDK%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
      <url>/2018/07/10/JDK%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>平时接触动态代理比较多，例如Spring等框架如何使用了动态代理经常听到，本文主要介绍JDK动态代理的基本实现原理(JDK8版本)，当了解了这些实现细节后，再次使用动态代理就会十分容易和清楚，知其然也知其所以然。</p><a id="more"></a><h3 id="动态代理Demo"><a href="#动态代理Demo" class="headerlink" title="动态代理Demo"></a>动态代理Demo</h3><p>先来看一下利用JDK动态代理写的Demo，下面会根据这个Demo进行分析</p><p>首先定义一个接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Calculator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sub</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">mul</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">div</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后是上面接口的实现类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CalculatorImpl</span> <span class="keyword">implements</span> <span class="title">Calculator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        System.out.println(a+b);</span><br><span class="line">        <span class="keyword">return</span> a+b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sub</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a-b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">mul</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a*b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">div</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a/b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在有个需求，就是在每个方法执行前后都实现一段逻辑，这个时候就要用到JDK的动态代理了。</p><p>我们首先定义一个类实现<code>InvocationHandler</code>接口，将要代理的对象通过构造方法传入，并实现<code>invoke</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyProxyHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//要代理的对象</span></span><br><span class="line">    <span class="keyword">private</span> Calculator target;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyProxyHandler</span><span class="params">(Calculator h)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = h;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">//获取参数</span></span><br><span class="line">        System.out.println(<span class="string">"beginWith---方法的参数是--"</span> + Arrays.asList(args));</span><br><span class="line"></span><br><span class="line">        before();</span><br><span class="line">        Object result = method.invoke(target,args);</span><br><span class="line">        after();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 前置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"before---"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 后置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"after---"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后我们利用JDK提供的Proxy类来实现我们想要的功能</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * jdk动态代理测试</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mingshan</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       Calculator target = <span class="keyword">new</span> CalculatorImpl();</span><br><span class="line">       Calculator proxy = (Calculator) Proxy.newProxyInstance(Calculator.class.getClassLoader(),</span><br><span class="line">               <span class="keyword">new</span> Class&lt;?&gt;[]&#123;Calculator.class&#125;,</span><br><span class="line">               <span class="keyword">new</span> MyProxyHandler(target));</span><br><span class="line"></span><br><span class="line">       proxy.add(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="具体实现流程"><a href="#具体实现流程" class="headerlink" title="具体实现流程"></a>具体实现流程</h3><p>动态代理之所以被称为动态代理，那是因为代理类是在运行过程中被Java动态生成的，我们可以看到这个被生成的代理类，需要在运行运行配置加上<code>-Dsun.misc.ProxyGenerator.saveGeneratedFiles=true</code>这个虚拟机参数，那么就会在当前项目<code>com.sun.proxy</code>包路径下生成<code>$Proxy0.class</code>这个class文件，其中文件名的数字是可变的。</p><p><img src="https://github.com/ZZULI-TECH/interview/blob/master/images/dynamic-proxy-vm-options.png?raw=true" alt="image"></p><p>代理类生成的过程主要包括两部分：</p><ul><li>代理类字节码生成</li><li>把字节码通过传入的类加载器加载到虚拟机中</li></ul><p>我们首先从Proxy类的newProxyInstance方法入手，开始分析实现流程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">newProxyInstance</span><span class="params">(ClassLoader loader,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      Class&lt;?&gt;[] interfaces,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      InvocationHandler h)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IllegalArgumentException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">// 检查空指针异常</span></span><br><span class="line">    Objects.requireNonNull(h);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Class&lt;?&gt;[] intfs = interfaces.clone();</span><br><span class="line">    <span class="comment">// 安全检查</span></span><br><span class="line">    <span class="keyword">final</span> SecurityManager sm = System.getSecurityManager();</span><br><span class="line">    <span class="keyword">if</span> (sm != <span class="keyword">null</span>) &#123;</span><br><span class="line">        checkProxyAccess(Reflection.getCallerClass(), loader, intfs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成代理类</span></span><br><span class="line">    Class&lt;?&gt; cl = getProxyClass0(loader, intfs);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Invoke its constructor with the designated invocation handler.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (sm != <span class="keyword">null</span>) &#123;</span><br><span class="line">            checkNewProxyPermission(Reflection.getCallerClass(), cl);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams);</span><br><span class="line">        <span class="keyword">final</span> InvocationHandler ih = h;</span><br><span class="line">        <span class="keyword">if</span> (!Modifier.isPublic(cl.getModifiers())) &#123;</span><br><span class="line">            AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Void&gt;() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> Void <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    cons.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cons.newInstance(<span class="keyword">new</span> Object[]&#123;h&#125;);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalAccessException|InstantiationException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(e.toString(), e);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">        Throwable t = e.getCause();</span><br><span class="line">        <span class="keyword">if</span> (t <span class="keyword">instanceof</span> RuntimeException) &#123;</span><br><span class="line">            <span class="keyword">throw</span> (RuntimeException) t;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(t.toString(), t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(e.toString(), e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>newProxyInstance</code>方法需要三个参数，分别是类加载器，接口类型的数组和自定义的InvocationHandler。首选会检测空指针异常和安全检查，然后调用<code>getProxyClass0</code>方法，<code>getProxyClass0</code>源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Class&lt;?&gt; getProxyClass0(ClassLoader loader,</span><br><span class="line">                                       Class&lt;?&gt;... interfaces) &#123;</span><br><span class="line">    <span class="keyword">if</span> (interfaces.length &gt; <span class="number">65535</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"interface limit exceeded"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If the proxy class defined by the given loader implementing</span></span><br><span class="line">    <span class="comment">// the given interfaces exists, this will simply return the cached copy;</span></span><br><span class="line">    <span class="comment">// otherwise, it will create the proxy class via the ProxyClassFactory</span></span><br><span class="line">    <span class="keyword">return</span> proxyClassCache.get(loader, interfaces);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码里面的注释很清楚，如果实现当前接口的代理类存在，直接从缓存中返回，如果不存在，则通过ProxyClassFactory来创建。这里可以明显看到有对interface接口数量的限制，不能超过65535。其中proxyClassCache具体初始化信息如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxyClassCache = <span class="keyword">new</span> WeakCache&lt;&gt;(<span class="keyword">new</span> KeyFactory(), <span class="keyword">new</span> ProxyClassFactory());</span><br></pre></td></tr></table></figure><p>其中创建代理类的具体逻辑是通过ProxyClassFactory的apply方法来创建的，ProxyClassFactory类中还包含代理类名称生成相关的两个静态常量，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// prefix for all proxy class names</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String proxyClassNamePrefix = <span class="string">"$Proxy"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// next number to use for generation of unique proxy class names</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicLong nextUniqueNumber = <span class="keyword">new</span> AtomicLong();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Class&lt;?&gt; apply(ClassLoader loader, Class&lt;?&gt;[] interfaces) &#123;</span><br><span class="line"></span><br><span class="line">    Map&lt;Class&lt;?&gt;, Boolean&gt; interfaceSet = <span class="keyword">new</span> IdentityHashMap&lt;&gt;(interfaces.length);</span><br><span class="line">    <span class="keyword">for</span> (Class&lt;?&gt; intf : interfaces) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Verify that the class loader resolves the name of this</span></span><br><span class="line"><span class="comment">         * interface to the same Class object.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Class&lt;?&gt; interfaceClass = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            interfaceClass = Class.forName(intf.getName(), <span class="keyword">false</span>, loader);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (interfaceClass != intf) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                intf + <span class="string">" is not visible from class loader"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Verify that the Class object actually represents an</span></span><br><span class="line"><span class="comment">         * interface.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (!interfaceClass.isInterface()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                interfaceClass.getName() + <span class="string">" is not an interface"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Verify that this interface is not a duplicate.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (interfaceSet.put(interfaceClass, Boolean.TRUE) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                <span class="string">"repeated interface: "</span> + interfaceClass.getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String proxyPkg = <span class="keyword">null</span>;     <span class="comment">// package to define proxy class in</span></span><br><span class="line">    <span class="keyword">int</span> accessFlags = Modifier.PUBLIC | Modifier.FINAL;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Record the package of a non-public proxy interface so that the</span></span><br><span class="line"><span class="comment">     * proxy class will be defined in the same package.  Verify that</span></span><br><span class="line"><span class="comment">     * all non-public proxy interfaces are in the same package.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">for</span> (Class&lt;?&gt; intf : interfaces) &#123;</span><br><span class="line">        <span class="keyword">int</span> flags = intf.getModifiers();</span><br><span class="line">        <span class="keyword">if</span> (!Modifier.isPublic(flags)) &#123;</span><br><span class="line">            accessFlags = Modifier.FINAL;</span><br><span class="line">            String name = intf.getName();</span><br><span class="line">            <span class="keyword">int</span> n = name.lastIndexOf(<span class="string">'.'</span>);</span><br><span class="line">            String pkg = ((n == -<span class="number">1</span>) ? <span class="string">""</span> : name.substring(<span class="number">0</span>, n + <span class="number">1</span>));</span><br><span class="line">            <span class="keyword">if</span> (proxyPkg == <span class="keyword">null</span>) &#123;</span><br><span class="line">                proxyPkg = pkg;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!pkg.equals(proxyPkg)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                    <span class="string">"non-public interfaces from different packages"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (proxyPkg == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// if no non-public proxy interfaces, use com.sun.proxy package</span></span><br><span class="line">        proxyPkg = ReflectUtil.PROXY_PACKAGE + <span class="string">"."</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Choose a name for the proxy class to generate.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">long</span> num = nextUniqueNumber.getAndIncrement();</span><br><span class="line">    String proxyName = proxyPkg + proxyClassNamePrefix + num;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Generate the specified proxy class.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">byte</span>[] proxyClassFile = ProxyGenerator.generateProxyClass(</span><br><span class="line">        proxyName, interfaces, accessFlags);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> defineClass0(loader, proxyName,</span><br><span class="line">                            proxyClassFile, <span class="number">0</span>, proxyClassFile.length);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassFormatError e) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * A ClassFormatError here means that (barring bugs in the</span></span><br><span class="line"><span class="comment">         * proxy class generation code) there was some other</span></span><br><span class="line"><span class="comment">         * invalid aspect of the arguments supplied to the proxy</span></span><br><span class="line"><span class="comment">         * class creation (such as virtual machine limitations</span></span><br><span class="line"><span class="comment">         * exceeded).</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(e.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>apply方法需要两个参数，类加载器和接口类型的数组。该方法包含验证类加载器和接口相关逻辑，包名的创建逻辑，调用<code>ProxyGenerator. generateProxyClass</code>生成代理类，把代理类字节码加载到JVM。</p><ol><li>包名默认是<code>com.sun.proxy</code>，如果被代理类是 non-public proxy interface ，则用和被代理类接口一样的包名，类名默认是$Proxy 加上一个自增的整数值，如$Proxy0，$Proxy1。</li><li>包名类名准备好后，就是通过<code>ProxyGenerator.generateProxyClass</code>根据具体传入的接口创建代理字节码，<code>-Dsun.misc.ProxyGenerator.saveGeneratedFiles=true</code> 这个VM参数就是在该方法起到作用，如果为true则保存字节码到磁盘。代理类中，所有的代理方法逻辑都一样都是调用invocationHander的invoke方法，这个我们可以看后面具体代理反编译结果。</li><li>把字节码通过传入的类加载器加载到JVM中: defineClass0(loader, proxyName,proxyClassFile, 0, proxyClassFile.length);。</li></ol><p>我们继续来看看<code>generateProxyClass</code>方法是如何实现的，下面是该类的源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] generateProxyClass(<span class="keyword">final</span> String var0, Class&lt;?&gt;[] var1, <span class="keyword">int</span> var2) &#123;</span><br><span class="line">    ProxyGenerator var3 = <span class="keyword">new</span> ProxyGenerator(var0, var1, var2);</span><br><span class="line">    <span class="comment">// 生成代理类字节码文件的真正方法</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">byte</span>[] var4 = var3.generateClassFile();</span><br><span class="line">    <span class="comment">// 保存文件操作</span></span><br><span class="line">    <span class="keyword">if</span> (saveGeneratedFiles) &#123;</span><br><span class="line">        AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Void&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> Void <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">int</span> var1 = var0.lastIndexOf(<span class="number">46</span>);</span><br><span class="line">                    Path var2;</span><br><span class="line">                    <span class="keyword">if</span> (var1 &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        Path var3 = Paths.get(var0.substring(<span class="number">0</span>, var1).replace(<span class="string">'.'</span>, File.separatorChar));</span><br><span class="line">                        Files.createDirectories(var3);</span><br><span class="line">                        var2 = var3.resolve(var0.substring(var1 + <span class="number">1</span>, var0.length()) + <span class="string">".class"</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        var2 = Paths.get(var0 + <span class="string">".class"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    Files.write(var2, var4, <span class="keyword">new</span> OpenOption[<span class="number">0</span>]);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException var4x) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(<span class="string">"I/O exception saving generated file: "</span> + var4x);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> var4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>generateProxyClass</code>方法中，通过调用<code>ProxyGenerator</code>类的<code>generateClassFile</code>方法，来生成代理类字节码文件，然后保存文件。</p><p>接下来我们看看<code>generateClassFile</code>方法干了些什么，下面是该方法的源码（方法有点长~）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">byte</span>[] generateClassFile() &#123;</span><br><span class="line">    <span class="comment">// addProxyMethod系列方法就是将接口的方法和Object的hashCode,equals,toString方法添加到代理方法Map(proxyMethods),</span></span><br><span class="line">    <span class="comment">// 其中方法签名作为key,proxyMethod作为value</span></span><br><span class="line">    <span class="comment">// 后面经过反编译生成的代理类看出，hashCode，equals，toString这三个方法相当于从Object拿过来，</span></span><br><span class="line">    <span class="comment">// m0 = Class.forName("java.lang.Object").getMethod("hashCode", new Class[0]);</span></span><br><span class="line">    <span class="keyword">this</span>.addProxyMethod(hashCodeMethod, Object.class);</span><br><span class="line">    <span class="keyword">this</span>.addProxyMethod(equalsMethod, Object.class);</span><br><span class="line">    <span class="keyword">this</span>.addProxyMethod(toStringMethod, Object.class);</span><br><span class="line">    Class[] var1 = <span class="keyword">this</span>.interfaces;</span><br><span class="line">    <span class="keyword">int</span> var2 = var1.length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> var3;</span><br><span class="line">    Class var4;</span><br><span class="line">    <span class="comment">// 获得所有接口中的所有方法，并将方法添加到代理方法中</span></span><br><span class="line">    <span class="keyword">for</span>(var3 = <span class="number">0</span>; var3 &lt; var2; ++var3) &#123;</span><br><span class="line">        var4 = var1[var3];</span><br><span class="line">        Method[] var5 = var4.getMethods();</span><br><span class="line">        <span class="keyword">int</span> var6 = var5.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> var7 = <span class="number">0</span>; var7 &lt; var6; ++var7) &#123;</span><br><span class="line">            Method var8 = var5[var7];</span><br><span class="line">            <span class="keyword">this</span>.addProxyMethod(var8, var4);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 迭代存储在map中的ProxyMethod</span></span><br><span class="line">    Iterator var11 = <span class="keyword">this</span>.proxyMethods.values().iterator();</span><br><span class="line"></span><br><span class="line">    List var12;</span><br><span class="line">    <span class="keyword">while</span>(var11.hasNext()) &#123;</span><br><span class="line">        var12 = (List)var11.next();</span><br><span class="line">        checkReturnTypes(var12);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Iterator var15;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 生成代理类的构造函数</span></span><br><span class="line">        <span class="keyword">this</span>.methods.add(<span class="keyword">this</span>.generateConstructor());</span><br><span class="line">        var11 = <span class="keyword">this</span>.proxyMethods.values().iterator();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(var11.hasNext()) &#123;</span><br><span class="line">            var12 = (List)var11.next();</span><br><span class="line">            var15 = var12.iterator();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(var15.hasNext()) &#123;</span><br><span class="line">                ProxyGenerator.ProxyMethod var16 = (ProxyGenerator.ProxyMethod)var15.next();</span><br><span class="line">                <span class="comment">// 向代理类添加字段</span></span><br><span class="line">                <span class="comment">// 将代理字段声明为Method，10为ACC_PRIVATE和ACC_STATAIC的与运算，表示该字段的修饰符为private static</span></span><br><span class="line">                <span class="comment">// 所以代理类的字段都是private static Method XXX</span></span><br><span class="line">                <span class="keyword">this</span>.fields.add(<span class="keyword">new</span> ProxyGenerator.FieldInfo(var16.methodFieldName, <span class="string">"Ljava/lang/reflect/Method;"</span>, <span class="number">10</span>));</span><br><span class="line">                <span class="comment">// 向代理类添加方法</span></span><br><span class="line">                <span class="keyword">this</span>.methods.add(var16.generateMethod());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 为代理类生成静态代码块，对一些字段进行初始化</span></span><br><span class="line">        <span class="keyword">this</span>.methods.add(<span class="keyword">this</span>.generateStaticInitializer());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException var10) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(<span class="string">"unexpected I/O Exception"</span>, var10);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 限制方法和字段数量</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.methods.size() &gt; <span class="number">65535</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"method limit exceeded"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.fields.size() &gt; <span class="number">65535</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"field limit exceeded"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.cp.getClass(dotToSlash(<span class="keyword">this</span>.className));</span><br><span class="line">        <span class="keyword">this</span>.cp.getClass(<span class="string">"java/lang/reflect/Proxy"</span>);</span><br><span class="line">        var1 = <span class="keyword">this</span>.interfaces;</span><br><span class="line">        var2 = var1.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(var3 = <span class="number">0</span>; var3 &lt; var2; ++var3) &#123;</span><br><span class="line">            var4 = var1[var3];</span><br><span class="line">            <span class="keyword">this</span>.cp.getClass(dotToSlash(var4.getName()));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.cp.setReadOnly();</span><br><span class="line">        ByteArrayOutputStream var13 = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        DataOutputStream var14 = <span class="keyword">new</span> DataOutputStream(var13);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            var14.writeInt(-<span class="number">889275714</span>);</span><br><span class="line">            var14.writeShort(<span class="number">0</span>);</span><br><span class="line">            var14.writeShort(<span class="number">49</span>);</span><br><span class="line">            <span class="keyword">this</span>.cp.write(var14);</span><br><span class="line">            var14.writeShort(<span class="keyword">this</span>.accessFlags);</span><br><span class="line">            var14.writeShort(<span class="keyword">this</span>.cp.getClass(dotToSlash(<span class="keyword">this</span>.className)));</span><br><span class="line">            var14.writeShort(<span class="keyword">this</span>.cp.getClass(<span class="string">"java/lang/reflect/Proxy"</span>));</span><br><span class="line">            var14.writeShort(<span class="keyword">this</span>.interfaces.length);</span><br><span class="line">            Class[] var17 = <span class="keyword">this</span>.interfaces;</span><br><span class="line">            <span class="keyword">int</span> var18 = var17.length;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> var19 = <span class="number">0</span>; var19 &lt; var18; ++var19) &#123;</span><br><span class="line">                Class var22 = var17[var19];</span><br><span class="line">                var14.writeShort(<span class="keyword">this</span>.cp.getClass(dotToSlash(var22.getName())));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            var14.writeShort(<span class="keyword">this</span>.fields.size());</span><br><span class="line">            var15 = <span class="keyword">this</span>.fields.iterator();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(var15.hasNext()) &#123;</span><br><span class="line">                ProxyGenerator.FieldInfo var20 = (ProxyGenerator.FieldInfo)var15.next();</span><br><span class="line">                var20.write(var14);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            var14.writeShort(<span class="keyword">this</span>.methods.size());</span><br><span class="line">            var15 = <span class="keyword">this</span>.methods.iterator();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(var15.hasNext()) &#123;</span><br><span class="line">                ProxyGenerator.MethodInfo var21 = (ProxyGenerator.MethodInfo)var15.next();</span><br><span class="line">                var21.write(var14);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            var14.writeShort(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> var13.toByteArray();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException var9) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(<span class="string">"unexpected I/O Exception"</span>, var9);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么自定义的InvocationHandler是如何在代理中使用的呢？ 在上面的方法中向代理类添加方法调用了<code>generateMethod()</code>方法，所以这个添加方法的步骤就是在<code>generateMethod()</code>方法中实现的。<br>由于这个方法太长，这里就不贴全部代码了，方法里面有一段代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var9.writeShort(ProxyGenerator.<span class="keyword">this</span>.cp.getFieldRef(<span class="string">"java/lang/reflect/Proxy"</span>, <span class="string">"h"</span>, <span class="string">"Ljava/lang/reflect/InvocationHandler;"</span>));</span><br></pre></td></tr></table></figure><p>原来在代理方法中通过Proxy类引用了自定义InvocationHandler，由于通过Proxy的newProxyInstance方法将InvocationHandler传入，生成的代理类通过继承Proxy类，拿到InvocationHandler，<br>最后调用invoke方法来实现。</p><p>明白了JDK动态代理的大致流程，让我们来反编译下生成的代理类，反编译后的<code>$Proxy0.java</code>的代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line">package com.sun.proxy;</span><br><span class="line"></span><br><span class="line">import java.lang.reflect.InvocationHandler;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line">import java.lang.reflect.Proxy;</span><br><span class="line">import java.lang.reflect.UndeclaredThrowableException;</span><br><span class="line">import me.mingshan.dy.Calculator;</span><br><span class="line"></span><br><span class="line">public final class $Proxy0 extends Proxy implements Calculator &#123;</span><br><span class="line"></span><br><span class="line">   private static Method m1;</span><br><span class="line">   private static Method m2;</span><br><span class="line">   private static Method m5;</span><br><span class="line">   private static Method m3;</span><br><span class="line">   private static Method m4;</span><br><span class="line">   private static Method m6;</span><br><span class="line">   private static Method m0;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   public $Proxy0(InvocationHandler var1) throws  &#123;</span><br><span class="line">      super(var1);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public final boolean equals(Object var1) throws  &#123;</span><br><span class="line">      try &#123;</span><br><span class="line">         return ((Boolean)super.h.invoke(this, m1, new Object[]&#123;var1&#125;)).booleanValue();</span><br><span class="line">      &#125; catch (RuntimeException | Error var3) &#123;</span><br><span class="line">         throw var3;</span><br><span class="line">      &#125; catch (Throwable var4) &#123;</span><br><span class="line">         throw new UndeclaredThrowableException(var4);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public final String toString() throws  &#123;</span><br><span class="line">      try &#123;</span><br><span class="line">         return (String)super.h.invoke(this, m2, (Object[])null);</span><br><span class="line">      &#125; catch (RuntimeException | Error var2) &#123;</span><br><span class="line">         throw var2;</span><br><span class="line">      &#125; catch (Throwable var3) &#123;</span><br><span class="line">         throw new UndeclaredThrowableException(var3);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public final int mul(int var1, int var2) throws  &#123;</span><br><span class="line">      try &#123;</span><br><span class="line">         return ((Integer)super.h.invoke(this, m5, new Object[]&#123;Integer.valueOf(var1), Integer.valueOf(var2)&#125;)).intValue();</span><br><span class="line">      &#125; catch (RuntimeException | Error var4) &#123;</span><br><span class="line">         throw var4;</span><br><span class="line">      &#125; catch (Throwable var5) &#123;</span><br><span class="line">         throw new UndeclaredThrowableException(var5);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public final int add(int var1, int var2) throws  &#123;</span><br><span class="line">      try &#123;</span><br><span class="line">         return ((Integer)super.h.invoke(this, m3, new Object[]&#123;Integer.valueOf(var1), Integer.valueOf(var2)&#125;)).intValue();</span><br><span class="line">      &#125; catch (RuntimeException | Error var4) &#123;</span><br><span class="line">         throw var4;</span><br><span class="line">      &#125; catch (Throwable var5) &#123;</span><br><span class="line">         throw new UndeclaredThrowableException(var5);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public final int sub(int var1, int var2) throws  &#123;</span><br><span class="line">      try &#123;</span><br><span class="line">         return ((Integer)super.h.invoke(this, m4, new Object[]&#123;Integer.valueOf(var1), Integer.valueOf(var2)&#125;)).intValue();</span><br><span class="line">      &#125; catch (RuntimeException | Error var4) &#123;</span><br><span class="line">         throw var4;</span><br><span class="line">      &#125; catch (Throwable var5) &#123;</span><br><span class="line">         throw new UndeclaredThrowableException(var5);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public final int div(int var1, int var2) throws  &#123;</span><br><span class="line">      try &#123;</span><br><span class="line">         return ((Integer)super.h.invoke(this, m6, new Object[]&#123;Integer.valueOf(var1), Integer.valueOf(var2)&#125;)).intValue();</span><br><span class="line">      &#125; catch (RuntimeException | Error var4) &#123;</span><br><span class="line">         throw var4;</span><br><span class="line">      &#125; catch (Throwable var5) &#123;</span><br><span class="line">         throw new UndeclaredThrowableException(var5);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public final int hashCode() throws  &#123;</span><br><span class="line">      try &#123;</span><br><span class="line">         return ((Integer)super.h.invoke(this, m0, (Object[])null)).intValue();</span><br><span class="line">      &#125; catch (RuntimeException | Error var2) &#123;</span><br><span class="line">         throw var2;</span><br><span class="line">      &#125; catch (Throwable var3) &#123;</span><br><span class="line">         throw new UndeclaredThrowableException(var3);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   static &#123;</span><br><span class="line">      try &#123;</span><br><span class="line">         m1 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;equals&quot;, new Class[]&#123;Class.forName(&quot;java.lang.Object&quot;)&#125;);</span><br><span class="line">         m2 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;toString&quot;, new Class[0]);</span><br><span class="line">         m5 = Class.forName(&quot;me.mingshan.dy.Calculator&quot;).getMethod(&quot;mul&quot;, new Class[]&#123;Integer.TYPE, Integer.TYPE&#125;);</span><br><span class="line">         m3 = Class.forName(&quot;me.mingshan.dy.Calculator&quot;).getMethod(&quot;add&quot;, new Class[]&#123;Integer.TYPE, Integer.TYPE&#125;);</span><br><span class="line">         m4 = Class.forName(&quot;me.mingshan.dy.Calculator&quot;).getMethod(&quot;sub&quot;, new Class[]&#123;Integer.TYPE, Integer.TYPE&#125;);</span><br><span class="line">         m6 = Class.forName(&quot;me.mingshan.dy.Calculator&quot;).getMethod(&quot;div&quot;, new Class[]&#123;Integer.TYPE, Integer.TYPE&#125;);</span><br><span class="line">         m0 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;hashCode&quot;, new Class[0]);</span><br><span class="line">      &#125; catch (NoSuchMethodException var2) &#123;</span><br><span class="line">         throw new NoSuchMethodError(var2.getMessage());</span><br><span class="line">      &#125; catch (ClassNotFoundException var3) &#123;</span><br><span class="line">         throw new NoClassDefFoundError(var3.getMessage());</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代理类的结构大致如下:</p><ul><li>静态字段：被代理的接口所有方法都有一个对应的静态方法变量；</li><li>静态块：主要是通过反射初始化静态方法变量；</li><li>具体每个代理方法：逻辑都差不多就是<code>h.invoke</code>，主要是调用我们自定义的InvocatinoHandler逻辑，触发目标对象target上对应的方法;</li><li>构造函数：从这里传入我们InvocationHandler逻辑</li></ul><p>参考：<br><br><a href="http://www.importnew.com/23168.html" target="_blank" rel="noopener">JDK动态代理详解</a><br><br><a href="https://www.cnblogs.com/MOBIN/p/5597215.html" target="_blank" rel="noopener">深度剖析JDK动态代理机制</a></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 动态代理 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>IllegalMonitorStateException异常分析</title>
      <link href="/2018/07/03/IllegalMonitorStateException%E5%BC%82%E5%B8%B8%E5%88%86%E6%9E%90/"/>
      <url>/2018/07/03/IllegalMonitorStateException%E5%BC%82%E5%B8%B8%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>当调用wait()， notify()等相关方法时，可能会产生这个异常，那么这个异常是什么意思呢？</p><a id="more"></a><p>抛出该异常原因:在Java中，每一个对象（Object/Class）都有一个监视器，当在同步代码块中，当前线程不是此监视器的所有者，也就是要在当前线程锁定对象，才能用锁定的对象此行这些方法，需要用到synchronized ，锁定什么对象就用什么对象来执行notify(), notifyAll(),wait(), wait(long), wait(long, int)操作，否则就会报IllegalMonitorStateException异常，原因异常。</p><p>下面这段代码就会抛出IllegalMonitorStateException异常，原因就是调用wait需要当前对象的监视器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ThreadTest.class.wait();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">":"</span> + i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> ThreadTest()).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以对于synchronized的使用来说，通常这样使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(x) &#123;</span><br><span class="line">    x.notify();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体对于不同的监视对象而言，可以有以下几种考虑：</p><ol><li>锁定方法所对应的对象实例</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.notify();</span><br><span class="line">       <span class="comment">// 或者直接写notify();</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>类锁</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">synchronized</span>(xx.class) &#123;</span><br><span class="line">       xx.notify();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>锁定其他对象</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Class Test&#123;</span><br><span class="line">    <span class="keyword">public</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> method（）&#123;</span><br><span class="line">      <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">         lock.notify();</span><br><span class="line">      &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> IllegalMonitorStateException </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>理解ThreadLocal</title>
      <link href="/2018/07/01/%E7%90%86%E8%A7%A3ThreadLocal/"/>
      <url>/2018/07/01/%E7%90%86%E8%A7%A3ThreadLocal/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>记得去年学习Spring MVC的时候自己学着写了一个小小的框架，用了一个AppContext来表示应用上下文，每个请求都应该有各自独立的AppContext，里面可以存储一些数据，比如数据库连接Connection等，此时考虑数据库的事务问题，即在一个线程内，一个事务的多个操作拿到的是一个Connection，该如何实现呢？此时就需要使用ThreadLocal来解决。</p><a id="more"></a><h3 id="ThreadLocal介绍"><a href="#ThreadLocal介绍" class="headerlink" title="ThreadLocal介绍"></a>ThreadLocal介绍</h3><p><strong>ThreadLocal能干啥？</strong></p><p>ThreadLocal是基于线程的一个本地变量的支持类，用户可以将对象与线程绑定，每一个线程都拥有一个自己的对象，例如对于上面的需求来说，可以将AppContext存入到ThreadLocal，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class AppContext &#123;</span><br><span class="line">    private static ThreadLocal&lt;AppContext&gt; appContextMap = new ThreadLocal&lt;AppContext&gt;();</span><br><span class="line">    private Map&lt;String, Object&gt; objects = new HashMap&lt;String, Object&gt;();</span><br><span class="line"></span><br><span class="line">    private AppContext() &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    // 部分代码省略</span><br><span class="line">    </span><br><span class="line">    public void clear() &#123;</span><br><span class="line">        AppContext context = appContextMap.get();</span><br><span class="line">        if (context != null) &#123;</span><br><span class="line">            context.objects.clear();</span><br><span class="line">        &#125;</span><br><span class="line">        context = null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static AppContext getAppContext() &#123;</span><br><span class="line">        AppContext appContext = appContextMap.get();</span><br><span class="line">        if (appContext == null) &#123;</span><br><span class="line">            appContext = new AppContext();</span><br><span class="line">            appContextMap.set(appContext);</span><br><span class="line">        &#125;</span><br><span class="line">        return appContextMap.get();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于数据库的Connection，可以有以下实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public Class ConnectionManager &#123;</span><br><span class="line"></span><br><span class="line">   // 创建一个私有静态的并且是与事务相关联的局部线程变量  </span><br><span class="line">   private static ThreadLocal&lt;Connection&gt; connectionHolder = new ThreadLocal&lt;Connection&gt;;</span><br><span class="line"></span><br><span class="line">   public static Connection getConnection() &#123;</span><br><span class="line">       // 获得线程变量connectionHolder的值conn  </span><br><span class="line">       Connection conn = connectionHolder.get();</span><br><span class="line">       if (conn == null)&#123;</span><br><span class="line">           // 如果连接为空，则创建连接，另一个工具类，创建连接  </span><br><span class="line">           conn = DbUtil.getConnection();</span><br><span class="line">           // 将局部变量connectionHolder的值设置为conn  </span><br><span class="line">           connectionHolder.set(conn);</span><br><span class="line">       &#125;</span><br><span class="line">       return conn;</span><br><span class="line">   &#125;  </span><br><span class="line">｝</span><br></pre></td></tr></table></figure><h3 id="ThreadLocal原理分析"><a href="#ThreadLocal原理分析" class="headerlink" title="ThreadLocal原理分析"></a>ThreadLocal原理分析</h3><p>ThreadLocal有如下成员变量和方法，如下图所示</p><p><img src="/images/threadlocal.png" alt="image"></p><p>其中经常用到的是以下几个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123; &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> T <span class="title">initialValue</span><span class="params">()</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure><p>由于ThreadLocal里面需要存值和取值，又需要与线程相关，那么数据存在哪里，用哪种数据结构呢？由于Map可以存储很多类型，这里又不需要对外提供服务，所以这里就用了静态内部类的Map来搞存储，来存储真实的变量实例。</p><h4 id="get-流程"><a href="#get-流程" class="headerlink" title="get()流程"></a>get()流程</h4><p>那么， ThreadLocal是如何工作的呢？我们先从get方法看起，下面是get方法的源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">            T result = (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先获得当前线程，然后通过getMap(t)方法获取到一个map，map的类型为ThreadLocalMap。接下来根据&lt;key,value&gt;从map中获取Entry，注意这里获取键值对传进去的是this，而不是当前线程t。如果获取成功，则返回value值。如果map为空，则调用setInitialValue方法返回value。</p><p>getMap()方法是如何获取到ThreadLocalMap的呢？来看看源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发现是直接获取当前线程的threadLocals成员变量，那么接下来就到Thread类里面去看一下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ThreadLocal values pertaining to this thread. This map is maintained</span></span><br><span class="line"><span class="comment"> * by the ThreadLocal class. */</span></span><br><span class="line">ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure><p>实际上就是ThreadLocalMap，这个类型是ThreadLocal类的一个内部类，我们来看看ThreadLocalMap内部的Entry类，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">    Object value;</span><br><span class="line"></span><br><span class="line">    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">        <span class="keyword">super</span>(k);</span><br><span class="line">        value = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Entry继承自WeakReference，这里弱引用为Map的key，也就是ThreadLocal，弱引用就是只要JVM垃圾回收器发现了它，就会将之回收。</p><p>回到get()方法， 如果通过getMap()方法获取的map为空，就会调用setInitialValue() 方法，下面是该方法的源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> T <span class="title">setInitialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    T value = initialValue();</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先调用initialValue() 方法进行初始化value，默认为null，接下来获取当前线程，获取map，判断map是否为空，不为空将ThreadLocal类的对象为key，设定value，为空则创建map，调用createMap(t, value)方法，createMap代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">    t.threadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="set-T-value-流程"><a href="#set-T-value-流程" class="headerlink" title="set(T value)流程"></a>set(T value)流程</h4><p>接下来看看set方法如何实现的，下面是源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先获取当前线程，然后获取map，判断map是否为空，不为空将ThreadLocal类的对象为key，设定value，为空则创建map，调用createMap(t, value)方法。</p><p>至此，我们就可以知道大致知道ThreadLocal的工作流程：</p><ol><li><p>Thread类中有一个成员变量属于ThreadLocalMap类(一个定义在ThreadLocal类中的内部类)，它是一个Map，它的key是ThreadLocal实例对象。</p></li><li><p>当为ThreadLocal类的对象set值时，首先获得当前线程的ThreadLocalMap类属性，然后以ThreadLocal类的对象为key，设定value。get值时则类似。</p></li></ol><h3 id="一个线程多个ThreadLocal，如何区分？"><a href="#一个线程多个ThreadLocal，如何区分？" class="headerlink" title="一个线程多个ThreadLocal，如何区分？"></a>一个线程多个ThreadLocal，如何区分？</h3><p>既然ThreadLocal内部用map存储数据，一个线程可以对应多个ThreadLocal对象，那么这些ThreadLocal对象是如何区分的呢？上面只是大致分析了ThreadLocal的工作原理，并未涉及ThreadLocalMap的存值和取值，接下来我们继续来看源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ThreadLocals rely on per-thread linear-probe hash maps attached</span></span><br><span class="line"><span class="comment"> * to each thread (Thread.threadLocals and</span></span><br><span class="line"><span class="comment"> * inheritableThreadLocals).  The ThreadLocal objects act as keys,</span></span><br><span class="line"><span class="comment"> * searched via threadLocalHashCode.  This is a custom hash code</span></span><br><span class="line"><span class="comment"> * (useful only within ThreadLocalMaps) that eliminates collisions</span></span><br><span class="line"><span class="comment"> * in the common case where consecutively constructed ThreadLocals</span></span><br><span class="line"><span class="comment"> * are used by the same threads, while remaining well-behaved in</span></span><br><span class="line"><span class="comment"> * less common cases.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> threadLocalHashCode = nextHashCode();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The next hash code to be given out. Updated atomically. Starts at</span></span><br><span class="line"><span class="comment"> * zero.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> AtomicInteger nextHashCode =</span><br><span class="line">    <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The difference between successively generated hash codes - turns</span></span><br><span class="line"><span class="comment"> * implicit sequential thread-local IDs into near-optimally spread</span></span><br><span class="line"><span class="comment"> * multiplicative hash values for power-of-two-sized tables.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HASH_INCREMENT = <span class="number">0x61c88647</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the next hash code.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nextHashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> nextHashCode.getAndAdd(HASH_INCREMENT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在ThreadLocal类内部定义了一个final的变量threadLocalHashCode，这个变量是干什么的？看注释，在ThreadLocalMap存储数据时，ThreadLocal对象作为key，通过threadLocalHashCode进行搜索，threadLocalHashCode通过原子类AtomicInteger，提供原子操作，由于nextHashCode为类变量，保证每次生成的hashCode都不一致，每次生成hashCode都会有HASH_INCREMENT的差值。threadLocalHashCode会在ThreadLocalMap中用到，下面继续分析。</p><p>前面分析get()流程，对于如何从ThreadLocalMap取数据并未提及，现在看看源码如何实现的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Entry <span class="title">getEntry</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (table.length - <span class="number">1</span>);</span><br><span class="line">    Entry e = table[i];</span><br><span class="line">    <span class="keyword">if</span> (e != <span class="keyword">null</span> &amp;&amp; e.get() == key)</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> getEntryAfterMiss(key, i, e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过调用ThreadLocalMap的getEntry方法，传入当前ThreadLocal对象，然后获取ThreadLocal的threadLocalHashCode， 然后通过位运算与(&amp;) 将 threadLocalHashCode和ThreadLocal内部存储数据的table的长度减一进行位运算得到i，利用i在table中直接进行搜索。</p><p>在ThreadLocalMap如何存值？下面看ThreadLocalMap.set()源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We don't use a fast path as with get() because it is at</span></span><br><span class="line">    <span class="comment">// least as common to use set() to create new entries as</span></span><br><span class="line">    <span class="comment">// it is to replace existing ones, in which case, a fast</span></span><br><span class="line">    <span class="comment">// path would fail more often than not.</span></span><br><span class="line"></span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Entry e = tab[i];</span><br><span class="line">         e != <span class="keyword">null</span>;</span><br><span class="line">         e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">            e.value = value;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">            replaceStaleEntry(key, value, i);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tab[i] = <span class="keyword">new</span> Entry(key, value);</span><br><span class="line">    <span class="keyword">int</span> sz = ++size;</span><br><span class="line">    <span class="keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class="line">        rehash();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在ThreadLocalMap.set()方法中，传入当前ThreadLocal对象和要存的值，然后通过位运算与(&amp;) 将 threadLocalHashCode和ThreadLocal内部存储数据的table的长度减一进行位运算得到i，这个i在get()方法已经见过了，完全一样（不一样就出问题啦），接下来开始遍历table，判断有没有相同的key等处理，其实最核心的就是你得去new 一个entry然后设置到table数组中，就是下面这句：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tab[i] = <span class="keyword">new</span> Entry(key, value);</span><br></pre></td></tr></table></figure><h3 id="ThreadLocal会有内存泄露？"><a href="#ThreadLocal会有内存泄露？" class="headerlink" title="ThreadLocal会有内存泄露？"></a>ThreadLocal会有内存泄露？</h3><p>看了好多博客，里面提到ThreadLocal会有内存泄露问题，因为从ThreadLocalMap的设计来看，如下图，key被设计成弱引用，一旦JVM进行GC时，这个key就没了，那么与key对应的value还存在ThreadLocalMap，ThreadLocalMap与Entry存在着强引用，GC无法回收，造成内存泄露。</p><p><img src="/images/threadlocal_weak.png" alt="image"></p><p>当然，这些都是分析出来的，既然我们考虑到了，那么Josh Bloch 和 Doug Lea肯定也为我们考虑过了，所以这个问题在源码中已经解决了，下面来看看相关源码</p><p>在ThreadLocalMap.set()方法中，如果key为null，此时会调用 replaceStaleEntry()方法，在这个方法中进行处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">replaceStaleEntry</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value,</span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="keyword">int</span> staleSlot)</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    Entry e;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Back up to check for prior stale entry in current run.</span></span><br><span class="line">    <span class="comment">// We clean out whole runs at a time to avoid continual</span></span><br><span class="line">    <span class="comment">// incremental rehashing due to garbage collector freeing</span></span><br><span class="line">    <span class="comment">// up refs in bunches (i.e., whenever the collector runs).</span></span><br><span class="line">    <span class="keyword">int</span> slotToExpunge = staleSlot;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = prevIndex(staleSlot, len);</span><br><span class="line">         (e = tab[i]) != <span class="keyword">null</span>;</span><br><span class="line">         i = prevIndex(i, len))</span><br><span class="line">        <span class="keyword">if</span> (e.get() == <span class="keyword">null</span>)</span><br><span class="line">            slotToExpunge = i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Find either the key or trailing null slot of run, whichever</span></span><br><span class="line">    <span class="comment">// occurs first</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = nextIndex(staleSlot, len);</span><br><span class="line">         (e = tab[i]) != <span class="keyword">null</span>;</span><br><span class="line">         i = nextIndex(i, len)) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If we find key, then we need to swap it</span></span><br><span class="line">        <span class="comment">// with the stale entry to maintain hash table order.</span></span><br><span class="line">        <span class="comment">// The newly stale slot, or any other stale slot</span></span><br><span class="line">        <span class="comment">// encountered above it, can then be sent to expungeStaleEntry</span></span><br><span class="line">        <span class="comment">// to remove or rehash all of the other entries in run.</span></span><br><span class="line">        <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">            e.value = value;</span><br><span class="line"></span><br><span class="line">            tab[i] = tab[staleSlot];</span><br><span class="line">            tab[staleSlot] = e;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Start expunge at preceding stale entry if it exists</span></span><br><span class="line">            <span class="keyword">if</span> (slotToExpunge == staleSlot)</span><br><span class="line">                slotToExpunge = i;</span><br><span class="line">            cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If we didn't find stale entry on backward scan, the</span></span><br><span class="line">        <span class="comment">// first stale entry seen while scanning for key is the</span></span><br><span class="line">        <span class="comment">// first still present in the run.</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span> &amp;&amp; slotToExpunge == staleSlot)</span><br><span class="line">            slotToExpunge = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If key not found, put new entry in stale slot</span></span><br><span class="line">    tab[staleSlot].value = <span class="keyword">null</span>;</span><br><span class="line">    tab[staleSlot] = <span class="keyword">new</span> Entry(key, value);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If there are any other stale entries in run, expunge them</span></span><br><span class="line">    <span class="keyword">if</span> (slotToExpunge != staleSlot)</span><br><span class="line">        cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中我们可以看到这段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// If key not found, put new entry in stale slot</span></span><br><span class="line">tab[staleSlot].value = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure><p>如果key找不到，那么就将value置为null，help GC。这样问题解决。</p><p>当然在resize()方法中也有同样的操作，总之都会进行处理的。</p><p>最后，我们可以调用remove()方法将相关数据移除，这个肯定就不会有内存泄露啦。</p><h3 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h3><p><a href="https://www.cnblogs.com/xzwblog/p/7227509.html#_label0" target="_blank" rel="noopener">https://www.cnblogs.com/xzwblog/p/7227509.html#_label0</a></p><p><a href="https://www.jianshu.com/p/ee8c9dccc953" target="_blank" rel="noopener">https://www.jianshu.com/p/ee8c9dccc953</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=MzA5MzQ2NTY0OA==&amp;mid=2650796401&amp;idx=1&amp;sn=61f2d19bfb0e34c08206c6b31a1c2dd1&amp;chksm=88562c2ebf21a5383ace3f52f336db9b53a714bb37d5f97a9d5746b43b6a3d30be113aca082a&amp;mpshare=1&amp;scene=23&amp;srcid=1212TdJMnkHNCPTwVsPKSuao#rd" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MzA5MzQ2NTY0OA==&amp;mid=2650796401&amp;idx=1&amp;sn=61f2d19bfb0e34c08206c6b31a1c2dd1&amp;chksm=88562c2ebf21a5383ace3f52f336db9b53a714bb37d5f97a9d5746b43b6a3d30be113aca082a&amp;mpshare=1&amp;scene=23&amp;srcid=1212TdJMnkHNCPTwVsPKSuao#rd</a></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> ThreadLocal </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>设计模式之装饰模式</title>
      <link href="/2018/06/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/"/>
      <url>/2018/06/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>装饰模式作为常用的设计模式用到很多，比如在Java中，io包下的很多类就是典型的装饰者模式的体现，如下代码：</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> BufferedOutputStream(OutputStream out)</span><br><span class="line"><span class="keyword">new</span> BufferedInputStream(InputStream in);</span><br><span class="line"><span class="keyword">new</span> PrintWriter(OutputStream out)</span><br><span class="line"><span class="keyword">new</span> FilterReader(Reader in);</span><br></pre></td></tr></table></figure><p>那么，什么是装饰模式呢？</p><p>在实际应用中我们可能会有这样的需求，需要动态地为一个类增加一些功能，这些功能动态地撤销，继承虽然也可以对类进行功能扩展，但是静态的，为了扩展性和动态性，就需要引入装饰模式。</p><p>装饰模式的定义是： 动态地给一些对象添加一些额外的职责。就增加功能来说，装饰模式相比生成子类更加灵活。</p><p>装饰模式的通用类图如下图所示：</p><p><img src="/images/decorator.png" alt="image"></p><p>在类图中，有四个角色需要说明：</p><ul><li><p>抽象构件（Component） </p><p>  给出一个抽象的接口，用以规范准备接收附加责任的对象。</p></li><li><p>具体构件（ConcreteComponent） </p><p>  ConcreteComponent是最核心、最原始、最基本的接口或抽象类的实现，要装饰的就是它。</p></li><li><p>装饰角色（Decorator） </p><p>  有一个构件（Conponent）对象的实例，并定义一个和抽象构件一致的接口。</p></li><li><p>具体装饰角色（ConcreteDecorator） </p><p>  具体的装饰类，要增加的功能当然要在这里写啦。</p></li></ul><p><strong>具体代码实现:</strong></p><p>抽象构件:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 抽象构建</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mingshan</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">operate</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体构件:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 具体构件</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mingshan</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteComponent</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"do something"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>装饰角色, 持有一个抽象构件的引用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 抽象装饰者</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mingshan</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Decorator</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Component component;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Decorator</span><span class="params">(Component component)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.component = component;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.component.operate();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体装饰角色</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 装饰者1</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mingshan</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteDecorator1</span> <span class="keyword">extends</span> <span class="title">Decorator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义被修饰者</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> component</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteDecorator1</span><span class="params">(Component component)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(component);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义自己的修饰方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"decorator A"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重写父类的方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.method1();</span><br><span class="line">        <span class="keyword">super</span>.operate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mingshan</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Component component = <span class="keyword">new</span> ConcreteComponent();</span><br><span class="line">        <span class="comment">// 第一次装饰</span></span><br><span class="line">        component = <span class="keyword">new</span> ConcreteDecorator1(component);</span><br><span class="line">        <span class="comment">// 第二次装饰</span></span><br><span class="line">        component = <span class="keyword">new</span> ConcreteDecorator2(component);</span><br><span class="line">        component.operate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>代码参考：</strong></p><p><a href="https://github.com/mstao/java-explore/tree/master/DesignPattern/src/pers/han/decorator" target="_blank" rel="noopener">https://github.com/mstao/java-explore/tree/master/DesignPattern/src/pers/han/decorator</a></p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 设计模式 </tag>
            
            <tag> 装饰模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>设计模式之适配器模式</title>
      <link href="/2018/06/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
      <url>/2018/06/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在我们日常生活中可以看到许多例子，例如我们的手机需要用充电器来充电，因为220v电压手机是承受不住的；笔记本电脑连接投影仪可以是HDMI，需要转接头等等例子，从这些例子中我们可以发现目标对象与源对象无法直接交互，需要一个中间层来作为一个桥梁达到让两者完美交互的效果，从这种就可以看到适配器模式的影子了。</p><a id="more"></a><p>那么什么是适配器模式呢? 将一个类的接口转换成客户希望的另外一个接口。Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。</p><p>适配器包含类适配器和对象适配器，类适配器是类间继承，对象适配器是类的关联关系，这是两者的区别。</p><p>我们先来看看适配器模式的角色</p><ol><li><p>Target目标角色</p><p> 该角色定义把其他类转化为何种接口，也就是我们最终期望的接口，需要Adapter实现该接口</p></li><li><p>Adaptee源角色</p><p> 想把谁转换为目标角色，此时就是源角色</p></li><li><p>Adapter适配器角色</p><p> 适配器模式的核心角色，它的职责非常简单，将源角色转化为目标角色</p></li></ol><h3 id="类适配器模式"><a href="#类适配器模式" class="headerlink" title="类适配器模式"></a>类适配器模式</h3><p>通过继承来实现适配器模式，由于Java是属于单继承，所以这个使用限制很大。</p><p>Adaptee源角色，里面包含原来的业务逻辑</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 适配器源角色</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mingshan</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adaptee</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 原有的业务逻辑</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"源角色 do something。。。"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Target目标角色， 包含现有的业务逻辑</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 适配器目标角色</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mingshan</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Target</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  目标角色有自己的方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">request</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 目标角色实现类， 现有的业务逻辑</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mingshan</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteTarget</span> <span class="keyword">implements</span> <span class="title">Target</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"xxxxxxxxxxxxxxxxxx"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>适配器角色，需要继承源角色，拿到其里面的方法，然后实现目标角色接口，让源角色与目标角色进行交互</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 适配器角色</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mingshan</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adapter</span> <span class="keyword">extends</span> <span class="title">Adaptee</span> <span class="keyword">implements</span> <span class="title">Target</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.doSomething();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试一下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 类适配器 Test</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mingshan</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 原有的业务逻辑</span></span><br><span class="line">        Target target = <span class="keyword">new</span> ConcreteTarget();</span><br><span class="line">        target.request();</span><br><span class="line">        <span class="comment">// 现在增加了适配器角色后的业务逻辑</span></span><br><span class="line">        Target target2 = <span class="keyword">new</span> Adapter();</span><br><span class="line">        target2.request();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="对象适配器模式"><a href="#对象适配器模式" class="headerlink" title="对象适配器模式"></a>对象适配器模式</h3><p>对象适配器是通过类的关联关系来进行的，是为了解决类适配器模式的问题而出现的，它比类适配器模式灵活，扩展性强，实际运用的比较多。</p><p>这里只解释一些Adapter适配器角色的实现，其他的和类适配器模式一致。</p><p>通过构造器将两个源角色传递进来，实现Target接口，然后就可以进行交互啦</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 适配器角色</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mingshan</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adapter</span> <span class="keyword">implements</span> <span class="title">Target</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Adaptee1 adaptee1;</span><br><span class="line">    <span class="keyword">private</span> Adaptee2 adaptee2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Adapter</span><span class="params">(Adaptee1 adaptee1, Adaptee2 adaptee2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.adaptee1 = adaptee1;</span><br><span class="line">        <span class="keyword">this</span>.adaptee2 = adaptee2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        adaptee1.doSomething();</span><br><span class="line">        adaptee2.doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="代码参考"><a href="#代码参考" class="headerlink" title="代码参考"></a>代码参考</h3><p><a href="https://github.com/mstao/java-explore/tree/master/DesignPattern/src/pers/han/adapter" target="_blank" rel="noopener">https://github.com/mstao/java-explore/tree/master/DesignPattern/src/pers/han/adapter</a></p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 设计模式 </tag>
            
            <tag> 适配器模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>离人</title>
      <link href="/2018/06/22/%E7%A6%BB%E4%BA%BA/"/>
      <url>/2018/06/22/%E7%A6%BB%E4%BA%BA/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>好久不写文章，只因这段时间太忙了，忙到忘记离别的日子已经逼在眼前，倒让人措手不及。当这些繁琐的流程到了末尾，离别的日子真是要到来了。</p><a id="more"></a><p>大学是我目前人生中最充实的时光，回想以前的上学时代，也真让人怀念。十年回首，可喜可悲可叹其实现在也没有多深的记忆了，也或许都释怀了吧。释怀这个词不怎么靠谱，哪里有什么释怀不释怀的，只不过心里能够接受事情的好与坏，不需要过多纠结；明白人总是聚少离多，那些离开的人，可能一辈子也不会再见了。人因为情感变得复杂，也变得有趣。</p><p>最近一直在看梁晓声的《中国人的日常》，印象十分深刻。他谈及自己的初恋，感觉充满一种令人羡慕的稚气与甜蜜，或许是那个时代特有的那种情感，也或许是每个人在经历初恋时都会有的这种感觉。稚气地认为，各自的心灵从此有了依靠，被自己感动，亦被对方感动。在那个年代，爱不可声张，甚至不敢承认，这对于热恋中的人来说是有多么压抑和煎熬。我们都向往纯真，向往无邪，当你向往这些的时候，说明这些早已远离于你，这些也只是虚幻想象的样子，真实早已消失。</p><p>他在谈及在他年幼时遇到改变其一生的启蒙恩师，这是何等幸运。在人生启蒙时代能遇到为他们人生指明道路之人，没有因为一时错念而浪费自己的人生。普通人千千万万，并不是每个人都会遇到指点迷津之人，在混沌的日子里，在无可奈何的岁月中，怎么做到顿悟自我，不浪费自己的生命呢？对于年轻人来说，最浪费时间的事情就是给其讲经验、大道理，讲一万句不如自己去摔一跤，不如自己去尝试一下，眼泪教你做人，后悔帮你成长，疼痛才是人生之师。人生该走的弯路，其实一米也少不了。</p><p>大学让人成长不少，遇到了这么多有趣的人，十分不寂寞。人生遇到了每一个人，其实都有缘分，缘分大也罢，小也罢，都不怎么重要。毕竟在人生漫漫长河中，他们都是那一朵朵的浪花，这是多么的有趣和富有生气，倘若平静死水般，该是多么的无聊与苍白。人生不如意之事七八九，苦事。终归还能与人言一二三，幸事。感谢能遇到一群能一起喝酒玩乐、酒后畅谈之舍友们，共同成长，希望再见如故。</p><p>感慨这么多，还是说句俗话，希望各位万事大吉，天天吃鸡(￣▽￣)／</p><p>放两张照片吧，以此纪念我的大学。</p><p><img src="/images/0731.JPG" alt="image"></p><p><img src="/images/0984.JPG" alt="image"></p><p><img src="/images/0932.JPG" alt="image"></p><p>记于2018/6/22</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大学 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>CentOS7安裝Redis遇到问题及解决</title>
      <link href="/2018/05/23/CentOS7%E5%AE%89%E8%A3%9DRedis%E9%81%87%E5%88%B0%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3/"/>
      <url>/2018/05/23/CentOS7%E5%AE%89%E8%A3%9DRedis%E9%81%87%E5%88%B0%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>前段时间我在我的CentOS7服务器上安装了Redis，遇到了一些问题忘记记录下来了ヽ(￣▽￣)ﾉ，而且我参考网上的教程配置一些脚本的时候发现有错误，根据我对shell的简单理解会介绍一下，毕竟这个东西很常用。</p><a id="more"></a><h2 id="安装Redis"><a href="#安装Redis" class="headerlink" title="安装Redis"></a>安装Redis</h2><p>首先在<strong>/usr/local</strong>目录下创建services 文件夹和其子文件redis,然后进入该文件夹。</p><p>下载redis可以通过wget，我这里下载的是<strong>redis-4.0.2</strong>版本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget http://download.redis.io/releases/redis-4.0.2.tar.gz</span><br></pre></td></tr></table></figure><p>将Redis下载到该文件夹下后，将压缩文件解压</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/services/redis</span><br><span class="line"></span><br><span class="line">tar -xzvf redis-4.0.2.tar.gz</span><br></pre></td></tr></table></figure><p>进入到解压后的文件夹，进行编译即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/services/redis/redis-4.0.2</span><br><span class="line"></span><br><span class="line">make</span><br></pre></td></tr></table></figure><p>编译完后，我们需要将<strong>redis-cli</strong>，<strong>redis-server</strong>，<strong>redis.conf</strong>拷贝到一个单独的文件夹，这里我们在<strong>/usr/local/services/redis</strong> 文件夹下新建一个文件夹<br><strong>redisroot</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /usr/local/services/redis/redisroot</span><br></pre></td></tr></table></figure><p>然后将编译后的<strong>redis-cli</strong>，<strong>redis-server</strong>，<strong>redis.conf</strong>拷贝到<strong>redisroot</strong>文件夹下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cp /usr/local/services/redis/redis-4.0.2/src/redis-server /usr/local/services/redis/redisroot</span><br><span class="line"></span><br><span class="line">cp /usr/local/services/redis/redis-4.0.2/src/redis-cli /usr/local/services/redis/redisroot</span><br><span class="line"></span><br><span class="line">cp /usr/local/services/redis/redis-4.0.2/redis.conf /usr/local/services/redis/redisroot</span><br></pre></td></tr></table></figure><p>拷贝完后的文件夹结构如下：</p><p><img src="/images/redisroot-folder.png" alt="image"></p><h2 id="编辑配置文件"><a href="#编辑配置文件" class="headerlink" title="编辑配置文件"></a>编辑配置文件</h2><p>编辑Redis配置文件</p><p>进入到<strong>redisroot</strong>文件夹，输入下列命令进入编辑模式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim redis.conf</span><br></pre></td></tr></table></figure><p>然后修改以下配置：</p><ol><li>在bind 127.0.0.1前加“#”将其注释掉</li><li>默认为保护模式，把 protected-mode yes 改为 protected-mode no</li><li>默认为不守护进程模式，把daemonize no 改为daemonize yes</li><li>将 requirepass foobared前的“#”去掉，密码改为你想要设置的密码</li></ol><p>设置完后，<strong>ESC</strong>切换模式后输入<strong>:wq!</strong>保存退出</p><h2 id="编辑Redis开机启动脚本"><a href="#编辑Redis开机启动脚本" class="headerlink" title="编辑Redis开机启动脚本"></a>编辑Redis开机启动脚本</h2><p>输入以下命令编辑脚本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/init.d/redis</span><br></pre></td></tr></table></figure><p>打开后在这个文件里添加如下脚本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>!/bin/sh</span><br><span class="line"><span class="meta">#</span> chkconfig: 2345 80 90</span><br><span class="line"><span class="meta">#</span> description: Start and Stop redis</span><br><span class="line"><span class="meta">#</span>PATH=/usr/local/bin:/sbin:/usr/bin:/bin</span><br><span class="line">REDISPORT=6379</span><br><span class="line">EXEC=/usr/local/services/redis/redisroot/redis-server     </span><br><span class="line">REDIS_CLI=/usr/local/services/redis/redisroot/redis-cli     </span><br><span class="line">PIDFILE=/var/run/redis_6379.pid</span><br><span class="line">CONF="/usr/local/services/redis/redisroot/redis.conf"     </span><br><span class="line">RESDISPASSWORD=123456</span><br><span class="line"></span><br><span class="line">case "$1" in</span><br><span class="line">    start)</span><br><span class="line">        if [ -f $PIDFILE ]</span><br><span class="line">        then</span><br><span class="line">                echo "$PIDFILE exists, process is already running or crashed"</span><br><span class="line">        else</span><br><span class="line">                echo "Starting Redis server..."</span><br><span class="line">                $EXEC $CONF</span><br><span class="line">        fi</span><br><span class="line">        if [ "$?"="0" ]</span><br><span class="line">        then</span><br><span class="line">              echo "Redis is running..."</span><br><span class="line">        fi</span><br><span class="line">        ;;</span><br><span class="line">    stop)</span><br><span class="line">        if [ ! -f $PIDFILE ]</span><br><span class="line">        then</span><br><span class="line">                echo "$PIDFILE does not exist, process is not running"</span><br><span class="line">        else</span><br><span class="line">                PID=$(cat $PIDFILE)</span><br><span class="line">                echo "Stopping ..."</span><br><span class="line">                $CLIEXEC -a $RESDISPASSWORD -p$REDISPORT shutdown</span><br><span class="line">                while [ -x $&#123;PIDFILE&#125; ]</span><br><span class="line">               do</span><br><span class="line">                    echo "Waiting for Redis to shutdown ..."</span><br><span class="line">                    sleep 1</span><br><span class="line">                done</span><br><span class="line">                echo "Redis stopped"</span><br><span class="line">        fi</span><br><span class="line">        ;;</span><br><span class="line">   restart|force-reload)</span><br><span class="line">        $&#123;0&#125; stop</span><br><span class="line">        $&#123;0&#125; start</span><br><span class="line">        ;;</span><br><span class="line">  *)</span><br><span class="line">    echo "Usage: /etc/init.d/redis &#123;start|stop|restart|force-reload&#125;" &gt;&amp;2</span><br><span class="line">        exit 1</span><br><span class="line">esac</span><br></pre></td></tr></table></figure><p>脚本中声明的路径常量需要根据自己的安装路径进行配置。</p><p>上面这个脚本是我参考网上的，但网上的有错误，比如我设置了Redis的密码，那么在执行停止命令时是需要验证密码的，所以要这样写<strong>$CLIEXEC -a $RESDISPASSWORD -p$REDISPORT shutdown</strong>。</p><h2 id="后续配置"><a href="#后续配置" class="headerlink" title="后续配置"></a>后续配置</h2><p>下面的一些操作是从网上拷贝的，为后续配置Redis，基本相同</p><h3 id="添加开机启动服务"><a href="#添加开机启动服务" class="headerlink" title="添加开机启动服务"></a>添加开机启动服务</h3><p>编辑<strong>/etc/rc.local</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/rc.local</span><br></pre></td></tr></table></figure><p>增加启动代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service redis start</span><br></pre></td></tr></table></figure><p>编辑后的配置文件如下：</p><p><img src="/images/service-redis-start.png" alt="image"></p><h3 id="设置权限"><a href="#设置权限" class="headerlink" title="设置权限"></a>设置权限</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 755 /etc/init.d/redis</span><br></pre></td></tr></table></figure><h3 id="注册系统服务"><a href="#注册系统服务" class="headerlink" title="注册系统服务"></a>注册系统服务</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chkconfig --add redis</span><br></pre></td></tr></table></figure><h3 id="测试redis服务"><a href="#测试redis服务" class="headerlink" title="测试redis服务"></a>测试redis服务</h3><p>启动服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service redis start</span><br></pre></td></tr></table></figure><p>启动日志如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_37_72_centos redisroot]# service redis start</span><br><span class="line">Starting Redis server...</span><br><span class="line">21416:C 23 May 00:24:19.666 # oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo</span><br><span class="line">21416:C 23 May 00:24:19.666 # Redis version=4.0.2, bits=64, commit=00000000, modified=0, pid=21416, just started</span><br><span class="line">21416:C 23 May 00:24:19.666 # Configuration loaded</span><br><span class="line">Redis is running...</span><br></pre></td></tr></table></figure><p>停止服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service redis stop</span><br></pre></td></tr></table></figure><p>停止日志如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_37_72_centos redisroot]#  service redis stop</span><br><span class="line">Stopping ...</span><br><span class="line">Redis stopped</span><br></pre></td></tr></table></figure><h3 id="创建redis命令软连接"><a href="#创建redis命令软连接" class="headerlink" title="创建redis命令软连接"></a>创建redis命令软连接</h3><p>在linux下很多地方都需要软连接，软连接其实就是windows的快捷方式。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln -s /usr/local/services/redis/redisroot/redis-cli /usr/bin/redis</span><br></pre></td></tr></table></figure><h3 id="测试Redis"><a href="#测试Redis" class="headerlink" title="测试Redis"></a>测试Redis</h3><p>最后可以直接进行测试了</p><p><img src="/images/redis-test.png" alt="image"></p><p>OK, 大功告成。</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>其实这些命令教程啊网上都有，不过有些是错误的，只有自己完完全全测试过一遍后才知道哪些有问题，同时会对Redis有个基本的了解吧，平时都在用Windows，相对来说有些傻瓜式，多敲些Linux命令还是有益处的，哈哈(～￣▽￣)～ </p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/lc1010078424/article/details/78295482" target="_blank" rel="noopener">https://blog.csdn.net/lc1010078424/article/details/78295482</a></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>CentOS7 搭建 Zookeeper-3.4.10 单机服务</title>
      <link href="/2018/05/12/CentOS7%20%E6%90%AD%E5%BB%BA%20Zookeeper-3.4.10%20%E5%8D%95%E6%9C%BA%E6%9C%8D%E5%8A%A1/"/>
      <url>/2018/05/12/CentOS7%20%E6%90%AD%E5%BB%BA%20Zookeeper-3.4.10%20%E5%8D%95%E6%9C%BA%E6%9C%8D%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>由于项目用到了Dubbo,而Dubbo的服务的注册与发现我用了Zookeeper，所以我在部署Dubbo服务的时候，就必须安装Zookeeper,本文记录下我在CentOS7 搭建 Zookeeper-3.4.10 单机服务的过程。</p><a id="more"></a><h3 id="Zookeeper的安装"><a href="#Zookeeper的安装" class="headerlink" title="Zookeeper的安装"></a>Zookeeper的安装</h3><ol><li>下载Zookeeper</li></ol><p>下载最新版本的ZooKeeper，这里有两个镜像可以选择</p><blockquote><p>清华镜像:<a href="https://mirrors.tuna.tsinghua.edu.cn/apache/zookeeper/" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/apache/zookeeper/</a></p><p>阿里镜像:<a href="https://mirrors.aliyun.com/apache/zookeeper/" target="_blank" rel="noopener">https://mirrors.aliyun.com/apache/zookeeper/</a></p></blockquote><p>我就选择阿里镜像进行安装。</p><p>首先在<strong>/usr/local</strong>目录下创建<strong>services</strong> 文件夹和其子文件<strong>zookeeper</strong>,然后进入该文件夹，<br>最后用wget进行下载</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /usr/local/services/zookeeper</span><br><span class="line"></span><br><span class="line">cd /usr/local/services/zookeeper</span><br><span class="line"></span><br><span class="line">wget --no-check-certificate  https://mirrors.aliyun.com/apache/zookeeper/zookeeper-3.4.10/zookeeper-3.4.10.tar.gz</span><br></pre></td></tr></table></figure><ol start="2"><li>提取tar文件</li></ol><p>接下来解压<strong>zookeeper-3.4.10.tar.gz</strong>， 首先进入到该文件夹, 然后进行解压</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/services/zookeeper</span><br><span class="line"></span><br><span class="line">tar -zxf  zookeeper-3.4.10.tar.gz</span><br><span class="line"></span><br><span class="line">cd zookeeper-3.4.10</span><br></pre></td></tr></table></figure><p>进入到解压后的文件夹后，创建<strong>data</strong>文件夹 用于存储数据文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir data</span><br></pre></td></tr></table></figure><p>创建<strong>logs</strong>文件夹 用于存储日志</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir logs</span><br></pre></td></tr></table></figure><ol start="3"><li>创建配置文件</li></ol><p>使用命令 vim conf/zoo.cfg 创建配置文件并打开, 其实该文件夹下有了一个zoo_sample.cfg示例配置文件，我们还是新创建一个吧。</p><p>编辑内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">tickTime = 2000</span><br><span class="line">dataDir = /usr/local/services/zookeeper/zookeeper-3.4.10/data</span><br><span class="line">dataLogDir = /usr/local/services/zookeeper/zookeeper-3.4.10/logs</span><br><span class="line">tickTime = 2000</span><br><span class="line">clientPort = 2181</span><br><span class="line">initLimit = 5</span><br><span class="line">syncLimit = 2</span><br></pre></td></tr></table></figure><h3 id="Zookeeper服务"><a href="#Zookeeper服务" class="headerlink" title="Zookeeper服务"></a>Zookeeper服务</h3><ol><li>启动服务</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/services/zookeeper/zookeeper-3.4.10/bin/zkServer.sh start</span><br></pre></td></tr></table></figure><ol start="2"><li>连接服务</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/services/zookeeper/zookeeper-3.4.10/bin/zkCli.sh</span><br></pre></td></tr></table></figure><ol start="3"><li>查看服务状态</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/services/zookeeper/zookeeper-3.4.10/bin/zkServer.sh status</span><br></pre></td></tr></table></figure><ol start="4"><li>停止服务</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/services/zookeeper/zookeeper-3.4.10/bin/zkServer.sh stop</span><br></pre></td></tr></table></figure><h3 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h3><p><a href="https://segmentfault.com/a/1190000010791627" target="_blank" rel="noopener">https://segmentfault.com/a/1190000010791627</a></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Zookeeper </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>利用WebMagic来爬取ZZULI的通知</title>
      <link href="/2018/05/08/%E5%88%A9%E7%94%A8WebMagic%E6%9D%A5%E7%88%AC%E5%8F%96ZZULI%E7%9A%84%E9%80%9A%E7%9F%A5/"/>
      <url>/2018/05/08/%E5%88%A9%E7%94%A8WebMagic%E6%9D%A5%E7%88%AC%E5%8F%96ZZULI%E7%9A%84%E9%80%9A%E7%9F%A5/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="WebMagic介绍"><a href="#WebMagic介绍" class="headerlink" title="WebMagic介绍"></a>WebMagic介绍</h2><p>WebMagic是一个开源的Java垂直爬虫框架，目标是简化爬虫的开发流程，让开发者专注于逻辑功能的开发。最近项目有需求爬取某些网站的信息，考虑到WebMagic的爬虫实现十分精简和扩展性很高，所以爬虫模块就采用了WebMagic来爬取网站的一些信息。</p><a id="more"></a><p>WebMagic的结构分为Downloader、PageProcessor、Scheduler、Pipeline四大组件，并由Spider将它们彼此组织起来。这四大组件对应爬虫生命周期中的下载、处理、管理和持久化等功能。WebMagic的总体架构图如下：</p><p><img src="/images/webmagic.jpg" alt="image"></p><p>从上面的架构图中可以看出，我们在下载完页面后需要自己定义规则来抽取信息和发现链接，同时控制爬虫爬取深度，所以需要自定义PageProcessor来进行以上操作。而通过定制Pipeline，我们还可以实现保存结果到文件、数据库等一系列功能，所以我们可以根据自己的需求来自定义Pipeline。</p><h2 id="爬虫实现"><a href="#爬虫实现" class="headerlink" title="爬虫实现"></a>爬虫实现</h2><h3 id="示例介绍"><a href="#示例介绍" class="headerlink" title="示例介绍"></a>示例介绍</h3><p>通过上面的分析，我们就可以来爬取特定页面的信息了。本次爬取的网站是<strong><a href="http://www.zzuli.edu.cn/s/12/t/1006/p/22/i/13/list.htm" target="_blank" rel="noopener">http://www.zzuli.edu.cn/s/12/t/1006/p/22/i/13/list.htm</a></strong>，我们需要爬取的页面主要是列表+详情的基本页面组合，有一个列表页，这个列表页以分页的形式展现，我们可以遍历这些分页找到所有目标页面。我们要从通知的详细界面，来抓取通知的标题、内容、日期等信息，也要从列表页抓取的链接等信息，从而获取这个通知的所有文章。</p><h4 id="列表页"><a href="#列表页" class="headerlink" title="列表页"></a>列表页</h4><p> 列表页的格式如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://www.zzuli.edu.cn/s/12/t/1006/p/22/i/13/list.htm</span><br></pre></td></tr></table></figure></p><p>其中i后面的13是可变的，根据上一页和下一页的切换来改变这一个数字，页面如下：</p><p><img src="/images/spide-list-page.png" alt="image"></p><h4 id="详细页"><a href="#详细页" class="headerlink" title="详细页"></a>详细页</h4><p>详细页的格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http://www.zzuli.edu.cn/s/12/t/1006/e8/ff/info190719.htm</span><br><span class="line">http://www.zzuli.edu.cn/s/12/t/1006/e5/65/info189797.htm</span><br></pre></td></tr></table></figure><p>通过观察这两个url，可以发现1006后面的都是可以变的，所以可以根据这个来写正则抽取链接。</p><p>详细页页面如下：<br><img src="/images/spide-detail-page.png" alt="image"></p><h3 id="发现通知URL"><a href="#发现通知URL" class="headerlink" title="发现通知URL"></a>发现通知URL</h3><p>在这个爬虫需求中，我们需要知道这些详细通知的URL，所以如何抽取这些URL显得很重要，事实也是如此，也是我们要实现爬虫的第一步。我们可以先考虑用以下正则表达式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://www\\.zzuli\\.edu\\.cn/s/12/t/1006/\\w+/\\w+/info\\d+\\.htm</span><br></pre></td></tr></table></figure></p><p>来过滤通知的详细界面，但这样未免太过宽泛，爬取效率也比较低，此时考虑到列表页中含有通知的详细界面的URL，所以我们必须从列表页中指定的区域获取URL。</p><p>在这里，我们使用xpath //table[@id=\”newslist\”]选中所有区域，再使用links()获取所有链接，最后再使用正则表达式<a href="http://www\\.zzuli\\.edu\\.cn/s/12/t/1006/\\w+/\\w+/info\\d+\\.htm，" target="_blank" rel="noopener">http://www\\.zzuli\\.edu\\.cn/s/12/t/1006/\\w+/\\w+/info\\d+\\.htm，</a> 对URL进行过滤，去掉一些其他无用的链接。于是，我们可以这样写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">page.addTargetRequests(page.getHtml().xpath(&quot;//table[@id=\&quot;newslist\&quot;]&quot;).links().regex(URL_POST).all());</span><br></pre></td></tr></table></figure><p>同时，我们需要把所有找到的列表页也加到待下载的URL中去：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">page.addTargetRequests(page.getHtml().links().regex(URL_LIST).all());</span><br></pre></td></tr></table></figure><h3 id="抽取内容"><a href="#抽取内容" class="headerlink" title="抽取内容"></a>抽取内容</h3><p>抽取页面所需要的信息对于爬虫应用来说是关键的一步，同时也是比较简单的，因为我们可以用xpath来解析html，定义好抽取表达式就可以了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">page.putField(<span class="string">"title"</span>, page.getHtml().xpath(<span class="string">"//h1[@class='arti-title']/text()"</span>));</span><br><span class="line">page.putField(<span class="string">"content"</span>, page.getHtml().xpath(<span class="string">"//div[@class='read']"</span>));</span><br><span class="line">page.putField(<span class="string">"date"</span>,</span><br><span class="line">        page.getHtml().xpath(<span class="string">"//div[@class='arti-metas']/table/tbody/tr/td[3]/span/text()"</span>).replace(<span class="string">"日期："</span>, <span class="string">""</span>));</span><br></pre></td></tr></table></figure><h3 id="列表页和详细页"><a href="#列表页和详细页" class="headerlink" title="列表页和详细页"></a>列表页和详细页</h3><p>我们可以定义几个常量来定义列表页和详细页的URL：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DOMAIN = <span class="string">"http://www\\.zzuli\\.edu\\.cn"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String URL_LIST = DOMAIN + <span class="string">"/s/12/t/1006/p/22/i/\\d+/list\\.htm"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String URL_POST = DOMAIN + <span class="string">"/s/12/t/1006/\\w+/\\w+/info\\d+\\.htm"</span>;</span><br></pre></td></tr></table></figure><p>我们可以根据URL_LIST和URL_POST来区别列表页和详细页的抽取。</p><h3 id="保存信息"><a href="#保存信息" class="headerlink" title="保存信息"></a>保存信息</h3><p>我们可以自定义Pipeline来将抽取的结果保存在想要的地方，这里我直接将标题、内容、日期等信息封装为实体，然后放到List中，便于后续处理，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义Pipeline，用来处理爬到的数据</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mingshan</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NoticePipeline</span> <span class="keyword">implements</span> <span class="title">Pipeline</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(ResultItems resultItems, Task task)</span> </span>&#123;</span><br><span class="line">        Notice notice = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            notice = <span class="keyword">new</span> Notice(resultItems.getAll());</span><br><span class="line">            notice.setLink(resultItems.getRequest().getUrl());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        NoticeList.addNotice(notice);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过以上的爬虫的实现，我们主要根据列表页来抽取所需要的通知详细页的URL，然后通过xpath来解析页面，获取特定的信息。如此简洁的逻辑和代码得益于WebMagic框架良好的封装，同时扩展性很强，推荐大家使用。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>主要参考WebMagic的官方文档和samples。</p><p><a href="http://webmagic.io/docs/zh/" target="_blank" rel="noopener">http://webmagic.io/docs/zh/</a></p>]]></content>
      
      
      <categories>
          
          <category> 爬虫 </category>
          
          <category> WebMagic </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WebMagic </tag>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>在Linux(CentOS)下重置MySQL根(Root)密码</title>
      <link href="/2018/05/05/%E5%9C%A8Linux(CentOS)%E4%B8%8B%E9%87%8D%E7%BD%AEMySQL%E6%A0%B9(Root)%E5%AF%86%E7%A0%81/"/>
      <url>/2018/05/05/%E5%9C%A8Linux(CentOS)%E4%B8%8B%E9%87%8D%E7%BD%AEMySQL%E6%A0%B9(Root)%E5%AF%86%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>我的CentOS服务器的mysql密码忘了，记录一下如何重置mysql的root密码</p><p>下面是操作步骤：</p><a id="more"></a><ol><li><p>首先输入“service mysqld status”查看当前mysql服务状态。</p></li><li><p>输入“killall -TERM mysqld”命令停止所有的mysqld进程。</p></li><li><p>输入“service mysqld stop”命令停止mysqld服务。</p></li><li><p>输入“mysqld_safe  –skip-grant-tables &amp;”命令以无密码方式进入MySQL安全模式。</p></li><li><p>输入“mysql -u root”并按回车键即可。</p></li><li><p>输入“use mysql;”挂载数据库。(注意：请勿忘记在最后输入分号（;）)</p></li><li><p>输入”update user set password=password(“admin”) where user=’root’;”将Root密码修改为admin。</p></li><li><p>输入”flush privileges;”更新权限。</p></li><li><p>输入“quit”并按回车键退出。(注意：此处不需输入分号。)</p></li><li><p>输入”service mysqld restart”重启mysqld服务。</p></li><li><p>输入“mysql -u root -p”并按回车键提示输入密码。</p></li><li><p>输入新密码admin并按回车键，提示已经成功登录。</p></li></ol><p>下面是所有步骤运行截图：</p><p><img src="/images/update_mysql_password.png" alt="image"></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>理解GC日志</title>
      <link href="/2018/04/17/%E7%90%86%E8%A7%A3GC%E6%97%A5%E5%BF%97/"/>
      <url>/2018/04/17/%E7%90%86%E8%A7%A3GC%E6%97%A5%E5%BF%97/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="输出GC日志"><a href="#输出GC日志" class="headerlink" title="输出GC日志"></a>输出GC日志</h3><p>通过阅读GC日志，我们可以了解Java虚拟机内存分配与回收策略。<br>先来看一个简单的示例。</p><p>下面是GC日志：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">0.115: [GC (System.gc()) [PSYoungGen: 3020K-&gt;600K(38400K)] 3020K-&gt;608K(125952K), 0.0012295 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span><br><span class="line">0.117: [Full GC (System.gc()) [PSYoungGen: 600K-&gt;0K(38400K)] [ParOldGen: 8K-&gt;554K(87552K)] 608K-&gt;554K(125952K), [Metaspace: 2773K-&gt;2773K(1056768K)], 0.0060759 secs] [Times: user=0.00 sys=0.00, real=0.01 secs] </span><br><span class="line">Heap</span><br><span class="line"> PSYoungGen      total 38400K, used 333K [0x00000000d5f00000, 0x00000000d8980000, 0x0000000100000000)</span><br><span class="line">  eden space 33280K, 1% used [0x00000000d5f00000,0x00000000d5f534a8,0x00000000d7f80000)</span><br><span class="line">  from space 5120K, 0% used [0x00000000d7f80000,0x00000000d7f80000,0x00000000d8480000)</span><br><span class="line">  to   space 5120K, 0% used [0x00000000d8480000,0x00000000d8480000,0x00000000d8980000)</span><br><span class="line"> ParOldGen       total 87552K, used 554K [0x0000000081c00000, 0x0000000087180000, 0x00000000d5f00000)</span><br><span class="line">  object space 87552K, 0% used [0x0000000081c00000,0x0000000081c8aab8,0x0000000087180000)</span><br><span class="line"> Metaspace       used 2779K, capacity 4486K, committed 4864K, reserved 1056768K</span><br><span class="line">  class space    used 300K, capacity 386K, committed 512K, reserved 1048576K</span><br></pre></td></tr></table></figure><a id="more"></a><p>上面的GC日志是由下面的Java代码产生的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * GC 日志</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mingshan</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GCLogDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> _1m = <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line">        <span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[_1m];</span><br><span class="line">        <span class="comment">// 将data置为null即让它成为垃圾</span></span><br><span class="line">        data = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 通知垃圾回收器回收垃圾（help gc）</span></span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Eclipse中以运行配置方式运行上面的代码，并设置VM参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:+PrintGCTimeStamps</span><br><span class="line">-XX:+PrintGCDetails</span><br></pre></td></tr></table></figure><h3 id="GC日志说明："><a href="#GC日志说明：" class="headerlink" title="GC日志说明："></a>GC日志说明：</h3><p>先看这两行GC日志</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0.115: [GC (System.gc()) [PSYoungGen: 3020K-&gt;600K(38400K)] 3020K-&gt;608K(125952K), 0.0012295 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span><br><span class="line">0.117: [Full GC (System.gc()) [PSYoungGen: 600K-&gt;0K(38400K)] [ParOldGen: 8K-&gt;554K(87552K)] 608K-&gt;554K(125952K), [Metaspace: 2773K-&gt;2773K(1056768K)], 0.0060759 secs] [Times: user=0.00 sys=0.00, real=0.01 secs]</span><br></pre></td></tr></table></figure><p>通过观察这两行日志发现，它们的格式相同，下面是对其格式的描述：</p><p>GC发生时间: [垃圾收集停顿类型: [GC发生区域: GC前该内存区域已使用容量 -&gt; GC后该内存区域已使用容量(该内存区域总容量)] 该内存区域GC所占用的时间] GC前Java堆已使用容量 -&gt; GC后Java堆已使用容量(Java堆总容量)] [user表示用户态消耗的CPU时间，sys表示内核态消耗的CPU时间，real表示操作从开始到结束所经过的墙钟时间]。</p><h3 id="GC日志解读"><a href="#GC日志解读" class="headerlink" title="GC日志解读"></a>GC日志解读</h3><p>最前面的数字“0.115:”和“0.117:”代表GC发生的时间，是从Java虚拟机启动以来经过的秒数。</p><p>GC日志开头的”[GC” 和”[Full GC”说明这个GC的停顿类型，而不是用来判断是新生代GC还是老年代GC，其中“[Full GC”说明发生了Stop-The-World。这里出现了“(System.gc())”，说明是调用了System.gc()方法所触发的搜集。</p><p>接下来的“[PSYoungGen:”代表GC发生的区域，而且这里显示的区域名称与使用的GC收集器名称密切相关。PSYoungGen，表示新生代使用的是多线程垃圾收集器Parallel Scavenge。</p><p>方括号内部的“3020K-&gt;600K(38400K)”代表“GC前该内存区域已使用容量 -&gt; GC后该内存区域已使用容量(该内存区域总容量)”。而在方括号外面的“3020K-&gt;608K(125952K)”表示”该内存区域GC所占用的时间] GC前Java堆已使用容量 -&gt; GC后Java堆已使用容量(Java堆总容量)”。</p><p>再往后的“0.0012295 secs”代表该内存区域GC所占用的时间，单位为秒。后面的“[Times: user=0.00 sys=0.00, real=0.00 secs] ”为具体的时间信息。其中user表示用户态消耗的CPU时间，sys表示内核态消耗的CPU时间，real表示操作从开始到结束所经过的墙钟时间（Wall Clock Time）。钟时间包括各种非运算的等待耗时，如IO等待、线程阻塞。CPU时间不包括等待时间，当系统有多核或者多个CPU时，多线程操作会叠加这些CPU时间，所以user或sys时间会超过real时间。</p><h3 id="堆详细信息解读："><a href="#堆详细信息解读：" class="headerlink" title="堆详细信息解读："></a>堆详细信息解读：</h3><p>下面是堆详细信息的日志：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Heap</span><br><span class="line"> PSYoungGen      total 38400K, used 333K [0x00000000d5f00000, 0x00000000d8980000, 0x0000000100000000)</span><br><span class="line">  eden space 33280K, 1% used [0x00000000d5f00000,0x00000000d5f534a8,0x00000000d7f80000)</span><br><span class="line">  from space 5120K, 0% used [0x00000000d7f80000,0x00000000d7f80000,0x00000000d8480000)</span><br><span class="line">  to   space 5120K, 0% used [0x00000000d8480000,0x00000000d8480000,0x00000000d8980000)</span><br><span class="line"> ParOldGen       total 87552K, used 554K [0x0000000081c00000, 0x0000000087180000, 0x00000000d5f00000)</span><br><span class="line">  object space 87552K, 0% used [0x0000000081c00000,0x0000000081c8aab8,0x0000000087180000)</span><br><span class="line"> Metaspace       used 2779K, capacity 4486K, committed 4864K, reserved 1056768K</span><br><span class="line">  class space    used 300K, capacity 386K, committed 512K, reserved 1048576K</span><br></pre></td></tr></table></figure><p>先了解下Java memory划分：</p><p>Java memory主要分heap memory 和 non-heap memory，如下图：</p><p><img src="/images/java-memory.jpg" alt="image"></p><p>第一行为新生代的大小，大小为38400K。而新生代又分为三个区域分别叫Eden，和俩个Survivor spaces。Eden用来存放新的对象，Survivor spaces用于 新对象 升级到 Tenured area时的 拷贝。默认的，Edem : from : to = 8 : 1 : 1 ( 可以通过参数 –XX:SurvivorRatio 来设定 )，即： Eden = 8/10 的新生代空间大小，from = to = 1/10 的新生代空间大小。</p><p>默认的，新生代 ( Young ) 与老年代 ( Old ) 的比例的值为 1:2 ( 该值可以通过参数 –XX:NewRatio 来指定 )，即：新生代 ( Young ) = 1/3 的堆空间大小。老年代 ( Old ) = 2/3 的堆空间大小。其中，新生代 ( Young ) 被细分为 Eden 和 两个 Survivor 区域，这两个 Survivor 区域分别被命名为 from 和 to，以示区分。 </p><p> ParOldGen 为老年代，大小为87552K，大约为PSYoungGen内存大小的2倍。 从JDK8开始，永久代(PermGen)的概念被废弃掉了，取而代之的是一个称为Metaspace的存储空间。Metaspace与PermGen之间最大的区别在于：Metaspace并不在虚拟机中，而是使用本地内存。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol><li>深入理解Java虚拟机：JVM高级特性与最佳实践（第2版）</li><li><a href="https://segmentfault.com/a/1190000012577387" target="_blank" rel="noopener">https://segmentfault.com/a/1190000012577387</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
          <category> GC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> GC </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Git合并多个commit</title>
      <link href="/2018/03/26/Git%E5%90%88%E5%B9%B6%E5%A4%9A%E4%B8%AAcommit/"/>
      <url>/2018/03/26/Git%E5%90%88%E5%B9%B6%E5%A4%9A%E4%B8%AAcommit/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在我们做新功能的时候，我们可能需要自己新建一个分支，然后在这个分支上开发，由于功能复杂或者功能点很多，或者每改动一个重要的地方都要进行提交一次，这样自己在测试开发时方便回滚等操作，会产生多个临时的commit，这些临时commit其实才是一个功能点，在向团队开发分支合并代码的时候，我们为了避免太多的 commit 而造成版本控制的混乱，通常我们推荐将这些 commit 合并成一个。</p><a id="more"></a><p><strong>1. git log查看提交记录</strong></p><p>首先我们利用<strong>git log</strong>查看当前分支提交的历史，最近提交在最上面，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">commit 2d6454c942f3961ad351caf145bedf29c4d3743c</span><br><span class="line"></span><br><span class="line">commit d059f47fd7ab863353cd98fb29c98ceb1fe97845</span><br><span class="line"></span><br><span class="line">commit 951522a48081b8ab4a529fee706d94c8fe3b16c8</span><br><span class="line"></span><br><span class="line">commit 1d85c5a75128b6127de90b9db367dc9d67bdd17a</span><br></pre></td></tr></table></figure><p><strong>2. git rebase</strong></p><p>这里用到了<strong>git rebase</strong>命令，这个命令主要用于更新代码和合并commit。假设你本地和服务器目前是同步的，然后你本地做了几次commit，其他人向服务器推送了commit。如果你希望同步服务器的commit，但是本地的commit又不想push到服务器的时候(比如你开发完某个功能，可能需要5个commit)。先fetch，然后rebase服务器的代码。</p><p>这里想要合并 1~2的commit，有两种方式</p><ol><li>从HEAD开始往后合并两次提交</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase -i HEAD~2</span><br></pre></td></tr></table></figure><ol start="2"><li>指定要合并的commit之前的版本号</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase -i 951522a</span><br></pre></td></tr></table></figure><p>此时951522a这个commit不参与合并</p><p><strong>3. 选取要合并的提交</strong></p><p>当输入完以上两个命令会弹出一个文本文件，内容前几行如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pick d059f47 add test.txt</span><br><span class="line">pick 2d6454c Update test.txt</span><br></pre></td></tr></table></figure><p>此时将第二个pick改为squash或者s,之后保存并关闭文本编辑窗口即可。改完之后文本内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p d059f47 add test.txt</span><br><span class="line">s 2d6454c Update test.txt</span><br></pre></td></tr></table></figure><p>保存后会弹出一个新文件，前面是你刚才要合并的两条 commit message，然后将这两条commit message删除，然后重新设置新的message，保存退出，如下： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># This is a combination of 2 commits.</span><br><span class="line"></span><br><span class="line"># This is the commit message #2:</span><br><span class="line"></span><br><span class="line">Add and update test.txt</span><br></pre></td></tr></table></figure><p>最后就可以发现两条commit message 已经合并为一条了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">commit 9fff5fa09e09836ff2c535486ced2a66f8e4c19a</span><br><span class="line">Author: Juntao Han &lt;499445428@qq.com&gt;</span><br><span class="line">Date:   Mon Mar 26 21:24:47 2018 +0800</span><br><span class="line"></span><br><span class="line">    Add and update test.txt</span><br><span class="line"></span><br><span class="line">commit 951522a48081b8ab4a529fee706d94c8fe3b16c8</span><br><span class="line">Author: Juntao Han &lt;499445428@qq.com&gt;</span><br><span class="line">Date:   Mon Mar 26 21:03:29 2018 +0800</span><br><span class="line"></span><br><span class="line">    update  .gitignore</span><br><span class="line"></span><br><span class="line">commit 1d85c5a75128b6127de90b9db367dc9d67bdd17a</span><br><span class="line">Author: Juntao Han &lt;499445428@qq.com&gt;</span><br><span class="line">Date:   Mon Mar 26 20:59:13 2018 +0800</span><br><span class="line"></span><br><span class="line">    :octocat: Added .gitattributes &amp; .gitignore files</span><br></pre></td></tr></table></figure><p>接下来推送到git服务器就好了</p>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
            <tag> rebase </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>关于git reabse的使用</title>
      <link href="/2018/03/15/%E5%85%B3%E4%BA%8Egit%20reabse%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2018/03/15/%E5%85%B3%E4%BA%8Egit%20reabse%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>由于在工作中用到了git rebase命令，所以记录一下。</p><p>比如当前在location-scan 分支做一个新功能，当新功能做完了，然后发pull request请求合并到develop分支，但在你提交pull request 之前，有人改动了develop分支的代码，导致你的代码与develop分支的代码发生了冲突， 由于有冲突，需要从develop分支将代码拉到location-scan 分支，进行代码的合并，然后再进行提交，此时的提交没有合并过的痕迹，所以此时我们就需要用到了git rebase命令了，具体的使用的流程：</p><a id="more"></a><ol><li>拉取远程develop分支代码，并与当前分支的代码合并</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase origin/develop</span><br></pre></td></tr></table></figure><ol start="2"><li>添加代码到暂存区</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br></pre></td></tr></table></figure><ol start="3"><li>如果让git继续应用(apply)余下的补丁，那么就用–continue参数</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase --continue</span><br></pre></td></tr></table></figure><ol start="4"><li>如果想让git放弃此次合并，那么就用–abort参数来终止rebase的动作</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase --abort</span><br></pre></td></tr></table></figure><ol start="5"><li>如果你想多次的提交都有第一次的提交合并，那么就用–amend参数</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit --amend (合并commit)</span><br></pre></td></tr></table></figure><ol start="6"><li>如果需要 将文件从暂存区取消，那么执行以下命令</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset HEAD &lt;file&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
            <tag> rebase </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>设计模式之Builder模式</title>
      <link href="/2018/03/09/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8BBuilder%E6%A8%A1%E5%BC%8F/"/>
      <url>/2018/03/09/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8BBuilder%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>当我们在创建对象的时候，如果对象需要很多的参数，并且有些参数是可选的，有些是必选的，有的可能默认值，这个时候如果我们用构造器传参或者通过set方法进行属性值设置，那么这样就有很大的问题，比如别人在创建这个对象的时候，并不知道需要传哪些参数，哪些参数是必须传值的，而且调用也不方便，所有我们就可以用到Builder模式，这里就是所谓的链式调用。在Effective Java书中， 第2条就是遇到到多个构造器时要考虑用构造器，里面讲的比较详细。</p><p>比如我们想这样创建一个对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> User.Builder(<span class="string">"Walker"</span>, <span class="string">"Han"</span>)</span><br><span class="line">        .age(<span class="number">20</span>)</span><br><span class="line">        .phone(<span class="string">"123456789"</span>)</span><br><span class="line">        .address(<span class="string">"166号"</span>)</span><br><span class="line">        .build();</span><br></pre></td></tr></table></figure><a id="more"></a><p>此时我们需要在User类中创建一个内部类Builder，该类用来创建User对象，通过上面的代码我们发现，可以连续调用属性的方法进行传参，这就要求每次调用后都要返回当前对象，这样才能连续调用，下面是代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 链式调用</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mingshan</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String firstName; <span class="comment">// 必传参数 </span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String lastName; <span class="comment">// 必传参数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age; <span class="comment">// 可选参数</span></span><br><span class="line">    <span class="keyword">private</span> String phone; <span class="comment">// 可选参数 </span></span><br><span class="line">    <span class="keyword">private</span> String address; <span class="comment">// 可选参数</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">User</span><span class="params">(Builder builder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.firstName = builder.firstName;</span><br><span class="line">        <span class="keyword">this</span>.lastName = builder.lastName;</span><br><span class="line">        <span class="keyword">this</span>.age = builder.age;</span><br><span class="line">        <span class="keyword">this</span>.phone = builder.phone;</span><br><span class="line">        <span class="keyword">this</span>.address = builder.address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"User [firstName="</span> + firstName + <span class="string">", lastName="</span> + lastName + <span class="string">", age="</span> + age + <span class="string">", phone="</span> + phone</span><br><span class="line">                + <span class="string">", address="</span> + address + <span class="string">"]"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> String firstName;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> String lastName;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">        <span class="keyword">private</span> String phone;</span><br><span class="line">        <span class="keyword">private</span> String address;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Builder</span><span class="params">(String firstName, String lastName)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.firstName = firstName;</span><br><span class="line">            <span class="keyword">this</span>.lastName = lastName;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">age</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.age = age;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">phone</span><span class="params">(String phone)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.phone = phone;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">address</span><span class="params">(String address)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.address = address;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> User <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> User(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后就可以像上面的方式进行调用了。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 设计模式 </tag>
            
            <tag> Builder模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Linux搭建Java Web环境(JDK8, Tomcat8.5, Nginx)</title>
      <link href="/2018/01/01/Linux%E6%90%AD%E5%BB%BAJava%20Web%E7%8E%AF%E5%A2%83(JDK8,%20Tomcat8.5,%20Nginx)/"/>
      <url>/2018/01/01/Linux%E6%90%AD%E5%BB%BAJava%20Web%E7%8E%AF%E5%A2%83(JDK8,%20Tomcat8.5,%20Nginx)/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="安装JDK"><a href="#安装JDK" class="headerlink" title="安装JDK"></a>安装JDK</h3><p>首先下载jdk-8u172-linux-x64.tar.gz，然后上传到服务器<strong>/usr/local/java</strong>目录</p><p>解压jdk-8u172-linux-x64.tar.gz</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf jdk-8u172-linux-x64.tar.gz</span><br></pre></td></tr></table></figure><p>设置环境变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/profile</span><br></pre></td></tr></table></figure><p>在最前面添加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">export JAVA_HOME=/usr/local/java/jdk1.8.0_172 </span><br><span class="line">export JRE_HOME=$&#123;JAVA_HOME&#125;/jre  </span><br><span class="line">export CLASSPATH=.:$&#123;JAVA_HOME&#125;/lib:$&#123;JRE_HOME&#125;/lib  </span><br><span class="line">export  PATH=$&#123;JAVA_HOME&#125;/bin:$PATH</span><br></pre></td></tr></table></figure><p>输入:wq!保存退出</p><p>执行profile文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure><p>这样可以使配置不用重启即可立即生效。</p><p>检查新安装的jdk</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -version</span><br></pre></td></tr></table></figure><p>显示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">java version &quot;1.8.0_172&quot;</span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_172-b11)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.172-b11, mixed mode)</span><br></pre></td></tr></table></figure><h3 id="安装Tomcat8-5"><a href="#安装Tomcat8-5" class="headerlink" title="安装Tomcat8.5"></a>安装Tomcat8.5</h3><p>下载tomcat到/usr/local/tomcat</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ wget http://redrockdigimark.com/apachemirror/tomcat/tomcat-8/v8.5.23/bin/apache-tomcat-8.5.23.tar.gz</span><br></pre></td></tr></table></figure><p>解压：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf apache-tomcat-8.5.23.tar.gz</span><br></pre></td></tr></table></figure><p>启动：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh startup.sh</span><br></pre></td></tr></table></figure><h3 id="安装Nginx"><a href="#安装Nginx" class="headerlink" title="安装Nginx"></a>安装Nginx</h3><p>开始前，请确认gcc g++开发类库是否装好，默认已经安装。</p><p>centos平台编译环境使用如下指令</p><p>安装make：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install gcc automake autoconf libtool make</span><br></pre></td></tr></table></figure><p>安装g++:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install gcc gcc-c++</span><br></pre></td></tr></table></figure><p>下面正式开始安装</p><p>选择安装目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/nignx</span><br></pre></td></tr></table></figure><p><strong>安装PCRE库</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/nignx</span><br><span class="line">wget ftp://ftp.csx.cam.ac.uk/pub/software/programming/pcre/pcre-8.39.tar.gz </span><br><span class="line">tar -zxvf pcre-8.39.tar.gz</span><br><span class="line">cd pcre-8.39</span><br><span class="line">./configure</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><p><strong>安装zlib库</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/nignx</span><br><span class="line"> </span><br><span class="line">wget http://zlib.net/zlib-1.2.11.tar.gz</span><br><span class="line">tar -zxvf zlib-1.2.11.tar.gz</span><br><span class="line">cd zlib-1.2.11</span><br><span class="line">./configure</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><p><strong>安装openssl</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/nignx</span><br><span class="line">wget https://www.openssl.org/source/openssl-1.0.1t.tar.gz</span><br><span class="line">tar -zxvf openssl-1.0.1t.tar.gz</span><br></pre></td></tr></table></figure><p><strong>启动nginx</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/nginx/sbin/nginx</span><br></pre></td></tr></table></figure><p><strong>查看进程</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef|grep nginx</span><br></pre></td></tr></table></figure><p><strong>其他命令</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nginx -s reload ：修改配置后重新加载生效</span><br><span class="line">nginx -s reopen ：重新打开日志文件</span><br><span class="line">nginx -t -c /usr/local/nginx/conf/nginx.conf  测试nginx配置文件是否正确</span><br></pre></td></tr></table></figure><p><strong>firewalld的基本使用</strong></p><p>启动： <code>systemctl start firewalld</code></p><p>查看状态： <code>systemctl status firewalld</code></p><p>停止： <code>systemctl disable firewalld</code></p><p>禁用： <code>systemctl stop firewalld</code></p><p><strong>查看firewall是否运行</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl status firewalld.service</span><br></pre></td></tr></table></figure><p><strong>添加开放端口</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --zone=public --add-port=80/tcp --permanent    （--permanent永久生效，没有此参数重启后失效）</span><br></pre></td></tr></table></figure><p><strong>查看所有打开的端口：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --zone=public --list-ports</span><br></pre></td></tr></table></figure><p><strong>更新防火墙规则：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>忽然之间</title>
      <link href="/2017/12/24/%E5%BF%BD%E7%84%B6%E4%B9%8B%E9%97%B4/"/>
      <url>/2017/12/24/%E5%BF%BD%E7%84%B6%E4%B9%8B%E9%97%B4/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>不知不觉，发现时间过得好快，出来实习的时间已经过去了大半年，毕业的日子马上就要来了，2017即将消逝，有必要写些什么。</p><a id="more"></a><p>从今年七月份开始就开始实习，感觉实习阶段对于刚踏入编程这个行业的人来说还是很重要的，因为这一年会让你知道你擅长哪个领域，应该深钻哪门编程语言(或许)，但并不是每个人都是如此，至少我不是，因为我实习主要用的语言并不是我喜欢的语言，对于一个自己不喜欢的语言当然不愿意花费过多的时间在上面，因为人的精力是有限的。随着编程的逐渐深入，会发现想要学好一门语言不是那么容易的，如果认为一门语言就简单使用语法和库，那么未免也太浅薄了。就拿我喜欢用的Java来说吧，才开始可能感觉会一些API和常用的框架就能做些东西，并不需要一些多么高深的东西，数据结构基本用不上，而且好用的工具一抓一大把，感觉编程是比较容易的，但事实上是这样的吗？显示不是，当你不满足于仅使用API和框架的时候，还想了解这些API的源码和框架的设计实现原理，你会发现许多问题都会迎面而来，而且大部分都是老问题，比如你想看集合的源码，想知道ArrayList和HashMap到底是怎么实现的，数据在其内部是如何进行存储的，这时候数据结构就派上用场了，如果你想自己造个轮子，也实现一把HashMap，你就需要对HashMap的数据结构了如指掌，这样的话当你再次使用HashMap的时候，其结构和实现原理就会在你大脑里飞转，想忘也忘不了。</p><p>对于我这种初学者来说，深知自己学会造轮子的重要性，虽然说自己写的基本上没有现成的轮子好使，但这些轮子并不代表对你没用，反而作用很大。比如我看了Java的并发包的ArrayBlockingQueue的源码，那么我自己试试能不能写个功能差不多的类呢，如果实现原理知道的话，那么基本功能还是可以写出来的。这个时候还有一件非常重要的事需要考虑，那就是学习源码优秀的代码结构和设计，设计模式是必不可少的，只有掌握了这些，才能深刻的明白写代码是怎么一回事，现在算是初级小码农( ¨̮ )</p><p>一晃眼从初中到大学毕业差不多十年过去了，时间还真是个无情的猎手，猎杀着世间容易消失的一切，那些存在着，消失的，以及后悔不后悔着的，或许都溶于自己的内心，再也看不到以前的样子了。</p><p>忽然之间，天昏地暗。最后发现孤独的还是自己，痛苦和快乐着的还是自己。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>二叉搜索树结构分析</title>
      <link href="/2017/12/24/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90/"/>
      <url>/2017/12/24/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>二叉查找树（Binary Search Tree），（又：二叉搜索树，二叉排序树），它具有以下特点：</p><ol><li>若任意节点的左子树不空，则左子树上所有结点的值均小于它的根结点的值；</li><li>若任意节点的右子树不空，则右子树上所有结点的值均大于它的根结点的值；</li><li>任意节点的左、右子树也分别为二叉查找树；</li><li>没有键值相等的节点。</li></ol><p>下面是一个二叉查找树的示例：</p><p><img src="/images/BinarySearchTree.png" alt="image"></p><a id="more"></a><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><p>既然二叉查找树也属于二叉树，那么二叉树的基本操作二叉查找树也需要实现，下面是基本操作</p><ul><li>查找结点</li><li>插入结点</li><li>删除结点</li></ul><p>我们先写个接口来定义要实现这些操作，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 树的接口</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mingshan</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Tree</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 插入操作</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 插入成功 ，返回 &#123;<span class="doctag">@true</span>&#125;，否则返回&#123;<span class="doctag">@false</span>&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E value)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 移除</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 移除的元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">E <span class="title">remove</span><span class="params">(E value)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 清空二叉树</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断二叉树中是否有此元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 如果包含，返回&#123;<span class="doctag">@true</span>&#125;，否则返回&#123;<span class="doctag">@false</span>&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(E value)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取二叉树中结点的数量</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 二叉树中结点的数量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面来依次实现。</p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>先在类中定义二叉查找树的根结点和结点数量的成员变量。然后定义一个静态内部类Node来表示结点，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根结点</span></span><br><span class="line"><span class="keyword">private</span> Node&lt;E&gt; root;</span><br><span class="line"><span class="comment">// 二叉树结点数量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">E</span>&gt;&gt; </span>&#123;</span><br><span class="line">    E item;</span><br><span class="line">    Node&lt;E&gt; parent;</span><br><span class="line">    Node&lt;E&gt; left;</span><br><span class="line">    Node&lt;E&gt; right;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span> <span class="params">(Node&lt;E&gt; parent, E item)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.parent = parent;</span><br><span class="line">        <span class="keyword">this</span>.item = item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"item="</span> + item + <span class="string">" parent="</span> + ((parent != <span class="keyword">null</span>) ? parent.item : <span class="string">"NULL"</span>) + <span class="string">" left="</span></span><br><span class="line">                + ((left != <span class="keyword">null</span>) ? left.item : <span class="string">"NULL"</span>) + <span class="string">" right="</span> + ((right != <span class="keyword">null</span>) ? right.item : <span class="string">"NULL"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="查找结点"><a href="#查找结点" class="headerlink" title="查找结点"></a>查找结点</h3><p>这里采用先序遍历二叉查找树，先访问根结点，然后遍历左子树，最后遍历右子树。这里的泛型参数需要继承Comparable，然后我们就可以利用其compareTo方法来比较结点的值然后进行搜索即可。<br>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(E value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 先序遍历二叉树</span></span><br><span class="line">    Node&lt;E&gt; node = root;</span><br><span class="line">    <span class="keyword">if</span> (root.item.compareTo(value) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果当前值比父节点的值小</span></span><br><span class="line">        <span class="keyword">if</span> (node.item.compareTo(value) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 此时应该从父节点的左子树进行搜索</span></span><br><span class="line">            <span class="keyword">if</span> (node.left != <span class="keyword">null</span></span><br><span class="line">                    &amp;&amp; (node.left.item.compareTo(value) == <span class="number">0</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            node = node.left;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果当前结点的值比父结点的值大，说明应该从父节点的右子树搜索</span></span><br><span class="line">            <span class="comment">// 并且新结点作为叶子结点，其父节点的右子结点应为null</span></span><br><span class="line">            <span class="keyword">if</span> (node.right != <span class="keyword">null</span> </span><br><span class="line">                    &amp;&amp; (node.right.item.compareTo(value) == <span class="number">0</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            node = node.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="插入结点"><a href="#插入结点" class="headerlink" title="插入结点"></a>插入结点</h3><p>根据二叉搜索树的特征，若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值； 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值。而且新插入的结点必为叶子结点，所以只需遍历到当前符合上面要求的结点，然后将其为空的左子结点或者右子结点指向当前的新节点，最后将新结点的父结点指向当前结点。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E value)</span> </span>&#123;</span><br><span class="line">    Node&lt;E&gt; node = addNode(value);</span><br><span class="line">    <span class="keyword">return</span> (node != <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node&lt;E&gt; <span class="title">addNode</span><span class="params">(E value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 生成新结点</span></span><br><span class="line">    Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;E&gt;(<span class="keyword">null</span>, value);</span><br><span class="line">    <span class="comment">// 如果根结点不存在</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        root = newNode;</span><br><span class="line">        size++;</span><br><span class="line">        <span class="keyword">return</span> newNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node&lt;E&gt; node = root;</span><br><span class="line">    <span class="comment">// 按照先序进行遍历二叉树</span></span><br><span class="line">    <span class="keyword">while</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 如过新结点的值比父节点的值小</span></span><br><span class="line">        <span class="keyword">if</span> (node.item.compareTo(newNode.item) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 此时应该从父节点的左子树进行搜索</span></span><br><span class="line">            <span class="comment">// 并且新结点作为叶子结点，其父节点的左子结点应为null</span></span><br><span class="line">            <span class="keyword">if</span> (node.left == <span class="keyword">null</span>) &#123;</span><br><span class="line">                node.left = newNode;</span><br><span class="line">                newNode.parent = node;</span><br><span class="line">                size++;</span><br><span class="line">                <span class="keyword">return</span> newNode;</span><br><span class="line">            &#125;</span><br><span class="line">            node = node.left;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果当前结点的值比父结点的值大，说明应该从父节点的右子树搜索</span></span><br><span class="line">            <span class="comment">// 并且新结点作为叶子结点，其父节点的右子结点应为null</span></span><br><span class="line">            <span class="keyword">if</span> (node.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">                node.right = newNode;</span><br><span class="line">                newNode.parent = node;</span><br><span class="line">                size++;</span><br><span class="line">                <span class="keyword">return</span> newNode;</span><br><span class="line">            &#125;</span><br><span class="line">            node = node.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> newNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="删除结点"><a href="#删除结点" class="headerlink" title="删除结点"></a>删除结点</h3><p>删除结点是操作中最为复杂的，分下面几种情况考虑：</p><ol><li>要删除的结点为叶子结点，没有左右子节点</li><li>要删除的结点只有左子结点(树)或者右子结点(树)</li><li>要删除的结点左右结点(树)都有</li></ol><p>下面这幅图代表这几种操作示例：</p><p><img src="/images/BinarySearchTree_remove.png" alt="image"></p><p>其中第一幅图代表要删除的结点只有右子结点(树)，只需将该结点的父结点指向该结点的右子结点，但要判断当前结点是其父结点的子左结点还是右子结点，然后对应指向当前结点的子结点即可；图二代表要删除的结点只有左子结点(树)，原理是一样的；图三是代表要删除的结点左右结点(树)都有，此时需要找出其右子树中的最小值代替该节点上的值，然后删除其右子树上的最小值。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(E value)</span> </span>&#123;</span><br><span class="line">    Node&lt;E&gt; node = <span class="keyword">this</span>.removeValue(value);</span><br><span class="line">    <span class="keyword">return</span> (node != <span class="keyword">null</span> ? node.item : <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node&lt;E&gt; <span class="title">removeValue</span><span class="params">(E value)</span> </span>&#123;</span><br><span class="line">    Node&lt;E&gt; curr = <span class="keyword">this</span>.getNode(value);</span><br><span class="line">    <span class="keyword">if</span> (curr != <span class="keyword">null</span>) &#123;</span><br><span class="line">        curr = removeNode(curr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> curr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除结点，分下面几种情况考虑</span></span><br><span class="line"><span class="comment"> * &lt;ul&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;要删除的结点为叶子结点，没有左右子节点&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;要删除的结点只有左子结点(树)或者右子结点(树)&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;要删除的结点左右结点(树)都有&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> nodeToRemoved</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 删除的结点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node&lt;E&gt; <span class="title">removeNode</span><span class="params">(Node&lt;E&gt; nodeToRemoved)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 判断当前节点是否为叶子结点（叶子结点的特点是没有子结点）</span></span><br><span class="line">    <span class="comment">// 直接删除叶子结点</span></span><br><span class="line">    <span class="keyword">if</span> (nodeToRemoved.left == <span class="keyword">null</span> &amp;&amp; nodeToRemoved.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 判断该二叉树是否只有根结点一个结点</span></span><br><span class="line">        <span class="keyword">if</span> (nodeToRemoved == root) &#123;</span><br><span class="line">            root = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果二叉树不是只有根结点一个结点，那么当前要删除的结点一定有父结点</span></span><br><span class="line">        Node&lt;E&gt; targetParent = nodeToRemoved.parent;</span><br><span class="line">        <span class="comment">// 判断当前结点是其父结点的左子结点还是右子结点</span></span><br><span class="line">        <span class="keyword">if</span> (targetParent.left.item.compareTo(nodeToRemoved.item) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果当前结点是其父结点的左子结点</span></span><br><span class="line">            targetParent.left = <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (targetParent.right.item.compareTo(nodeToRemoved.item) == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">// 如果当前结点是其父结点的右子结点</span></span><br><span class="line">            targetParent.right = <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 此时二叉树有问题</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nodeToRemoved.left != <span class="keyword">null</span> &amp;&amp; nodeToRemoved.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 要删除的结点左右结点(树)都有</span></span><br><span class="line">        <span class="comment">// 此时结点的左右子结点(树)都有，用其右子树中的最小值代替该节点上的值,删除其右子树上的最小值</span></span><br><span class="line">        <span class="comment">// 所以此时需要先找出其右子树的最小值</span></span><br><span class="line">        Node&lt;E&gt; minNode = findMinNode(nodeToRemoved);</span><br><span class="line">        <span class="comment">// 将当前要删除结点的值替换为其子树的最小节点</span></span><br><span class="line">        nodeToRemoved.item = minNode.item;</span><br><span class="line">        <span class="comment">// 删除找到的最小节点</span></span><br><span class="line">        removeNode(minNode);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 要删除的结点只有左子结点(树)或者右子结点(树)</span></span><br><span class="line">        <span class="comment">// 此时需要将该结点的子结点(树)指向该结点(树)的父结点</span></span><br><span class="line">        Node&lt;E&gt; targetLeft = nodeToRemoved.left;</span><br><span class="line">        Node&lt;E&gt; targetRight = nodeToRemoved.right;</span><br><span class="line">        Node&lt;E&gt; targetParent = nodeToRemoved.parent;</span><br><span class="line">        <span class="comment">// 判断当前要删除的结点是其父结点的左结点还是右结点</span></span><br><span class="line">        <span class="keyword">if</span> (targetParent.left.item.compareTo(nodeToRemoved.item) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 左</span></span><br><span class="line">            <span class="keyword">if</span> (targetLeft != <span class="keyword">null</span>) &#123;</span><br><span class="line">                targetParent.left = targetLeft;</span><br><span class="line">                targetLeft.parent = targetParent;</span><br><span class="line">                targetLeft = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (targetRight != <span class="keyword">null</span>) &#123;</span><br><span class="line">                targetParent.left = targetRight;</span><br><span class="line">                targetRight.parent = targetParent;</span><br><span class="line">                targetRight = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (targetParent.right.item.compareTo(nodeToRemoved.item) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 右</span></span><br><span class="line">            <span class="keyword">if</span> (targetLeft != <span class="keyword">null</span>) &#123;</span><br><span class="line">                targetParent.right = targetLeft;</span><br><span class="line">                targetLeft.parent = targetParent;</span><br><span class="line">                targetLeft = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (targetRight != <span class="keyword">null</span>) &#123;</span><br><span class="line">                targetParent.right = targetRight;</span><br><span class="line">                targetRight.parent = targetParent;</span><br><span class="line">                targetRight = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    size--;</span><br><span class="line">    <span class="keyword">return</span> nodeToRemoved;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们需要通过传入的值来获取二叉树的结点，此时调用函数<strong>getNode</strong>，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过传入的值来搜索结点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 传入的值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 结点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node&lt;E&gt; <span class="title">getNode</span><span class="params">(E value)</span> </span>&#123;</span><br><span class="line">    Node&lt;E&gt; node = root;</span><br><span class="line">    <span class="keyword">while</span> (node != <span class="keyword">null</span> &amp;&amp; node.item != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (node.item.compareTo(value) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            node = node.left;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node.item.compareTo(value) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            node = node.right;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在要删除的结点左右结点(树)都有的情况下，我们需要查找其右子树中的最小值，此时我们考虑到如果为最小结点，那么该结点必然没有左子树(结点)，所以可以选择递归进行遍历，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 找到给定结点的子树的最小结点(值)</span></span><br><span class="line"><span class="comment"> * 此时应该考虑到如果为最小结点，那么该结点必然没有左子树(结点)，所以可以选择递归进行遍历</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> nodeToRemoved</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 给定结点的子树的最小结点(值)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node&lt;E&gt; <span class="title">findMinNode</span><span class="params">(Node&lt;E&gt; nodeToRemoved)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nodeToRemoved == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (nodeToRemoved.left == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> nodeToRemoved;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> findMinNode(nodeToRemoved.left);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="打印"><a href="#打印" class="headerlink" title="打印"></a>打印</h3><p>我们需要将二叉树打印到控制台上，便于查看二叉树的结构，效果如下：</p><p><img src="/images/BinarySearchTree_print.png" alt="image"></p><p>打印代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> TreePrinter.getString(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TreePrinter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Comparable&lt;T&gt;&gt; <span class="function">String <span class="title">getString</span><span class="params">(BinarySearchTree&lt;T&gt; tree)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tree.root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"Tree has no nodes."</span>;</span><br><span class="line">        <span class="keyword">return</span> getString(tree.root, <span class="string">""</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> &lt;E extends Comparable&lt;E&gt;&gt; <span class="function">String <span class="title">getString</span><span class="params">(Node&lt;E&gt; node, String prefix, <span class="keyword">boolean</span> isTail)</span> </span>&#123;</span><br><span class="line">        StringBuilder builder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (node.parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">            String siteme = <span class="string">"left"</span>;</span><br><span class="line">            <span class="keyword">if</span> (node.equals(node.parent.right))</span><br><span class="line">                siteme = <span class="string">"right"</span>;</span><br><span class="line">            builder.append(prefix + (isTail ? <span class="string">"└── "</span> : <span class="string">"├── "</span>) + <span class="string">"("</span> + siteme + <span class="string">") "</span> + node.item + <span class="string">"\n"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            builder.append(prefix + (isTail ? <span class="string">"└── "</span> : <span class="string">"├── "</span>) + node.item + <span class="string">"\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Node&lt;E&gt;&gt; children = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (node.left != <span class="keyword">null</span> || node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            children = <span class="keyword">new</span> ArrayList&lt;Node&lt;E&gt;&gt;(<span class="number">2</span>);</span><br><span class="line">            <span class="keyword">if</span> (node.left != <span class="keyword">null</span>)</span><br><span class="line">                children.add(node.left);</span><br><span class="line">            <span class="keyword">if</span> (node.right != <span class="keyword">null</span>)</span><br><span class="line">                children.add(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (children != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; children.size() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">                builder.append(getString(children.get(i), prefix + (isTail ? <span class="string">"    "</span> : <span class="string">"│   "</span>), <span class="keyword">false</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (children.size() &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">                builder.append(getString(children.get(children.size() - <span class="number">1</span>), prefix + (isTail ? <span class="string">"    "</span> : <span class="string">"│   "</span>), <span class="keyword">true</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> builder.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="源码地址"><a href="#源码地址" class="headerlink" title="源码地址"></a>源码地址</h3><p>本篇博客的代码地址：</p><p><a href="https://github.com/mstao/data-structures/blob/master/Tree/src/pers/mingshan/tree/BinarySearchTree.java" target="_blank" rel="noopener">https://github.com/mstao/data-structures/blob/master/Tree/src/pers/mingshan/tree/BinarySearchTree.java</a></p><p>测试代码地址如下：</p><p><a href="https://github.com/mstao/data-structures/blob/master/Tree/src/pers/mingshan/tree/TreeTest.java" target="_blank" rel="noopener">https://github.com/mstao/data-structures/blob/master/Tree/src/pers/mingshan/tree/TreeTest.java</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> 二叉树 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 二叉搜索树 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>链式队列结构分析</title>
      <link href="/2017/12/21/%E9%93%BE%E5%BC%8F%E9%98%9F%E5%88%97%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90/"/>
      <url>/2017/12/21/%E9%93%BE%E5%BC%8F%E9%98%9F%E5%88%97%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="链式队列介绍"><a href="#链式队列介绍" class="headerlink" title="链式队列介绍"></a>链式队列介绍</h3><p>链式队列拥有队列的特性，只不过和顺序队列的区别是，顺序队列底层用的是数组存储元素，而链式队列用的是链表结构存储数据，也就是把一个元素和指向下个结点的指针封装成一个结点，这里称为Node，当队列为空，头指针与尾指针均指向头结点，只不过头结点为空结点，下面是链式队列的结构图</p><p><img src="/images/LinkQueue.png" alt="image"></p><p>一个结点抽象成Node类，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> E data;</span><br><span class="line">    <span class="keyword">private</span> Node next;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(E data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h4 id="初始"><a href="#初始" class="headerlink" title="初始"></a>初始</h4><h4 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h4><p>链式队列需要有个指向队首的指针，指向队尾的指针，这里把这两个均声明为Node类型，当然队列需要容量和统计队列内元素的个数，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger size = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> capacity;</span><br><span class="line"><span class="comment">// 队列的头结点</span></span><br><span class="line"><span class="keyword">private</span> Node head;</span><br><span class="line"><span class="comment">// 队列的尾结点</span></span><br><span class="line"><span class="keyword">private</span> Node tail;</span><br></pre></td></tr></table></figure><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><p>在构造函数中初始化队列，当队列为空时，头指针与尾指针均指向头结点，头结点不存储数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(Integer.MAX_VALUE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkQueue</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (capacity &lt;= <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">    tail = head = <span class="keyword">new</span> Node(<span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkQueue</span><span class="params">(E element)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(Integer.MAX_VALUE);</span><br><span class="line">    <span class="comment">// 初始Node，只有一个节点</span></span><br><span class="line">    Node newNode = <span class="keyword">new</span> Node(element);</span><br><span class="line">    head.next = newNode;</span><br><span class="line">    tail = newNode;</span><br><span class="line">    size.incrementAndGet();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><h4 id="入队"><a href="#入队" class="headerlink" title="入队"></a>入队</h4><p>链式队列也实现我们在顺序队列写好的接口，所以入队也有两种操作，抛异常和不抛异常，分别为<strong>add(E e)</strong>和<strong>offer(E e)</strong>，这里直接说offer方法，如果队列为空，让头结点指向新的节点，同时让为指针指向新节点，不为空直接正常入队即可，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public boolean add(E e) &#123;</span><br><span class="line">    if (offer(e))</span><br><span class="line">        return true;</span><br><span class="line">    else</span><br><span class="line">        throw new IllegalStateException(&quot;Queue full&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public boolean offer(E e) &#123;</span><br><span class="line">    if (e == null)</span><br><span class="line">        throw new NullPointerException();</span><br><span class="line">    if (size.get() == capacity)</span><br><span class="line">        return false;</span><br><span class="line">    Node newNode = new Node(e);</span><br><span class="line">    if (head == null) &#123;</span><br><span class="line">        head.next = newNode;</span><br><span class="line">        tail = newNode;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        tail.next = newNode;</span><br><span class="line">        tail = newNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    size.incrementAndGet();</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="出队"><a href="#出队" class="headerlink" title="出队"></a>出队</h4><p>出队也是比较简单的，直接移除队首结点即可，让头结点指向下一个结点，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isEmpty()) &#123;</span><br><span class="line">        Node node = head.next;</span><br><span class="line">        head.next = node.next;</span><br><span class="line">        size.decrementAndGet();</span><br><span class="line">        <span class="keyword">return</span> node.data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="清空队列"><a href="#清空队列" class="headerlink" title="清空队列"></a>清空队列</h4><p>清空队列是让除了头结点的结点全部清除掉，解除关联，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    head.next = <span class="keyword">null</span>;</span><br><span class="line">    tail = <span class="keyword">null</span>;</span><br><span class="line">    size.set(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="源码地址"><a href="#源码地址" class="headerlink" title="源码地址"></a>源码地址</h3><p>本篇博客源码地址：</p><p><a href="https://github.com/mstao/data-structures/blob/master/Queue/src/pers/mingshan/queue/LinkQueue.java" target="_blank" rel="noopener">https://github.com/mstao/data-structures/blob/master/Queue/src/pers/mingshan/queue/LinkQueue.java</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> 队列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 队列 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>顺序队列结构分析</title>
      <link href="/2017/12/20/%E9%A1%BA%E5%BA%8F%E9%98%9F%E5%88%97%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90/"/>
      <url>/2017/12/20/%E9%A1%BA%E5%BA%8F%E9%98%9F%E5%88%97%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="队列介绍"><a href="#队列介绍" class="headerlink" title="队列介绍"></a>队列介绍</h3><p>队列是一种特殊的线性表，特殊之处在于它只允许在表的前端（front）进行删除操作，而在表的后端（rear）进行插入操作，和栈一样，队列是一种操作受限制的线性表。进行插入操作的端称为队尾，进行删除操作的端称为队头。队列中没有元素时，称为空队列。<br>队列的特点是先进先出(FIFO)，下面是队列的结构图：</p><p><img src="/images/ArrayQueue.png" alt="image"></p><a id="more"></a><h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><p>既然是队列，那么入队和出队操作是必不可少的，除此之外，还需要其他api，下面是Queue的接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 队列接口</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mingshan</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;E&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Queue</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加元素， 如果没有可用的空间，抛出IllegalStateException异常</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e 将要添加的元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加元素。成功时返回 true，如果当前没有可用的空间，则返回 false，不会抛异常</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e 将要添加的元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取并移除此队列的头部,如果队列为空，则返回null</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 头部元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">E <span class="title">poll</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取队列头部元素, 不移除头部元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 头部元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">E <span class="title">peek</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断队列是否为空</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取队列的长度</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 队列的长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 清空队列</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面来看看这些方法如何实现，现在还不考虑锁的问题，<strong>java.util.concurrent.ArrayBlockingQueue</strong>这个类有具体的实现，有空分析分析这个类的源码。</p><h3 id="构造函数和成员变量"><a href="#构造函数和成员变量" class="headerlink" title="构造函数和成员变量"></a>构造函数和成员变量</h3><p>顺序队列默认把元素存到数组里，所以这里用数组来保存队列里的元素，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 队列内部数组默认容量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_SIZE = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 队列内部数组的容量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> capacity;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 保存元素的数组</span></span><br><span class="line"><span class="keyword">private</span> Object[] elements;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指向队列头部</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> head;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指向队列尾部</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> tail;</span><br></pre></td></tr></table></figure><p>在构造函数里面初始化队列的大小</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 默认构造函数初始化</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    capacity = DEFAULT_SIZE;</span><br><span class="line">    elements = <span class="keyword">new</span> Object[capacity];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定队列内部数组容量进行初始化</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> capacity 指定容量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayQueue</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">    elements = <span class="keyword">new</span> Object[capacity];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定队列的第一个元素进行初始化</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e 队列的第一个元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayQueue</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.capacity = DEFAULT_SIZE;</span><br><span class="line">    elements = <span class="keyword">new</span> Object[capacity];</span><br><span class="line">    elements[<span class="number">0</span>] = e;</span><br><span class="line">    tail++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定队列的第一个元素和容量进行初始化</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e 队列的第一个元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> capacity 队列内部数组容量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayQueue</span><span class="params">(E e, <span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">    elements = <span class="keyword">new</span> Object[capacity];</span><br><span class="line">    elements[<span class="number">0</span>] = e;</span><br><span class="line">    tail++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="入队"><a href="#入队" class="headerlink" title="入队"></a>入队</h3><p>在入队的时候，其实有两种选择，如果队列满的话，抛出异常，或者等待其他元素出队后再进行入队。</p><h4 id="add-E-e"><a href="#add-E-e" class="headerlink" title="add(E e)"></a>add(E e)</h4><p>add方法就是实现第一种，如果没有可用的空间，抛出IllegalStateException异常，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 获取当前的数组的长度</span></span><br><span class="line">        <span class="keyword">int</span> oldLength = elements.length;</span><br><span class="line">        <span class="comment">// 如果原来数组的长度小于当前需要的长度，那么直接抛异常IllegalStateException</span></span><br><span class="line">        <span class="keyword">if</span> (oldLength &lt; tail + <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Queue full"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            elements[tail++] = e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先获取队列的大小，如果队列的大小小于当前需要的空间，那么直接抛异常IllegalStateException，否则正常入队。</p><p><strong>假溢出</strong></p><p>我们在利用数组实现队列的时候，发现数组队列会出现假溢出问题，即队列还没有满，但不能再往队列中放入元素了，如下图所示：</p><p><img src="https://github.com/ZZULI-TECH/interview/blob/master/images/ArrayQueue_false_overflow.png?raw=true" alt="image"></p><p>在数据进行出队的时候，每一个元素出队，指向队列头元素的head就会向后移动，导致head之前的元素被“遗忘”了，无法再次利用。</p><p>当然，我们可以对数组队列进行一些优化。在插入元素的时候，我们检查一下tail是否已经指向了队尾，如果指向了队尾并且head不等于0的情况下，说明发生了假溢出，需要进行元素迁移工作，将head和tail之间的元素整体移动到 0 到 <code>tail - head</code> 的位置，这样就可以避免假溢出问题了（还是上面的图），优化后的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 由于数组队列存在假溢出问题，所谓要进行数据搬运</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(e);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (tail == capacity) &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 证明队列是满的</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Queue full"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果head 不等于0，证明head之前的空间是空着的，所以需要进行数据搬运</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head; i &lt; tail; i++) &#123;</span><br><span class="line">            elements[i - head] = elements[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 搬运完更新head 和 tail</span></span><br><span class="line">        head = <span class="number">0</span>;</span><br><span class="line">        tail -= head; <span class="comment">// tail = tail - head</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 正常操作</span></span><br><span class="line">    elements[tail++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="offer-E-e"><a href="#offer-E-e" class="headerlink" title="offer(E e)"></a>offer(E e)</h4><p>入队操作。成功时返回 true，如果当前没有可用的空间，则返回 false，不会抛异常，由于这里没有用到锁，也就暂时不考虑等待入队了，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 获取当前的数组的长度</span></span><br><span class="line">        <span class="keyword">int</span> oldLength = elements.length;</span><br><span class="line">        <span class="comment">// 如果原来数组的长度小于当前需要的长度，那么直接抛异常IllegalStateException</span></span><br><span class="line">        <span class="keyword">if</span> (oldLength &lt; tail + <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Queue full"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            elements[tail++] = e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据前面的假溢出问题分析，优化后的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(e);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (tail == capacity) &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 证明队列是满的</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果head 不等于0，证明head之前的空间是空着的，所以需要进行数据搬运</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head; i &lt; tail; i++) &#123;</span><br><span class="line">            elements[i - head] = elements[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 搬运完更新head 和 tail</span></span><br><span class="line">        head = <span class="number">0</span>;</span><br><span class="line">        tail = elements.length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 正常操作</span></span><br><span class="line">    elements[tail++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="出队"><a href="#出队" class="headerlink" title="出队"></a>出队</h3><h4 id="poll"><a href="#poll" class="headerlink" title="poll()"></a>poll()</h4><p>获取并移除此队列的头部,如果队列为空，则返回null，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isEmpty()) &#123;</span><br><span class="line">        E value = (E) elements[head];</span><br><span class="line">        <span class="comment">// 移除头部元素</span></span><br><span class="line">        elements[head] = <span class="keyword">null</span>;</span><br><span class="line">        head++;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="peek"><a href="#peek" class="headerlink" title="peek()"></a>peek()</h4><p>获取队列头部元素, 不移除头部元素，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> (E) elements[head];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="清空队列"><a href="#清空队列" class="headerlink" title="清空队列"></a>清空队列</h3><p>由于用数组存储队列元素，所以需要将底层数组清空</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//将底层数组所有元素赋为null  </span></span><br><span class="line">    Arrays.fill(elements, <span class="keyword">null</span>);</span><br><span class="line">    head = <span class="number">0</span>;</span><br><span class="line">    tail = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="源码地址"><a href="#源码地址" class="headerlink" title="源码地址"></a>源码地址</h3><p>本篇博客源码地址：</p><p><a href="https://github.com/mstao/data-structures/blob/master/Queue/src/pers/mingshan/queue/ArrayQueue.java" target="_blank" rel="noopener">https://github.com/mstao/data-structures/blob/master/Queue/src/pers/mingshan/queue/ArrayQueue.java</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> 队列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 队列 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>RESTful API风格基于Token的鉴权机制分析(与JWT结合)</title>
      <link href="/2017/12/19/RESTful%20API%E9%A3%8E%E6%A0%BC%E5%9F%BA%E4%BA%8EToken%E7%9A%84%E9%89%B4%E6%9D%83%E6%9C%BA%E5%88%B6%E5%88%86%E6%9E%90(%E4%B8%8EJWT%E7%BB%93%E5%90%88)/"/>
      <url>/2017/12/19/RESTful%20API%E9%A3%8E%E6%A0%BC%E5%9F%BA%E4%BA%8EToken%E7%9A%84%E9%89%B4%E6%9D%83%E6%9C%BA%E5%88%B6%E5%88%86%E6%9E%90(%E4%B8%8EJWT%E7%BB%93%E5%90%88)/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="RESTful-API"><a href="#RESTful-API" class="headerlink" title="RESTful API"></a>RESTful API</h3><p>RESTful API是目前比较成熟的API设计理论，它通过统一的API接口来对外提供服务，这样对其他调用者来说比较友好，更加容易实现前后端分离。具体介绍和如何使用参考这篇文章<br><a href="http://mingshan.me/2017/10/01/%E5%88%A9%E7%94%A8SpringMVC%E5%AE%9E%E7%8E%B0RESTful%20API%EF%BC%8C%E5%B9%B6%E4%B8%8ESwagger%E9%9B%86%E6%88%90%E7%94%9F%E6%88%90API%E6%96%87%E6%A1%A3/">RESTful API介绍与使用</a></p><h3 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h3><p>在我们的项目中，仅仅使用RESTful API是远远不够的，因为RESTful API只提供JSON数据，没有了视图层，将视图渲染交给了前端，这就带来了许多问题。比如我们以前在写JSP界面的时候，会把数据放到request里面，把登录的用户信息放在session里面，因为jsp本质上也是servlet，所以可以在界面直接拿到这些数据，现在前后端一分离，怎样对用户的身份进行识别就是首要考虑的问题。</p><p>以前我们是通过session来进行对用户的身份验证，由于http协议是无状态的，所以我们需要在服务器端将用户的信息保存下来，这份登录信息会在响应时传递给浏览器，告诉其保存为cookie(Java中的jsessionid),以便下次请求时发送给我们的应用，这样我们的应用就能识别请求来自哪个用户了,这就是传统的基于session认证。</p><h3 id="使用-Token-进行身份鉴权"><a href="#使用-Token-进行身份鉴权" class="headerlink" title="使用 Token 进行身份鉴权"></a>使用 Token 进行身份鉴权</h3><p>现在我们的API可能不只是在浏览器上调用，比如app等也需要调用，这是如果只用session的话就有局限性了，所以我们可以用 <strong>Token</strong> 进行身份鉴权，由于Token我们可以根据自己的需要进行自定义，只要API提供方和调用方约定好如何生成Token和解析token，更加轻量化，扩展性更强。</p><a id="more"></a><h3 id="JWT-JSON-Web-Token"><a href="#JWT-JSON-Web-Token" class="headerlink" title="JWT(JSON Web Token)"></a>JWT(JSON Web Token)</h3><p>JWT 是JSON风格轻量级的授权和身份认证规范，可实现无状态、分布式的Web应用授权，JWT主要由三部分构成，由.进行连接</p><ul><li>Header</li><li>Payload</li><li>Signature</li></ul><p>所以完整的JWT如下面形式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xxxxx.yyyyy.zzzzz</span><br></pre></td></tr></table></figure><p>真实的JWT长这样：</p><p><img src="/images/encoded-jwt3.png" alt="image"></p><p>那么header，Payload和Signature分别代表什么呢？</p><h4 id="header"><a href="#header" class="headerlink" title="header"></a>header</h4><p>header主要包含两部分：</p><ul><li>Token的类型，这里是JWT</li><li>声明加密的算法 通常直接使用 HMAC SHA256</li></ul><p>完整的header应该长这样：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"alg"</span>: <span class="string">"HS256"</span>,</span><br><span class="line">  <span class="attr">"typ"</span>: <span class="string">"JWT"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后将头部进行Base64加密，得到第一部分。</p><h4 id="Payload"><a href="#Payload" class="headerlink" title="Payload"></a>Payload</h4><p>第二部分主要是包含声明（Claims），声明是关于实体（通常是用户）和附加元数据的声明，这部分是存放数据的地方，比如用户id什么的，类似下面这样：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"id"</span>: <span class="string">"1234567890"</span>,</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"mingshan"</span>,</span><br><span class="line">  <span class="attr">"admin"</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后将有效Payload用Base64进行编码，以形成JWT的第二部分。</p><h4 id="Signature"><a href="#Signature" class="headerlink" title="Signature"></a>Signature</h4><p>要创建签名部分，必须要有已经编码的header，编过码的Payload，一个密匙（secret）和加密算法。</p><p>例如，如果想使用HMAC SHA256算法，签名将按以下方式创建：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HMACSHA256(</span><br><span class="line">  base64UrlEncode(header) + &quot;.&quot; +</span><br><span class="line">  base64UrlEncode(payload),</span><br><span class="line">  secret)</span><br></pre></td></tr></table></figure><p>详细细节请参考JWT官网 <a href="https://jwt.io/introduction/" target="_blank" rel="noopener">JWT官网介绍</a></p><h3 id="RESTful与JWT结合进行鉴权"><a href="#RESTful与JWT结合进行鉴权" class="headerlink" title="RESTful与JWT结合进行鉴权"></a>RESTful与JWT结合进行鉴权</h3><p>上面只是介绍一下RESTful API和JWT，下面我们来考虑怎么实现。</p><p>首先是流程，借用JWT官网上的一幅图</p><p><img src="/images/jwt-diagram.png" alt="image"></p><p>从图中我们可以总结如下（以Client和Server端为例）：</p><ol><li>首先Client发起认证请求，包含用户名和密码，进行登录操作</li><li>Server端验证用户名和密码，验证通过的话用密匙生成token，并将token存储起来，然后将token返回给Client</li><li>此时Client已经验证登录过了，下次进行请求时将token放在header的Authorization中</li><li>Server端根据规则将token解析出来，拿到subject，从到拿到用户信息，然后通过用户信息去拿已经存储的token，然后将两个token进行比较，从而判断用户是否已登录</li><li>将验证信息发送给Client</li></ol><p>通过上面的流程分析，我们发现其实并不怎么难。但现在有几个地方我们还没有说</p><ul><li>怎样标识哪些API需要鉴权，如何优雅地处理？</li><li>token存在哪个地方？</li><li>token的生成与解析如何去做？</li></ul><p>下面我们依次来分析。</p><h4 id="标识哪些API需要鉴权"><a href="#标识哪些API需要鉴权" class="headerlink" title="标识哪些API需要鉴权"></a>标识哪些API需要鉴权</h4><p>标识哪些API需要鉴权，我们需要自定义注解，然后将注解加到需要鉴权的API上面就可以了，这里自定义两个注解，<strong>@Authorization</strong> 和 <strong>@CurrentUser</strong>，<strong>@Authorization</strong>就是标识哪些API需要鉴权，<strong>@CurrentUser</strong>就是将从token获取的用户信息封装到当前user对象里面，主要用在登出处理，下面是代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: mingshan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> com.lightblog.authorization.interceptor.AuthorizationInterceptor</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: Created in 19:23 2017/10/14</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Authorization &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: mingshan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: Created in 19:29 2017/10/14</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target</span>(ElementType.PARAMETER)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> CurrentUser &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于我用到SpringMVC，所以我就考虑添加拦截器来处理用户的鉴权请求，Spring为我们提供<strong>了org.springframework.web.servlet.handler.HandlerInterceptorAdapter</strong>这个适配器，继承此类，可以非常方便的实现自己的拦截器。这里主要重写它的预处理方法来处理请求，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The custom interceptor that checks out the current request has authorization.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: mingshan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: Created in 19:27 2017/10/14</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AuthorizationInterceptor</span> <span class="keyword">extends</span> <span class="title">HandlerInterceptorAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> TokenManager tokenManager;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response,</span></span></span><br><span class="line"><span class="function"><span class="params">                             Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// Checks out the annotation of authorization that is method level.</span></span><br><span class="line">        <span class="keyword">if</span> (!(handler <span class="keyword">instanceof</span> HandlerMethod)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        HandlerMethod handlerMethod = (HandlerMethod)handler;</span><br><span class="line">        Method method = handlerMethod.getMethod();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Gets authorization string from request header.</span></span><br><span class="line">        String authorization = request.getHeader(Constants.AUTHORIZATION);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Gets the model of Token from authorization string.</span></span><br><span class="line">        TokenModel token = tokenManager.getToken(authorization);</span><br><span class="line">        <span class="comment">// Checks out the token that is from Redis,</span></span><br><span class="line">        <span class="keyword">if</span> (tokenManager.checkToken(token)) &#123;</span><br><span class="line">            <span class="comment">// Puts userId into request.</span></span><br><span class="line">            request.setAttribute(Constants.CURRENT_USER_ID, token.getUserId());</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If verify token failed, and the current method has the annotation of authorization,</span></span><br><span class="line">        <span class="comment">// sets the response code to 401.</span></span><br><span class="line">        <span class="comment">// The 401 code means unauthorized.</span></span><br><span class="line">        <span class="keyword">if</span> (method.getAnnotation(Authorization.class) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的<strong>preHandle</strong>方法里，我们首先得到处理的方法，从http请求的Authorization中拿到token，然后解析token，检测token，如果检测token成功，那么将用户id放到request中，返回true继续执行，如果检测失败，那么返回http状态码401，401意味着未认证，返回false，不继续往下执行了。</p><h4 id="toekn存储位置"><a href="#toekn存储位置" class="headerlink" title="toekn存储位置"></a>toekn存储位置</h4><p>在我这里我是将token存在了Redis里，用户id作为key，token作为value，解析token和检测token主要在RedisTokenManager类中，主要有创建token，删除token，从jwt中获取token以及检测token，比较简单，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The implement class of Token manager.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: mingshan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: Created in 23:41 2017/10/13</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisTokenManager</span> <span class="keyword">implements</span> <span class="title">TokenManager</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(RedisTokenManager.class);</span><br><span class="line">    <span class="keyword">private</span> RedisTemplate&lt;Long, String&gt; redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRedisTemplate</span><span class="params">(RedisTemplate&lt;Long, String&gt; redisTemplate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.redisTemplate = redisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TokenModel <span class="title">creatToken</span><span class="params">(<span class="keyword">long</span> userId)</span> </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setId(userId);</span><br><span class="line">        String subject = JWTUtil.generalSubject(user);</span><br><span class="line">        String token = JWTUtil.createJWT(userId, subject, Constants.JWT_TTL);</span><br><span class="line">        TokenModel model = <span class="keyword">new</span> TokenModel(userId, token);</span><br><span class="line">        redisTemplate.boundValueOps(userId).set(token, Constants.TOKEN_EXPIRES_HOUR, TimeUnit.HOURS);</span><br><span class="line">        <span class="keyword">return</span> model;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteToken</span><span class="params">(<span class="keyword">long</span> userId)</span> </span>&#123;</span><br><span class="line">        redisTemplate.delete(userId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkToken</span><span class="params">(TokenModel model)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (model == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Object source = redisTemplate.boundValueOps(model.getUserId()).get();</span><br><span class="line">        <span class="keyword">if</span> (source == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String token = source.toString();</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">""</span>.equals(token) || !token.equals(model.getToken())) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        redisTemplate.boundValueOps(model.getUserId()).expire(Constants.TOKEN_EXPIRES_HOUR, TimeUnit.HOURS);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TokenModel <span class="title">getToken</span><span class="params">(String authorization)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (authorization == <span class="keyword">null</span> || <span class="string">""</span>.equals(authorization)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        User user = RequestCheck.getUserFromToken(authorization);</span><br><span class="line">        <span class="keyword">if</span> (user == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> userId = user.getId();</span><br><span class="line"></span><br><span class="line">        String token = RequestCheck.extractJwtTokenFromAuthorizationHeader(authorization);</span><br><span class="line">        TokenModel model = <span class="keyword">new</span> TokenModel(userId, token);</span><br><span class="line">        <span class="keyword">return</span> model;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这个类用到了如何去从JWT中解析token，这里的<strong>getUserFromToken</strong>方法是从JWT字符中解析token，具体来说先获取Cliams，然后获取subject，再从subject获取用户信息，最后封装成User对象，序列化对象用的是fastjson，并不复杂，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: mingshan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: Created in 12:41 2017/12/16</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestCheck</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(RequestCheck.class);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> User <span class="title">getUserFromToken</span><span class="params">(String auth)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (auth == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!Constants.TOKEN_PREFIX.equals(auth.substring(<span class="number">0</span>, <span class="number">7</span>))) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            String token = extractJwtTokenFromAuthorizationHeader(auth);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Claims claims = JWTUtil.parseJWT(token);</span><br><span class="line">                String subject = claims.getSubject();</span><br><span class="line">                User user = JSONObject.parseObject(subject, User.class);</span><br><span class="line">                <span class="keyword">return</span> user;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                logger.error(<span class="string">"解析JWT token 失败！"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取真实的toekn，去掉‘Bearer ’</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> auth</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">extractJwtTokenFromAuthorizationHeader</span><span class="params">(String auth)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Replace "Bearer Token" to "Token" directly</span></span><br><span class="line">        <span class="keyword">return</span> auth.replaceFirst(<span class="string">"[B|b][E|e][A|a][R|r][E|e][R|r] "</span>, <span class="string">""</span>).replace(<span class="string">" "</span>, <span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s = <span class="string">"Bearer 122"</span>;</span><br><span class="line">        System.out.print(extractJwtTokenFromAuthorizationHeader(s));</span><br><span class="line"></span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setId(<span class="number">1</span>);</span><br><span class="line">        JSONObject jo = <span class="keyword">new</span> JSONObject();</span><br><span class="line">        jo.put(<span class="string">"userId"</span>, user.getId());</span><br><span class="line">        System.out.print(jo.toJSONString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="token的生成与解析"><a href="#token的生成与解析" class="headerlink" title="token的生成与解析"></a>token的生成与解析</h4><p>这里我们写了一个工具类JWTUtil，用来创建token和解析JWT，先引入jjwt，jjwt封装了操作jwt的常用操作</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.jsonwebtoken<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jjwt<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.9.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其中header和Payload的编解码用到了<strong>java.util.Base64</strong>的代码， 代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: mingshan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: Created in 21:29 2017/12/14</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JWTUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 编码</span></span><br><span class="line"><span class="comment">     * String asB64 = Base64.getEncoder().encodeToString("some string".getBytes("utf-8"));</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 解码</span></span><br><span class="line"><span class="comment">     * byte[] asBytes = Base64.getDecoder().decode("c29tZSBzdHJpbmc=");</span></span><br><span class="line"><span class="comment">     * System.out.println(new String(asBytes, "utf-8"));</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获得加密的key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 加密后的key</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SecretKey <span class="title">generateKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] encodedKey = Base64.getDecoder().decode(Constants.JWT_SECRET);</span><br><span class="line">        SecretKey key = <span class="keyword">new</span> SecretKeySpec(encodedKey, <span class="number">0</span>, encodedKey.length, <span class="string">"AES"</span>);</span><br><span class="line">        <span class="keyword">return</span> key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 签发 JWT</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> subject</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ttlMillis</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 生成的JWT token</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">createJWT</span><span class="params">(Long id, String subject, <span class="keyword">long</span> ttlMillis)</span> </span>&#123;</span><br><span class="line">        SignatureAlgorithm signatureAlgorithm = SignatureAlgorithm.HS256;</span><br><span class="line">        <span class="keyword">long</span> nowMillis = System.currentTimeMillis();</span><br><span class="line">        Date now = <span class="keyword">new</span> Date(nowMillis);</span><br><span class="line">        SecretKey secretKey = generateKey();</span><br><span class="line">        JwtBuilder builder = Jwts.builder()</span><br><span class="line">                .setId(id.toString()) <span class="comment">// JWT_ID</span></span><br><span class="line">                .setSubject(subject) <span class="comment">// 主题</span></span><br><span class="line">                .setIssuedAt(now) <span class="comment">// 签发时间</span></span><br><span class="line">                .signWith(signatureAlgorithm, secretKey); <span class="comment">// 签名算法以及密匙</span></span><br><span class="line">        <span class="keyword">if</span> (ttlMillis &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 设置过期时间</span></span><br><span class="line">            <span class="keyword">long</span> expMillis = nowMillis + ttlMillis;</span><br><span class="line">            Date expDate = <span class="keyword">new</span> Date(expMillis);</span><br><span class="line">            builder.setExpiration(expDate);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> builder.compact();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解密jwt</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> jwt</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Claims <span class="title">parseJWT</span><span class="params">(String jwt)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        SecretKey key = generateKey();</span><br><span class="line">        Claims claims = Jwts.parser()</span><br><span class="line">                .setSigningKey(key)</span><br><span class="line">                .parseClaimsJws(jwt).getBody();</span><br><span class="line">        <span class="keyword">return</span> claims;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成subject信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> user</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">generalSubject</span><span class="params">(User user)</span></span>&#123;</span><br><span class="line">        JSONObject jo = <span class="keyword">new</span> JSONObject();</span><br><span class="line">        jo.put(<span class="string">"id"</span>, user.getId());</span><br><span class="line">        <span class="keyword">return</span> jo.toJSONString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><p>本博客的完整代码在这里，可以参考一下：<br><a href="https://github.com/mstao/LightBlog/tree/master/light-blog-web" target="_blank" rel="noopener">https://github.com/mstao/LightBlog/tree/master/light-blog-web</a></p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="http://www.scienjus.com/restful-token-authorization/" target="_blank" rel="noopener">http://www.scienjus.com/restful-token-authorization/</a></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> RESTful-API </tag>
            
            <tag> Token </tag>
            
            <tag> JWT </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>双向链表结构分析</title>
      <link href="/2017/12/17/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90/"/>
      <url>/2017/12/17/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="双向链表描述"><a href="#双向链表描述" class="headerlink" title="双向链表描述"></a>双向链表描述</h3><p>双向链表也叫双链表，它的每个数据结点都有两个指针，分别指向前驱结点和后继节点，同时有一个数据域来保存数据，双向链表的图示如下：</p><p><img src="/images/DoubleLinkedList.png" alt="image"></p><p>从图片可以看出，双链表的头结点的前驱结点和尾结点的后继结点为空，这一点要注意，对双链表的操作要检查这两种情况。</p><h3 id="双向链表结构"><a href="#双向链表结构" class="headerlink" title="双向链表结构"></a>双向链表结构</h3><p>每个数据结点都有两个指针，分别指向前驱结点和后继节点，同时有一个数据域来保存数据，我们先来定义一个数据结点的结构：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 内部Node，用于存储链表的结点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mingshan</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 存储节点的值</span></span><br><span class="line">    E item;</span><br><span class="line">    <span class="comment">// 指向节点的前驱结点</span></span><br><span class="line">    Node next;</span><br><span class="line">    <span class="comment">// 指向节点的后继结点</span></span><br><span class="line">    Node prev;</span><br><span class="line"></span><br><span class="line">    Node(Node prev, E element, Node next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.item = element;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">        <span class="keyword">this</span>.prev = prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>从Node类我们可以看出，item代表结点存储的元素，next指向链表的后继结点，prev指向前驱结点，由于我们在写单链表时定义了<strong>LinkedList</strong>接口，所以我们直接实现这个接口好了。</p><p>下面是对双向链表的功能的具体分析。</p><h3 id="add方法"><a href="#add方法" class="headerlink" title="add方法"></a>add方法</h3><p>我们现在定义三个成员变量：<strong>size</strong>， <strong>first</strong>，<strong>last</strong>，用来表示链表结点的个数以及指向链表头结点和尾节点，代码与解释如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 链表结点数量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指向头结点</span></span><br><span class="line"><span class="keyword">private</span> Node first;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指向尾结点</span></span><br><span class="line"><span class="keyword">private</span> Node last;</span><br></pre></td></tr></table></figure><h4 id="add-E-data"><a href="#add-E-data" class="headerlink" title="add(E data)"></a>add(E data)</h4><p>首先我们来实现<strong>add(E data)</strong>方法，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (data == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">// 将当前结点作为尾结点</span></span><br><span class="line">    linkLast(data);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个方法中我们调用了linkLast(data)这个方法来将当前节点作为尾结点，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将当前结点作为尾结点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">linkLast</span><span class="params">(E data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node l = last;</span><br><span class="line">    <span class="keyword">final</span> Node newNode = <span class="keyword">new</span> Node(l, data, <span class="keyword">null</span>);</span><br><span class="line">    last = newNode;</span><br><span class="line">    <span class="keyword">if</span> (l == <span class="keyword">null</span>) &#123;</span><br><span class="line">        first = newNode;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 原来的尾结点指向新结点</span></span><br><span class="line">        l.next = newNode;</span><br><span class="line">    &#125;</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在linkLast方法中，先获取尾结点，再构造新节点，让last指向新节点，然后开始判断原来的尾节点是否为空，为空代表链表为空，让first指向新结点即可；如果不为空，那么原来的尾结点的next指向新结点。</p><h4 id="add-int-index-E-data"><a href="#add-int-index-E-data" class="headerlink" title="add(int index, E data)"></a>add(int index, E data)</h4><p>我们再来<strong>add(int index, E data)</strong>这个方法怎么实现，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (data == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    checkPositionIndex(index);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断在该索引的结点是不是尾结点</span></span><br><span class="line">    <span class="keyword">if</span> (size == index) &#123;</span><br><span class="line">        <span class="comment">// 将当前结点作为尾结点</span></span><br><span class="line">        linkLast(data);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 将结点插入到指定位置index(原来的结点之前)</span></span><br><span class="line">        linkBefore(index, data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法的作用是向索引位置index处添加结点，这个时候我们就需要检测index是否有效，<strong>checkPositionIndex(index)</strong>相关的方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 检测索引位置是否合法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkPositionIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isPositionIndex(index))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"参数不合法"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isPositionIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> index &gt;= <span class="number">0</span> &amp;&amp; index &lt;= size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果index符合以上要求，那么就要判断在该索引位置的结点是不是尾结点，如果是，直接调用<strong>linkLast(data)</strong> 将当前节点作为尾结点；如果不是，将结点插入到指定位置index(原来的结点之前)，此时调用<strong>linkBefore(index, data)</strong>方法，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将结点插入到指定位置index(原来的结点之前)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> data</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">linkBefore</span><span class="params">(<span class="keyword">int</span> index, E data)</span> </span>&#123;</span><br><span class="line">    Node curr = node(index);</span><br><span class="line">    Node pred = curr.prev;</span><br><span class="line">    Node newNode = <span class="keyword">new</span> Node(pred, data, curr);</span><br><span class="line">    curr.prev = newNode;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (pred == <span class="keyword">null</span>) &#123;</span><br><span class="line">        first = newNode;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        pred.next = newNode;</span><br><span class="line">    &#125;</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在该方法中，我们需要获取在该索引位置的节点<strong>curr</strong>，<strong>curr</strong>的前驱结点<strong>pred</strong>，以及构造新节点<strong>newNode</strong>，同时还要将<strong>curr</strong>的前驱结点指向新节点，然后判断<strong>pred</strong>是否为空，如果<strong>pred</strong>为空，说明<strong>curr</strong>为头结点，那么此时就让新节点作为头结点；如果不为空，说明此时属于一般情况，在链表的中间的某个位置插入元素，那么就让<strong>prev</strong>的后继结点指向新节点就行了。</p><h3 id="remove方法"><a href="#remove方法" class="headerlink" title="remove方法"></a>remove方法</h3><h4 id="remove-int-index"><a href="#remove-int-index" class="headerlink" title="remove(int index)"></a>remove(int index)</h4><p>根据索引位置来删除元素，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    checkElementIndex(index);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取在该索引位置上的结点</span></span><br><span class="line">    Node c = node(index);</span><br><span class="line">    E element = c.item;</span><br><span class="line">    Node prev = c.prev;</span><br><span class="line">    Node next = c.next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 代表头结点</span></span><br><span class="line">    <span class="keyword">if</span> (prev == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 将下一个结点置为头结点</span></span><br><span class="line">        first = next;</span><br><span class="line">        <span class="comment">// 将下一个结点的前驱结点置为null</span></span><br><span class="line">        next.prev = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 将原来头结点的后继结点置为null</span></span><br><span class="line">        c.next = <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 移除尾结点</span></span><br><span class="line">        last = prev;</span><br><span class="line">        <span class="comment">// 前一个结点的后继结点置为null</span></span><br><span class="line">        prev.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 将原来尾结点的前驱结点置为null</span></span><br><span class="line">        c.prev = <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 属于一般情况</span></span><br><span class="line">        <span class="comment">// 将前一个结点的后继结点置为原结点的后继结点</span></span><br><span class="line">        prev.next = next;</span><br><span class="line">        <span class="comment">// 将后一个结点的前驱结点置为原结点的前驱结点</span></span><br><span class="line">        next.prev = prev;</span><br><span class="line">        <span class="comment">// 切断当前删除的结点的前驱和后继结点</span></span><br><span class="line">        c.prev = <span class="keyword">null</span>;</span><br><span class="line">        c.next = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    c.item = <span class="keyword">null</span>;</span><br><span class="line">    size--;</span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在该方法中，还是要先检测索引是否合法，这里是<strong>checkElementIndex(index)</strong>方法，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 检测元素位置是否合法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkElementIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isElementIndex(index))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">"查找元素位置不合法"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isElementIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> index &gt;= <span class="number">0</span> &amp;&amp; index &lt; size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>检测通过后就要获取在该索引处的结点信息，包括结点的数据，前驱节点和后继节点，此时有三种情况需要考虑：</p><ul><li>如果<strong>prev</strong>为空，代表该结点为头结点，那么就将下一个结点置为头结点，然后将下一个结点的前驱结点置为null，最后将原来头结点的后继结点置为null。说白了就是讲头结点移除，同时解除头结点与后面一个节点的关系。</li><li>如果<strong>next</strong>为空，代表该结点为尾节点，那么就将尾节点的前驱节点作为尾节点，前一个结点的后继结点置为null，将原来尾结点的前驱结点置为null。</li><li>如果既不是头结点，又不是尾节点，那么就属于一般情况了，此时将前一个结点的后继结点置为原结点的后继结点，将后一个结点的前驱结点置为原结点的前驱结点，最后切断当前删除的结点的前驱和后继结点。</li></ul><p>以上代码可以简化，具体可以参考JDK源码中<strong>java.util.LinkedList</strong>中的<strong>unlink</strong>方法，简化后的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代表头结点</span></span><br><span class="line"><span class="keyword">if</span> (prev == <span class="keyword">null</span>) &#123;</span><br><span class="line">    first = next;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    prev.next = next;</span><br><span class="line">    c.prev = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (next == <span class="keyword">null</span>) &#123;</span><br><span class="line">    last = prev;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    next.prev = prev;</span><br><span class="line">    c.next = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>老铁们看的懂吗(￣▽￣)／，其实和我上面的代码效果是一样的，只是把一般情况合并了，也很好理解。</p><h3 id="set方法"><a href="#set方法" class="headerlink" title="set方法"></a>set方法</h3><p>set方法将索引位置的结点的值替换成新的值，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (data == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    checkPositionIndex(index);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取原来在该索引位置上的结点</span></span><br><span class="line">    Node oldNode = node(index);</span><br><span class="line">    <span class="comment">// 获取原来结点的值</span></span><br><span class="line">    E oldValue = oldNode.item;</span><br><span class="line">    <span class="comment">// 更新值</span></span><br><span class="line">    oldNode.item = data;</span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时获取当前索引位置的结点用到了<strong>node(index)</strong>方法，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据索引获取结点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">node</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果当前索引值小于当前链表长度的一半，那么从头结点开始遍历</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt; size / <span class="number">2</span>) &#123;</span><br><span class="line">        Node temp = first;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++) &#123;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果当前索引值大于当前链表长度的一半，那么从尾结点反向遍历</span></span><br><span class="line">        Node temp = last;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = size - <span class="number">1</span>; i &gt; index; i--) &#123;</span><br><span class="line">            temp = temp.prev;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<strong>node</strong>方法中，我们进行了折半查找，这样效率会高些吧，哈哈，简单就不说了。</p><h3 id="get方法"><a href="#get方法" class="headerlink" title="get方法"></a>get方法</h3><p>获取传入索引的结点的值，也需要遍历双链表，就不说了，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    <span class="comment">// 获取其索引的结点</span></span><br><span class="line">    Node node = node(index);</span><br><span class="line">    <span class="keyword">return</span> node.item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="反转双链表"><a href="#反转双链表" class="headerlink" title="反转双链表"></a>反转双链表</h3><p>反转双链表，这里我采用是遍历双链表，逐个链接点进行反转。原理是：使用p和q两个指针配合工作，使得两个节点间的指向反向，同时用r记录剩下的链表。<br>图示如下：</p><p><img src="/images/DoubleLinkedList-reverse.png" alt="image"></p><p>具体代码和步骤参考如下代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (first != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 代表指向当前进行反转的下一个结点</span></span><br><span class="line">        Node r;</span><br><span class="line">        <span class="comment">// p 代表进行结点指向反转的结点前一个结点</span></span><br><span class="line">        Node p = first;</span><br><span class="line">        <span class="comment">// q 代表进行结点指向反转的当前结点</span></span><br><span class="line">        Node q = first.next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 首先将head指向的下一个结点置为null</span></span><br><span class="line">        <span class="comment">// 因为进行链表反转时头结点变成了尾结点，指向的下一个结点必然是null</span></span><br><span class="line">        first.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 进行循环操作，p, q指向向前移动</span></span><br><span class="line">        <span class="keyword">while</span> (q != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 将当前正在反转的结点的下一个结点指向r</span></span><br><span class="line">            r = q.next;</span><br><span class="line">            <span class="comment">// 将当前结点的下一个结点指向其前一个结点(由指向后一个结点改为指向前一个结点)</span></span><br><span class="line">            q.next = p;</span><br><span class="line">            <span class="comment">// 将当前结点的prev改为指向下一个结点</span></span><br><span class="line">            p.prev = q;</span><br><span class="line">            <span class="comment">// p和q都向链表后面移一位</span></span><br><span class="line">            <span class="comment">// 原来的q变成了p</span></span><br><span class="line">            p = q;</span><br><span class="line">            <span class="comment">// 原来的r变成了q</span></span><br><span class="line">            q = r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将最后一个结点的prev指向为null</span></span><br><span class="line">        p.prev = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 将原来的头结点置为尾结点</span></span><br><span class="line">        last = first;</span><br><span class="line">        <span class="comment">// 将最后一个结点置为头结点</span></span><br><span class="line">        first = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><p>本篇博客的完整代码</p><p><a href="https://github.com/mstao/data-structures/blob/master/LinkedList/src/pers/mingshan/linkedlist/DoubleLinkedList.java" target="_blank" rel="noopener">https://github.com/mstao/data-structures/blob/master/LinkedList/src/pers/mingshan/linkedlist/DoubleLinkedList.java</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> 链表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 双向链表 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>栈结构分析</title>
      <link href="/2017/12/17/%E6%A0%88%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90/"/>
      <url>/2017/12/17/%E6%A0%88%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="栈介绍"><a href="#栈介绍" class="headerlink" title="栈介绍"></a>栈介绍</h3><p>栈是一种仅在表头进行插入和删除操作的线性表，并且属于后进先出（last-in，first-out，LIFO）原则，下面是栈的入栈和出栈的图示：</p><p><img src="/images/Stack.png" alt="image"></p><h3 id="主要操作"><a href="#主要操作" class="headerlink" title="主要操作"></a>主要操作</h3><p>栈主要有入栈和出栈操作，但要实现完整的栈操作，我们需要定义一些方法</p><ul><li>push 入栈，将元素压入栈顶</li><li>pop 出栈，获取栈顶元素并将其从栈中删除</li><li>peek 获取栈顶元素，但不删除</li><li>empty 判断栈是否为空</li><li>size 获取栈内元素的数量</li></ul><p>下面来介绍一下实现这些方法的具体实现。</p><a id="more"></a><h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><p>栈内的元素是放在数组里面的，所以我们需要一些变量来存储和描述这些数据，定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 存放栈内元素的数组，默认大小为10</span></span><br><span class="line"><span class="keyword">private</span> Object[] elementData;</span><br><span class="line"><span class="comment">// 元素的数量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> elementCount;</span><br><span class="line"><span class="comment">// 指定要增加的容量大小</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> capacityIncrement;</span><br></pre></td></tr></table></figure><p>在构造方法中初始数组容量，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过传入自定义的值来初始化数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> initialCapacity 数组容初始量</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> capacityIncrement 扩容增加的容量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Stack</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">int</span> capacityIncrement)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span>+</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">    <span class="keyword">this</span>.capacityIncrement = capacityIncrement;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过传入自定义的值来初始化数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> initialCapacity 数组初始容量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Stack</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(initialCapacity, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构造方法初始化数组容量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Stack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="push"><a href="#push" class="headerlink" title="push"></a>push</h4><p>入栈操作需要将数据存到数组里面，如有数组有初始化大小，所以每次入栈操作需要检查数组的大小，大小不够需要进行扩容操作，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 入栈</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> data</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 入栈的数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">push</span><span class="params">(E data)</span> </span>&#123;</span><br><span class="line">    addElement(data);</span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里调用了<strong>addElement(data)</strong>方法，我们来看看代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 向栈顶添加元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> obj</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addElement</span><span class="params">(E obj)</span> </span>&#123;</span><br><span class="line">    ensureCapacity(elementCount + <span class="number">1</span>);</span><br><span class="line">    elementData[elementCount++] = obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<strong>addElement(data)</strong>方法中调用ensureCapacity来检测数组的大小，扩容操作也是在这个方法中进行的，下面是方法的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 确保栈容量，扩容</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> minCapacity </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="comment">// 判断是否需要扩容</span></span><br><span class="line">    <span class="keyword">if</span> (oldCapacity &lt; minCapacity) &#123;</span><br><span class="line">        <span class="comment">// 指定要扩大多少，否则就扩容2倍</span></span><br><span class="line">        <span class="keyword">int</span> newCapacity = oldCapacity + (<span class="keyword">this</span>.capacityIncrement &gt; <span class="number">0</span> </span><br><span class="line">                ? <span class="keyword">this</span>.capacityIncrement : oldCapacity);</span><br><span class="line">        <span class="comment">// 将原数组的容量拷贝到扩容后的数组</span></span><br><span class="line">        elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个方法中，首先判断当前的数组的大小够不够用，如果不够用，那么会根据传入的自定义扩容大小<strong>capacityIncrement</strong>来进行扩容操作，如果<strong>capacityIncrement</strong>小于0，那么容量就扩大2倍。最后将原来数组的数据拷贝到新数组中。</p><h4 id="pop"><a href="#pop" class="headerlink" title="pop"></a>pop</h4><p>出栈是将栈顶的元素移除并返回，下面是代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 出栈，移除栈顶的元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 被移除的元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    E obj = peek();</span><br><span class="line">    <span class="keyword">if</span> (size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 移除栈顶元素</span></span><br><span class="line">        elementData[elementCount - <span class="number">1</span>] = <span class="keyword">null</span>;</span><br><span class="line">        elementCount--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在pop方法中，我们实则是调用了<strong>peek</strong>方法来获取栈顶元素，然后将栈顶元素移除下面来看<strong>peek</strong>的代码。</p><h4 id="peek"><a href="#peek" class="headerlink" title="peek"></a>peek</h4><p>peek方法是获取栈顶的元素，代码比较简单</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取栈顶的元素，但不移除</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 栈顶的元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = size();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> EmptyStackException();</span><br><span class="line">    E obj = (E) elementData[elementCount - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="search"><a href="#search" class="headerlink" title="search"></a>search</h4><p>通过传入的元素来获取该元素第一次出现的位置，如果找不到返回-1，下面是代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回对象在堆栈中的位置，以 0 为基数。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> element</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 元素第一次出现的位置，找不到返回-1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(Object element)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> z = elementCount - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (element == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = z; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (elementData[i] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = z; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (element.equals(elementData[i])) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于栈可以存储null，所以需对null进行处理。</p><h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><p>本篇博客的完整代码</p><p><a href="https://github.com/mstao/data-structures/blob/master/Stack/src/pers/mingshan/stack/Stack.java" target="_blank" rel="noopener">https://github.com/mstao/data-structures/blob/master/Stack/src/pers/mingshan/stack/Stack.java</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> 栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>单链表结构分析</title>
      <link href="/2017/12/12/%E5%8D%95%E9%93%BE%E8%A1%A8%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90/"/>
      <url>/2017/12/12/%E5%8D%95%E9%93%BE%E8%A1%A8%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="单链表描述"><a href="#单链表描述" class="headerlink" title="单链表描述"></a>单链表描述</h3><p>单链表又为单向链表，由数据域(Data)和结点域(Node)组成，数据域代表该结点所存储的元素，结点域指向下一个节点，单链表的图示如下：</p><p><img src="/images/SingleLinkedList.png" alt="image"></p><h3 id="单链表结构"><a href="#单链表结构" class="headerlink" title="单链表结构"></a>单链表结构</h3><p>我们先定义一下单链表一个结点的结构，一个Node类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    E item;</span><br><span class="line">    Node next;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.item = e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>从Node类我们可以看出，item代表结点存储的元素，next指向链表的下一个节点。谈到链表，肯定少不了链表的基本操作，比如添加结点，删除结点，获取给定索引的节点啦，所以我们先写一个链表接口LinkedList，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> pers.mingshan.linkedlist;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 链表接口</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mingshan</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;E&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">LinkedList</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据索引获取节点的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index 传入的索引值， 从1开始</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 节点的值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置某个结点的的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index 传入的索引值， 从1开始</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data 要插入的元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 旧的节点的值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E data)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据index添加结点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index 传入的索引值， 从1开始</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data 要插入的元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 插入是否成功</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E data)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加结点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 插入是否成功</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E data)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据index移除结点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index 传入的索引值， 从1开始</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 移除成功返回该索引处的旧值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据data移除结点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是否移除成功</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">removeAll</span><span class="params">(E data)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 清空链表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否包含data结点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 包含返回&#123;<span class="doctag">@code</span> true&#125;, 不包含返回 &#123;<span class="doctag">@code</span> false&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(E data)</span></span>;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取链表长度</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 链表长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">length</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断链表是否为空</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 链表为空返回&#123;<span class="doctag">@code</span> true&#125;, 不为空返回 &#123;<span class="doctag">@code</span> false&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 链表反转</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这么多方法，先实现哪个呢？由于我们做了很多的增删改查，那么就从增加新结点开始吧(￣▽￣)／</p><h3 id="add方法"><a href="#add方法" class="headerlink" title="add方法"></a>add方法</h3><p>我们首先实现<strong><em>add(E data)</em></strong>，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (data == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">        Node newNode = <span class="keyword">new</span> Node(data);</span><br><span class="line">        head = newNode;</span><br><span class="line">        size++;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node temp = head;</span><br><span class="line">    <span class="comment">// 从头结点向后遍历，获取链表最后一个节点</span></span><br><span class="line">    <span class="keyword">while</span> (temp.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// temp 始终指向下一个节点</span></span><br><span class="line">        temp = temp.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据当前元素构造新节点</span></span><br><span class="line">    Node newNode = <span class="keyword">new</span> Node(data);</span><br><span class="line">    <span class="comment">// 将最后一节点的next指向新节点</span></span><br><span class="line">    temp.next = newNode;</span><br><span class="line">    <span class="comment">// 计数加一</span></span><br><span class="line">    size++;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<strong>add(E data)</strong>方法中，首先进行判空操作，然后检查头结点是否为空，如果头结点为空那么就把该新结点作为头结点；如果头结点不为空，那么就需要从头结点开始遍历单链表，直到找到尾节点，并将原来的尾节点的next指向新添加的结点，链表的元素数量加一。</p><p>然后实现<strong>add(int index, E data)</strong>，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据索引插入元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e 要插入的元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index 传入的索引值， 从1开始</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (data == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    checkPositionIndex(index);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">    Node temp = head;</span><br><span class="line">    <span class="comment">// 从头结点向后遍历</span></span><br><span class="line">    <span class="keyword">while</span> (temp.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 1       2 </span></span><br><span class="line">        <span class="comment">// temp  temp.next</span></span><br><span class="line">        <span class="comment">// 假设现在index为2 那么原先在2位置上的节点需要向后移动一个</span></span><br><span class="line">        <span class="comment">// 1           2              3</span></span><br><span class="line">        <span class="comment">// temp    temp.next(e)     temp.next.next</span></span><br><span class="line">        <span class="comment">// 判断是否到了传入的索引</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果索引为1，那么将当前节点置为头结点</span></span><br><span class="line">        <span class="keyword">if</span> (index == <span class="number">1</span>) &#123;</span><br><span class="line">            Node newNode = <span class="keyword">new</span> Node(data);</span><br><span class="line">            head = newNode;</span><br><span class="line">            head.next = temp;</span><br><span class="line">            size++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断是否到了传入的索引</span></span><br><span class="line">        <span class="keyword">if</span> (++count == index) &#123;</span><br><span class="line">            <span class="comment">// 构造新节点</span></span><br><span class="line">            Node newNode = <span class="keyword">new</span> Node(data);</span><br><span class="line">            <span class="comment">// 将当前的位置的节点设置为新节点</span></span><br><span class="line">            newNode.next = temp.next;</span><br><span class="line">            temp.next = newNode;</span><br><span class="line">            size++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// temp 始终指向下一个节点</span></span><br><span class="line">        temp = temp.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>add(int index, E data)</strong>这个方法是根据传入的索引值向链表插入元素。首选需要进行判空操作，然后检测传入的索引值是否合法，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 检测索引位置是否合法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkPositionIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isPositionIndex(index))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"参数不合法"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isPositionIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> index &gt;= <span class="number">1</span> &amp;&amp; index &lt;= size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>检测完之后，需要判断传入的索引值的位置上的节点是否为头结点，如果是，将新结点设置为头结点，并将新结点的next指向原来的头结点。然后进行链表遍历，直到索引位置，在该位置之前插入新结点即可，具体参考代码注释。</p><h3 id="remove方法"><a href="#remove方法" class="headerlink" title="remove方法"></a>remove方法</h3><p>现在我们根据索引值删除结点，代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据索引删除元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index 传入的索引值， 从1开始</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    checkPositionIndex(index);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">    Node temp = head;</span><br><span class="line">    <span class="comment">// 从头结点向后遍历</span></span><br><span class="line">    <span class="keyword">while</span> (temp.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (index == <span class="number">1</span>) &#123;</span><br><span class="line">            head = head.next;</span><br><span class="line">            <span class="keyword">return</span> head.item;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (++count == index) &#123;</span><br><span class="line">            E oldValue = temp.next.item;</span><br><span class="line">            temp.next = temp.next.next;</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// temp 始终指向下一个节点</span></span><br><span class="line">        temp = temp.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个删除操作也比较简单，也需要遍历单链表，直到索引位置结点，然后将结点的前驱节点的next指向索引节点的下一个节点即可。</p><h3 id="set方法"><a href="#set方法" class="headerlink" title="set方法"></a>set方法</h3><p>set方法将索引的结点的值设置为传入的值，也需要遍历单链表，套路都一样。代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (data == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    checkPositionIndex(index);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">    Node temp = head;</span><br><span class="line">    <span class="keyword">while</span> (temp != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (count++ == index) &#123;</span><br><span class="line">            E oldValue = temp.item;</span><br><span class="line">            temp.item = data;</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">        temp = temp.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="get方法"><a href="#get方法" class="headerlink" title="get方法"></a>get方法</h3><p>获取传入索引的结点的值，也需要遍历单链表，就不说了，代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    checkPositionIndex(index);</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">    Node temp = head;</span><br><span class="line">    <span class="keyword">while</span> (temp != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (count++ == index) &#123;</span><br><span class="line">            <span class="keyword">return</span> temp.item;</span><br><span class="line">        &#125;</span><br><span class="line">        temp = temp.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="反转单链表"><a href="#反转单链表" class="headerlink" title="反转单链表"></a>反转单链表</h3><p>反转单链表，这里我采用是遍历单链表，逐个链接点进行反转。原理是：使用p和q两个指针配合工作，使得两个节点间的指向反向，同时用r记录剩下的链表。流程如下图：</p><p><img src="/images/SingleLinkedList-reverse.png" alt="image"></p><p>具体代码和步骤参考如下代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 链表反转</span></span><br><span class="line"><span class="comment"> * 遍历单链表，逐个链接点进行反转。</span></span><br><span class="line"><span class="comment"> * 原理：</span></span><br><span class="line"><span class="comment"> * 使用p和q两个指针配合工作，使得两个节点间的指向反向，同时用r记录剩下的链表。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 代表指向当前进行反转的下一个节点</span></span><br><span class="line">        Node r;</span><br><span class="line">        <span class="comment">// p 代表进行节点指向反转的节点前一个节点</span></span><br><span class="line">        Node p = head;</span><br><span class="line">        <span class="comment">// q 代表进行节点指向反转的当前节点</span></span><br><span class="line">        Node q = head.next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 首先将head指向的下一个节点置为null</span></span><br><span class="line">        <span class="comment">// 因为进行链表反转时头结点变成了尾节点，指向的下一个节点必然是null</span></span><br><span class="line">        head.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 进行循环操作，p, q指向向前移动</span></span><br><span class="line">        <span class="keyword">while</span> (q != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 将当前正在反转的节点的下一个节点指向r</span></span><br><span class="line">            r = q.next;</span><br><span class="line">            <span class="comment">// 将当前节点的下一个节点指向其前一个节点(由指向后一个节点改为指向前一个节点)</span></span><br><span class="line">            q.next = p;</span><br><span class="line">            <span class="comment">// p和q都向链表后面移一位</span></span><br><span class="line">            <span class="comment">// 原来的q变成了p</span></span><br><span class="line">            p = q;</span><br><span class="line">            <span class="comment">// 原来的r变成了q</span></span><br><span class="line">            q = r;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        head = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><p>本篇博客的完整代码</p><p><a href="https://github.com/mstao/data-structures/blob/master/LinkedList/src/pers/mingshan/linkedlist/SingleLinkedList.java" target="_blank" rel="noopener">https://github.com/mstao/data-structures/blob/master/LinkedList/src/pers/mingshan/linkedlist/SingleLinkedList.java</a></p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="http://blog.csdn.net/feliciafay/article/details/6841115" target="_blank" rel="noopener">http://blog.csdn.net/feliciafay/article/details/6841115</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> 链表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 单链表 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>恢复被Reset掉的提交</title>
      <link href="/2017/12/04/%E6%81%A2%E5%A4%8D%E8%A2%ABReset%E6%8E%89%E7%9A%84%E6%8F%90%E4%BA%A4/"/>
      <url>/2017/12/04/%E6%81%A2%E5%A4%8D%E8%A2%ABReset%E6%8E%89%E7%9A%84%E6%8F%90%E4%BA%A4/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>记得有一次我用github的桌面客户端提交代码时，提交了我不想提交的内容，于是我就点了Revert按钮，进行了<strong>Revert</strong>操作，这个操作会撤销一个提交的同时会新建一个提交，这也不是我想要的效果，所以我就用了Reset命令，最后操作失误，提交的代码都丢了，这让我很忧伤，但我之前进行提交操作了，git会有提交记录，所以我查了查命令，发现了<strong>git reflog</strong>命令，这个命令用于记录对git仓库进行的各种操作，输入命令显示如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">D:\code\LightBlog [master ≡ +0 ~2 -0 !]&gt; git reflog</span><br><span class="line">4ca2fb7 HEAD@&#123;0&#125;: commit: Add spring-redis for cache</span><br><span class="line">ddcc61a HEAD@&#123;1&#125;: commit: Add light blog ui template</span><br><span class="line">1e9f0b9 HEAD@&#123;2&#125;: pull --progress --prune origin master: Fast-forward</span><br><span class="line">93d6519 HEAD@&#123;3&#125;: commit: Add encryption util with MD5</span><br><span class="line">1d158ff HEAD@&#123;4&#125;: commit: fIX(#2) HttpStatus 204 -&gt;no content</span><br><span class="line">ef8cb50 HEAD@&#123;5&#125;: revert: Revert &quot;Refine exception handler&quot;</span><br><span class="line">51a7b00 HEAD@&#123;6&#125;: rebase: updating HEAD</span><br><span class="line">51a7b00 HEAD@&#123;7&#125;: rebase: aborting</span><br><span class="line">e20b30f HEAD@&#123;8&#125;: pull --progress --rebase --prune origin master: checkout e20b30f0a282cb4b1229a5ebcf220422d3685c40</span><br><span class="line">51a7b00 HEAD@&#123;9&#125;: commit: Refine exception handler</span><br><span class="line">294b1e3 HEAD@&#123;10&#125;: pull --progress --prune origin master: Merge made by the &apos;recursive&apos; strategy.</span><br><span class="line">927ff21 HEAD@&#123;11&#125;: commit: Add exception handler for RESTful</span><br><span class="line">4e2592c HEAD@&#123;12&#125;: commit: Add authorization for web with redis.</span><br></pre></td></tr></table></figure><p>可以看见每次操作都会有记录的（没有全部贴出来），这是我们可以用<strong>git reset ID</strong>来恢复内容，ID指的第一列的东西，比如<strong>4ca2fb7</strong>，这样我们就可以找回丢失的内容了。</p><p>下面是我常用的一套命令，用来更新本地代码，这也是我经过好几次拉取远程代码冲突一大片得到的经验，<strong>git mergetool</strong>指的是当发生代码冲突时，输入此命令就会进行冲突的解决，由于我用的VS，输入此命令后就会跳到VS中来解决冲突了，对于一个文件如果冲突实在是太多，推荐<strong>winmerge</strong>工具，一个轻量且免费的冲突合并工具，我平时也用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br><span class="line"></span><br><span class="line">git commit -m &apos;temp commit&apos;</span><br><span class="line"></span><br><span class="line">git stash save appconfig</span><br><span class="line"></span><br><span class="line">git log</span><br><span class="line"></span><br><span class="line">git pull -r origin develop</span><br><span class="line"></span><br><span class="line">git mergetool(回车合并冲突)</span><br><span class="line"></span><br><span class="line">git reset HEAD~</span><br><span class="line"></span><br><span class="line">git stash apply</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>SpringBoot与RabbitMQ结合使用</title>
      <link href="/2017/11/25/SpringBoot%E4%B8%8ERabbitMQ%E7%BB%93%E5%90%88%E4%BD%BF%E7%94%A8/"/>
      <url>/2017/11/25/SpringBoot%E4%B8%8ERabbitMQ%E7%BB%93%E5%90%88%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>上一篇文章中是使用amqp-client来操作RabbitMQ的，但我们平常用SpringBoot比较多，SpringBoot也整合了RabbitMQ，用起来是十分方便的。</p><p>首先，我们先添加依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后在application.properties文件添加RabbitMQ的配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># rabbitmq</span><br><span class="line">spring.application.name=spring-boot-rabbitmq</span><br><span class="line">spring.rabbitmq.host=127.0.0.1</span><br><span class="line">spring.rabbitmq.port=5672</span><br><span class="line">spring.rabbitmq.username=guest</span><br><span class="line">spring.rabbitmq.password=guest</span><br><span class="line">spring.rabbitmq.publisher-confirms=true</span><br></pre></td></tr></table></figure><h2 id="Hello"><a href="#Hello" class="headerlink" title="Hello"></a>Hello</h2><p>我们先来个hello，首先在发送方注入<strong>AmqpTemplate</strong>，像其它Spring Framework提供的高级抽象一样， Spring AMQP 提供了扮演核心角色的模板. 定义了主要操作的接口称为AmqpTemplate. 这些操作包含了发送和接收消息的一般行为。</p><p>在配置类RabbitConfig类生成一个名为hello_rq的队列</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class RabbitConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public Queue helloQueue() &#123;</span><br><span class="line">        return new Queue(&quot;hello_rq&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>发送方：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sender</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(Sender.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AmqpTemplate amqpTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String context = <span class="string">"hello "</span> + <span class="keyword">new</span> Date();</span><br><span class="line">        logger.info(<span class="string">"Sender : "</span> + context);</span><br><span class="line">        <span class="keyword">this</span>.amqpTemplate.convertAndSend(<span class="string">"hello_rq"</span>, context);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们用了convertAndSend方法进行消息的发送，将消息发送到hello_rq的队列中</p><p><strong>接收方：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RabbitListener</span>(queues = <span class="string">"hello_rq"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Receiver</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(Receiver.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitHandler</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(String hello)</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">"Receiver1  : "</span> + hello);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在接收方利用@RabbitListener注解来监听队列，利用@RabbitHandler来处理消息</p><a id="more"></a><p><strong>测试类：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringJUnit4ClassRunner.class)</span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Sender sender;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        sender.send();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四种-Exchange-Types"><a href="#四种-Exchange-Types" class="headerlink" title="四种 Exchange Types"></a>四种 Exchange Types</h2><h3 id="fanout"><a href="#fanout" class="headerlink" title="fanout"></a>fanout</h3><p>fanout类型的Exchange路由规则非常简单，它会把所有发送到该Exchange的消息路由到所有与它绑定的Queue中。</p><p><strong>生产者代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FanoutProducer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(FanoutProducer.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AmqpTemplate amqpTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String message = <span class="string">"This is topic message ====!"</span>;</span><br><span class="line">        logger.info(<span class="string">"message =&gt; "</span> + message);</span><br><span class="line">        <span class="keyword">this</span>.amqpTemplate.convertAndSend(<span class="string">"ex.fanout"</span>, <span class="string">""</span>, message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中的convertAndSend有三个参数，第一个参数设置exchange名称，第二个参数设置routingKey，第三个参数设置要发送的消息，由于是fanout，所以没必要设置routingKey的值，其实在源码中，也是最终调用channel.basicPublish方法的。源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BasicProperties convertedMessageProperties = <span class="keyword">this</span>.messagePropertiesConverter</span><br><span class="line">.fromMessageProperties(messageProperties, <span class="keyword">this</span>.encoding);</span><br><span class="line">channel.basicPublish(exchange, routingKey, mandatory, convertedMessageProperties, messageToUse.getBody());</span><br></pre></td></tr></table></figure><p><strong>消费者代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RabbitListener</span>(bindings = <span class="meta">@QueueBinding</span>(value = <span class="meta">@Queue</span>,</span><br><span class="line">        exchange = <span class="meta">@Exchange</span>(value = <span class="string">"ex.fanout"</span>, type = ExchangeTypes.FANOUT)</span><br><span class="line">))</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FanoutConsumerA</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(FanoutConsumerA.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitHandler</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">"ConsumerA Receiver :"</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里用@RabbitListener注解来监听，利用@RabbitHandler来处理消息。其中在@RabbitListener中又为队列，交换器和绑定的@QueueBinding 注解中指定参数，一个参数比较全的例子如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@RabbitListener(bindings = @QueueBinding(</span><br><span class="line">        value = @Queue(value = &quot;auto.headers&quot;, autoDelete = &quot;true&quot;,</span><br><span class="line">                        arguments = @Argument(name = &quot;x-message-ttl&quot;, value = &quot;10000&quot;,</span><br><span class="line">                                                type = &quot;java.lang.Integer&quot;)),</span><br><span class="line">        exchange = @Exchange(value = &quot;auto.headers&quot;, type = ExchangeTypes.HEADERS, autoDelete = &quot;true&quot;),</span><br><span class="line">        arguments = &#123;</span><br><span class="line">                @Argument(name = &quot;x-match&quot;, value = &quot;all&quot;),</span><br><span class="line">                @Argument(name = &quot;foo&quot;, value = &quot;bar&quot;),</span><br><span class="line">                @Argument(name = &quot;baz&quot;)</span><br><span class="line">        &#125;)</span><br><span class="line">)</span><br><span class="line">public class HeadersConsumerA &#123; &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意队列的x-message-ttl 参数设为了10秒钟，因为参数类型不是String， 因此我们指定了它的类型，在这里是Integer。有了这些声明后，如果队列已经存在了，参数必须匹配现有队列上的参数。对于header交换器，我们设置binding arguments 要匹配头中foo为bar，且baz可为任意值的消息。 x-match 参数则意味着必须同时满足两个条件。</p><p><strong>测试类：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringJUnit4ClassRunner.class)</span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FanoutTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> FanoutProducer fanoutProducer;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        fanoutProducer.send();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="direct"><a href="#direct" class="headerlink" title="direct"></a>direct</h3><p>direct类型的Exchange路由规则也比较简单，它会把消息路由到那些binding key与routing key完全匹配的Queue中。</p><p><strong>生产者代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DirectProducer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(DirectProducer.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AmqpTemplate amqpTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String message = <span class="string">"This is topic message @====!"</span>;</span><br><span class="line">        logger.info(<span class="string">"message =&gt; "</span> + message);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 参数意义</span></span><br><span class="line">        <span class="comment">// 第一个： exchange 名称</span></span><br><span class="line">        <span class="comment">// 第二个： routingKey</span></span><br><span class="line">        <span class="comment">// 第三个： 发送的消息</span></span><br><span class="line">        <span class="keyword">this</span>.amqpTemplate.convertAndSend(<span class="string">"ex.direct"</span>, <span class="string">"error"</span>, message)里面的第二个参数为routingKey,设置为</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时convertAndSend(“ex.direct”, “error”, message)里面的第二个参数为routingKey,设置为error，说明消费者的bindingKey须为error才能接受到消息，其他的接收不到。</p><p><strong>消费者代码:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RabbitListener</span>(bindings = <span class="meta">@QueueBinding</span>(value = <span class="meta">@Queue</span>,</span><br><span class="line">        exchange = <span class="meta">@Exchange</span>(value = <span class="string">"ex.direct"</span>, type = ExchangeTypes.DIRECT),</span><br><span class="line">        key = <span class="string">"info"</span></span><br><span class="line">))</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DirectConsumerA</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(DirectConsumerA.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitHandler</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">"ConsumerA Receiver :"</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在消费者A中，routingKey设置为info，自然接受不到消息了。</p><p><strong>测试类：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringJUnit4ClassRunner.class)</span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DirectTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> DirectProducer directProducer;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        directProducer.send();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="topic"><a href="#topic" class="headerlink" title="topic"></a>topic</h3><p>由于direct的匹配规则需要完全配置，没有灵活性，所以topic就弥补了这一缺点， routingKey 必须是由点分隔的单词列表。这些单词可以是任何东西，但通常它们指定连接到消息的一些功能。一些有效的路由键例子：“ stock.usd.nyse ”，“ nyse.vmw ”，“ quick.orange.rabbit ”。在路由选择键中可以有任意数量的字，最多255个字节。</p><p>绑定键也必须是相同的形式。binding key中可以存在两种特殊字符“*”与“#”，用于做模糊匹配：</p><ul><li>“*” 可以代替一个字。</li><li>“#” 可以代替零个或多个单词。</li></ul><p><strong>生产者代码:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TopicProducer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(TopicProducer.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AmqpTemplate amqpTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String message = <span class="string">"This is topic message @====!"</span>;</span><br><span class="line">        logger.info(<span class="string">"message =&gt; "</span> + message);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 参数意义</span></span><br><span class="line">        <span class="comment">// 第一个： exchange 名称</span></span><br><span class="line">        <span class="comment">// 第二个： routingKey</span></span><br><span class="line">        <span class="comment">// 第三个： 发送的消息</span></span><br><span class="line">        <span class="keyword">this</span>.amqpTemplate.convertAndSend(<span class="string">"ex.topic"</span>, <span class="string">"quick.orange.rabbit"</span>, message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时routingKey为quick.orange.rabbit，消费者可以对这个routingKey进行模糊匹配。</p><p><strong>消费者代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RabbitListener</span>(bindings = <span class="meta">@QueueBinding</span>(</span><br><span class="line">        <span class="comment">//value = @Queue(value = "myQueue", durable = "true"),</span></span><br><span class="line">        value = <span class="meta">@Queue</span>, <span class="comment">// 自动生成， 自动删除</span></span><br><span class="line">        exchange = <span class="meta">@Exchange</span>(value = <span class="string">"ex.topic"</span>, ignoreDeclarationExceptions = <span class="string">"true"</span>, type = ExchangeTypes.TOPIC),</span><br><span class="line">        key = <span class="string">"*.orange.*"</span>)</span><br><span class="line">)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TopicConsumerA</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(TopicConsumerA.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitHandler</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">"ConsumerA Receiver :"</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时bindingKey为<em>.orange.</em>，那么可以与生产者的routingKey匹配，那么这个消费者可以接受到消息。</p><h3 id="headers"><a href="#headers" class="headerlink" title="headers"></a>headers</h3><p>headers类型的Exchange不依赖于routing key与binding key的匹配规则来路由消息，而是根据发送的消息内容中的headers属性进行匹配。 在绑定Queue与Exchange时指定一组键值对；当消息发送到Exchange时，RabbitMQ会取到该消息的headers（也是一个键值对的形式），消费者会根据设置x-match设置的配置类型(all,any)来进行匹配。</p><p><strong>生产者代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeadersProducer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(TopicProducer.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AmqpTemplate amqpTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String mes = <span class="string">"This is headers message ====!"</span>;</span><br><span class="line">        logger.info(<span class="string">"message =&gt; "</span> + mes);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构建消息</span></span><br><span class="line">        Message message = MessageBuilder.withBody(mes.getBytes())</span><br><span class="line">                .setContentType(MessageProperties.CONTENT_TYPE_TEXT_PLAIN)</span><br><span class="line">                .setMessageId(<span class="string">"123"</span>)</span><br><span class="line">                .setHeader(<span class="string">"xiaoming"</span>, <span class="string">"123456"</span>)</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 参数意义</span></span><br><span class="line">        <span class="comment">// 第一个： exchange 名称</span></span><br><span class="line">        <span class="comment">// 第二个： routingKey</span></span><br><span class="line">        <span class="comment">// 第三个： 发送的消息</span></span><br><span class="line">        <span class="keyword">this</span>.amqpTemplate.convertAndSend(<span class="string">"ex.headers"</span>, <span class="string">""</span>, message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>生产者的代码比较特殊，首先我们需要构建消息，需要用到<strong>Message Builder API</strong>， MessageBuilder 和 MessagePropertiesBuilder提供了消息构建API; 它们提供了更加方便地创建消息和消息属性的方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构建消息</span></span><br><span class="line">Message message = MessageBuilder.withBody(mes.getBytes())</span><br><span class="line">        .setContentType(MessageProperties.CONTENT_TYPE_TEXT_PLAIN)</span><br><span class="line">        .setMessageId(<span class="string">"123"</span>)</span><br><span class="line">        .setHeader(<span class="string">"xiaoming"</span>, <span class="string">"123456"</span>)</span><br><span class="line">        .build();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者 ============================</span></span><br><span class="line"></span><br><span class="line">MessageProperties props = MessagePropertiesBuilder.newInstance()</span><br><span class="line">        .setContentType(MessageProperties.CONTENT_TYPE_TEXT_PLAIN)</span><br><span class="line">        .setMessageId(<span class="string">"123"</span>)</span><br><span class="line">        .setHeader(<span class="string">"xiaoming"</span>, <span class="string">"123456"</span>)</span><br><span class="line">        .build();</span><br><span class="line">Message message2 = MessageBuilder.withBody(mes.getBytes())</span><br><span class="line">        .andProperties(props)</span><br><span class="line">        .build();</span><br></pre></td></tr></table></figure><p>其中<strong>MessageProperties.CONTENT_TYPE_TEXT_PLAIN</strong>代表 <strong>text/plain</strong>, 当然还有其他格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String CONTENT_TYPE_BYTES = <span class="string">"application/octet-stream"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String CONTENT_TYPE_TEXT_PLAIN = <span class="string">"text/plain"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String CONTENT_TYPE_SERIALIZED_OBJECT = <span class="string">"application/x-java-serialized-object"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String CONTENT_TYPE_JSON = <span class="string">"application/json"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String CONTENT_TYPE_JSON_ALT = <span class="string">"text/x-json"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String CONTENT_TYPE_XML = <span class="string">"application/xml"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String SPRING_BATCH_FORMAT = <span class="string">"springBatchFormat"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String BATCH_FORMAT_LENGTH_HEADER4 = <span class="string">"lengthHeader4"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String SPRING_AUTO_DECOMPRESS = <span class="string">"springAutoDecompress"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String X_DELAY = <span class="string">"x-delay"</span>;</span><br></pre></td></tr></table></figure><p><strong>消费者代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RabbitListener</span>(bindings = <span class="meta">@QueueBinding</span>(value = <span class="meta">@Queue</span>,</span><br><span class="line">        exchange = <span class="meta">@Exchange</span>(value = <span class="string">"ex.headers"</span>, type = ExchangeTypes.HEADERS),</span><br><span class="line">        arguments = &#123;</span><br><span class="line">                <span class="meta">@Argument</span>(name = <span class="string">"x-match"</span>, value = <span class="string">"any"</span>),</span><br><span class="line">                <span class="meta">@Argument</span>(name = <span class="string">"xiaoming"</span>, value = <span class="string">"123456"</span>),</span><br><span class="line">                <span class="meta">@Argument</span>(name = <span class="string">"bbb"</span>, value = <span class="string">"1234567"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">))</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeadersConsumerA</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(HeadersConsumerA.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitHandler</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">"ConsumerA Receiver :"</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时headers的key-value形式映射为@Argument，x-match指明匹配模式，这里为any，代表只要有一个匹配到就可以接收到消息。</p><h2 id="源码地址"><a href="#源码地址" class="headerlink" title="源码地址"></a>源码地址</h2><p>你可以在这里看到本博文的源代码：</p><p><a href="https://github.com/mstao/spring-boot-learning/tree/master/spring-boot-rabbitmq" target="_blank" rel="noopener">https://github.com/mstao/spring-boot-learning/tree/master/spring-boot-rabbitmq</a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://www.blogjava.net/qbna350816/archive/2016/08/13/431562.html" target="_blank" rel="noopener">http://www.blogjava.net/qbna350816/archive/2016/08/13/431562.html</a></p>]]></content>
      
      
      <categories>
          
          <category> RabbitMQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> SpringBoot </tag>
            
            <tag> RabbitMQ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>RabbitMQ中四种Exchange Types的理解</title>
      <link href="/2017/11/20/RabbitMQ%E4%B8%AD%E5%9B%9B%E7%A7%8DExchange%20Types%E7%9A%84%E7%90%86%E8%A7%A3/"/>
      <url>/2017/11/20/RabbitMQ%E4%B8%AD%E5%9B%9B%E7%A7%8DExchange%20Types%E7%9A%84%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>由于在项目中用到了RabbitMQ，RabbitMQ是当前比较流行的消息中间件，所以在业余时间仔细了解下这个消息队列(Message Queue)。</p><h2 id="RabbitMQ简介"><a href="#RabbitMQ简介" class="headerlink" title="RabbitMQ简介"></a>RabbitMQ简介</h2><p>RabbitMQ实现了AMQP(Advanced Message Queuing Protocol)协议，AMQP是一种消息传递协议，是应用层协议的一个开放标准，为面向消息的中间件设计。具体介绍参考<a href="http://www.rabbitmq.com/tutorials/amqp-concepts.html" target="_blank" rel="noopener">：AMQP介绍</a></p><h2 id="RabbitMQ概念介绍"><a href="#RabbitMQ概念介绍" class="headerlink" title="RabbitMQ概念介绍"></a>RabbitMQ概念介绍</h2><p>RabbitMQ有许多重要的概念，了解这些概念对了解RabbitMQ是十分有必要的，下面简单介绍一下：</p><p>RabbitMQ 消息模型</p><pre><code>RabbitMQ消息发送时，生产者是不知道消息是否发送到某个队列中去了，生产者仅仅只能将消息发送给某个交换器。</code></pre><p>ConnectionFactory</p><pre><code>连接工厂类。可以创建一个连接。</code></pre><p>Connection</p><pre><code>在客户创建一个到某个虚拟主机的连接。</code></pre><p>Channel</p><pre><code>消息通道，包含了大量的API可用于编程。在客户端的每个连接里，可建立多个channel，每个channel代表一个会话任务。</code></pre><p>Broker</p><pre><code>RabbbitMQ消息队列代理服务器实体。</code></pre><p>Producer</p><pre><code>发送消息的应用程序。</code></pre><p>Consumer</p><pre><code>接收消息的用户程序。</code></pre><p>Exchange</p><pre><code>交换器，生产者直接将消息发送给交换器。交换器将消息分发给指定的队列。它指定消息按什么规则，路由到哪个队列。</code></pre><p>Binding</p><pre><code>绑定，指的是交换器和队列之间的关系。它的作用就是把exchange和queue按照路由规则绑定起来。</code></pre><p>Routing Key</p><pre><code>路由关键字，exchange根据这个关键字进行消息投递。</code></pre><p>vhost</p><pre><code>虚拟主机，一个broker里可以开设多个vhost，用作不同用户的权限分离。</code></pre><p>Excahnge Types</p><pre><code>RabbitMQ常用的Exchange Type有fanout、direct、topic、headers这四种，下面分别进行介绍。</code></pre><a id="more"></a><h2 id="Exchange-Types-简单介绍"><a href="#Exchange-Types-简单介绍" class="headerlink" title="Exchange Types 简单介绍"></a>Exchange Types 简单介绍</h2><p>下面对这四种Exchange Types进行简单介绍，由于用到maven来组织项目，所以需要先添加依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.rabbitmq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>amqp-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="fanout"><a href="#fanout" class="headerlink" title="fanout"></a>fanout</h3><p>fanout类型的Exchange路由规则非常简单，它会把所有发送到该Exchange的消息路由到所有与它绑定的Queue中。</p><p><img src="/images/mq_fanout.png" alt="image"></p><p>上图中，生产者（P）发送到Exchange（X）的所有消息都会路由到图中的两个Queue，并最终被两个消费者（C1与C2）消费。</p><p><strong>生产者代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 生产者</span></span><br><span class="line"><span class="comment"> * Exchange Types为fanout</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * fanout类型的Exchange路由规则非常简单，它会把所有发送到该Exchange的消息路由到所有与它绑定的Queue中。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mingshan</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String EXCHANGE_NAME = <span class="string">"logs"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        factory.setHost(<span class="string">"localhost"</span>);</span><br><span class="line">        Connection connection = factory.newConnection();</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">// 声明exchange，Exchange Types为fanout</span></span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.FANOUT);</span><br><span class="line"></span><br><span class="line">        String message = <span class="string">"Info-hello world"</span>;</span><br><span class="line">        channel.basicPublish(EXCHANGE_NAME, <span class="string">""</span>, <span class="keyword">null</span>, message.getBytes(<span class="string">"UTF-8"</span>));</span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于fanout不需要选择将消息路由到哪个Queue，所以channel.basicPublish方法的第二个参数routingKey就不需要设置。</p><p><strong>消费者代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 消费者</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mingshan</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerA</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String EXCHANGE_NAME = <span class="string">"logs"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        factory.setHost(<span class="string">"localhost"</span>);</span><br><span class="line">        Connection connection = factory.newConnection();</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.FANOUT);</span><br><span class="line"></span><br><span class="line">        String queueName = channel.queueDeclare().getQueue();</span><br><span class="line">        channel.queueBind(queueName, EXCHANGE_NAME, <span class="string">""</span>);</span><br><span class="line">        System.out.println(<span class="string">"A Waiting for messages. To exit press CTRL+C"</span>);</span><br><span class="line"></span><br><span class="line">        Consumer consumer = <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, BasicProperties properties, <span class="keyword">byte</span>[] body)</span></span></span><br><span class="line"><span class="function">                    <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                String message = <span class="keyword">new</span> String(body, <span class="string">"UTF-8"</span>);</span><br><span class="line">                System.out.println(<span class="string">"A Recv '"</span> + message + <span class="string">"'"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        channel.basicConsume(queueName, <span class="keyword">true</span>, consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在消费者代码中，我们的EXCHANGE_NAME需要与生产者的保持一致，channel.queueDeclare().getQueue()创建临时queue，channel.queueBind(queueName, EXCHANGE_NAME, “”)将exchange绑定到指定的queue上，第三个参数为routingKey，由于此处为fanout，所以为空。</p><h3 id="direct"><a href="#direct" class="headerlink" title="direct"></a>direct</h3><p>direct类型的Exchange路由规则也比较简单，它会把消息路由到那些binding key与routing key完全匹配的Queue中。</p><p><img src="/images/mq_direct.png" alt="image"></p><p>以上图为例，假设我们在生产者配置的routingKey为error，那么两个消费者都可以收到消息，如果是info，那么c2可以接收到消息，c2便接收不到消息了。</p><p><strong>生产者代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 生产者</span></span><br><span class="line"><span class="comment"> * Exchange Types为direct</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * direct类型的Exchange路由规则也很简单，它会把消息路由到那些binding key与routing key完全匹配的Queue中。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mingshan</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String EXCHANGE_NAME = <span class="string">"logs-direct"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        factory.setHost(<span class="string">"localhost"</span>);</span><br><span class="line">        Connection connection = factory.newConnection();</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">// 声明exchange，Exchange Types为direct</span></span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT);</span><br><span class="line">        System.out.println(<span class="string">"Please enter message ---&gt;"</span>);</span><br><span class="line">        String message = <span class="string">""</span>;</span><br><span class="line">        String routeKey = <span class="string">"error"</span>;</span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (scanner.hasNext()) &#123;</span><br><span class="line">            message = scanner.nextLine();</span><br><span class="line">            System.out.println(<span class="string">" ----- "</span> + message);</span><br><span class="line">            channel.basicPublish(EXCHANGE_NAME, routeKey, <span class="keyword">null</span>, message.getBytes(<span class="string">"UTF-8"</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">        scanner.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时生产者Exchange Tyoes设置为direct，并且routingKey设置的为error</p><p><strong>消费者代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 消费者</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mingshan</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerA</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String EXCHANGE_NAME = <span class="string">"logs-direct"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        factory.setHost(<span class="string">"localhost"</span>);</span><br><span class="line">        Connection connection = factory.newConnection();</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT);</span><br><span class="line"></span><br><span class="line">        String queueName = channel.queueDeclare().getQueue();</span><br><span class="line">        <span class="comment">// 此时routeKey 为 info</span></span><br><span class="line">        String routeKey = <span class="string">"info"</span>;</span><br><span class="line">        channel.queueBind(queueName, EXCHANGE_NAME, routeKey);</span><br><span class="line">        System.out.println(<span class="string">"A Waiting for messages. To exit press CTRL+C"</span>);</span><br><span class="line"></span><br><span class="line">        Consumer consumer = <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, BasicProperties properties, <span class="keyword">byte</span>[] body)</span></span></span><br><span class="line"><span class="function">                    <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                String message = <span class="keyword">new</span> String(body, <span class="string">"UTF-8"</span>);</span><br><span class="line">                System.out.println(<span class="string">"A Recv '"</span> + message + <span class="string">"'"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        channel.basicConsume(queueName, <span class="keyword">true</span>, consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在消费者中，我们设置的routeKey为info，此时消费者A接受不到消息了，如果routingKey为error，那么就可以接收到消息。</p><h3 id="topic"><a href="#topic" class="headerlink" title="topic"></a>topic</h3><p>由于direct的匹配规则需要完全配置，没有灵活性，所以topic就弥补了这一缺点，  routingKey 必须是由点分隔的单词列表。这些单词可以是任何东西，但通常它们指定连接到消息的一些功能。一些有效的路由键例子：“ stock.usd.nyse ”，“ nyse.vmw ”，“ quick.orange.rabbit ”。在路由选择键中可以有任意数量的字，最多255个字节。</p><p>绑定键也必须是相同的形式。binding key中可以存在两种特殊字符“*”与“#”，用于做模糊匹配：</p><ul><li>“*” 可以代替一个字。</li><li>“#” 可以代替零个或多个单词。</li></ul><p><img src="/images/mq_topic.png" alt="image"></p><p><strong>生产者代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 生产者</span></span><br><span class="line"><span class="comment"> * Exchange Types为topic</span></span><br><span class="line"><span class="comment"> * &lt;ul&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;routing key为一个句点号“. ”分隔的字符串（我们将被句点号“. ”分隔开的每一段独立的字符串称为一个单词），</span></span><br><span class="line"><span class="comment"> *     如“stock.usd.nyse”、“nyse.vmw”、“quick.orange.rabbit”&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;binding key与routing key一样也是句点号“. ”分隔的字符串&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *   &lt;li&gt;binding key中可以存在两种特殊字符“*”与“#”，用于做模糊匹配，其中“*”用于匹配一个单词，“#”用于匹配多个单词（可以是零个）&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mingshan</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String EXCHANGE_NAME = <span class="string">"logs-topic"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        factory.setHost(<span class="string">"localhost"</span>);</span><br><span class="line">        Connection connection = factory.newConnection();</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">// 声明exchange，Exchange Types为headers</span></span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.TOPIC);</span><br><span class="line">        System.out.println(<span class="string">"Please enter message ---&gt;"</span>);</span><br><span class="line">        String message = <span class="string">""</span>;</span><br><span class="line">        String routeKey = <span class="string">"quick.orange.rabbit"</span>;</span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (scanner.hasNext()) &#123;</span><br><span class="line">            message = scanner.nextLine();</span><br><span class="line">            System.out.println(<span class="string">" ----- "</span> + message);</span><br><span class="line">            channel.basicPublish(EXCHANGE_NAME, routeKey, <span class="keyword">null</span>, message.getBytes(<span class="string">"UTF-8"</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">        scanner.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>消费者代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 消费者</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mingshan</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerA</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String EXCHANGE_NAME = <span class="string">"logs-topic"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        factory.setHost(<span class="string">"localhost"</span>);</span><br><span class="line">        Connection connection = factory.newConnection();</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.TOPIC);</span><br><span class="line"></span><br><span class="line">        String queueName = channel.queueDeclare().getQueue();</span><br><span class="line">        <span class="comment">// 此时routeKey 为 *.orange.*</span></span><br><span class="line">        String routeKey = <span class="string">"*.orange.*"</span>;</span><br><span class="line">        channel.queueBind(queueName, EXCHANGE_NAME, routeKey);</span><br><span class="line">        System.out.println(<span class="string">"A Waiting for messages. To exit press CTRL+C"</span>);</span><br><span class="line"></span><br><span class="line">        Consumer consumer = <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, BasicProperties properties, <span class="keyword">byte</span>[] body)</span></span></span><br><span class="line"><span class="function">                    <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                String message = <span class="keyword">new</span> String(body, <span class="string">"UTF-8"</span>);</span><br><span class="line">                System.out.println(<span class="string">"A Recv '"</span> + message + <span class="string">"'"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        channel.basicConsume(queueName, <span class="keyword">true</span>, consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="headers"><a href="#headers" class="headerlink" title="headers"></a>headers</h3><p>headers类型的Exchange不依赖于routing key与binding key的匹配规则来路由消息，而是根据发送的消息内容中的headers属性进行匹配。<br>在绑定Queue与Exchange时指定一组键值对；当消息发送到Exchange时，RabbitMQ会取到该消息的headers（也是一个键值对的形式），消费者会根据设置x-match设置的配置类型(all,any)来进行匹配。</p><p><strong>生产者代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 生产者</span></span><br><span class="line"><span class="comment"> * Exchange Types为headers</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Headers是一个键值对，可以定义成HashMap。发送者在发送的时候定义一些键值对，接收者也可以再绑定时候传入一些键值对，</span></span><br><span class="line"><span class="comment"> * 两者匹配的话，则对应的队列就可以收到消息。匹配有两种方式all和any。这两种方式是在接收端必须要用键值"x-mactch"来定义</span></span><br><span class="line"><span class="comment"> * 。all代表定义的多个键值对都要满足，而any则代码只要满足一个就可以了。fanout，direct，topic exchange的routingKey都需要要字符串形式的，</span></span><br><span class="line"><span class="comment"> * 而headers exchange则没有这个要求，因为键值对的值可以是任何类型。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mingshan</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String EXCHANGE_NAME = <span class="string">"logs-headers"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        factory.setHost(<span class="string">"localhost"</span>);</span><br><span class="line">        Connection connection = factory.newConnection();</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">// 声明exchange，Exchange Types为headers</span></span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.HEADERS);</span><br><span class="line"></span><br><span class="line">        Map&lt;String,Object&gt; headers =  <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</span><br><span class="line">        headers.put(<span class="string">"xiaoming"</span>, <span class="string">"123456"</span>);</span><br><span class="line">        AMQP.BasicProperties.Builder builder = <span class="keyword">new</span> AMQP.BasicProperties.Builder();</span><br><span class="line">        builder.deliveryMode(MessageProperties.PERSISTENT_TEXT_PLAIN.getDeliveryMode());</span><br><span class="line">        builder.priority(MessageProperties.PERSISTENT_TEXT_PLAIN.getPriority());</span><br><span class="line">        builder.headers(headers);</span><br><span class="line">        AMQP.BasicProperties theProps = builder.build();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"Please enter message ---&gt;"</span>);</span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        String message = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (scanner.hasNext()) &#123;</span><br><span class="line">            message = scanner.nextLine();</span><br><span class="line">            channel.basicPublish(EXCHANGE_NAME, <span class="string">""</span>, theProps, message.getBytes(<span class="string">"UTF-8"</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">        scanner.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>消费者代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 消费者</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mingshan</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerA</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String EXCHANGE_NAME = <span class="string">"logs-headers"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        factory.setHost(<span class="string">"localhost"</span>);</span><br><span class="line">        Connection connection = factory.newConnection();</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.HEADERS);</span><br><span class="line"></span><br><span class="line">        String queueName = channel.queueDeclare().getQueue();</span><br><span class="line"></span><br><span class="line">        Map&lt;String, Object&gt; headers = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</span><br><span class="line">        headers.put(<span class="string">"x-match"</span>, <span class="string">"any"</span>);<span class="comment">//all any  </span></span><br><span class="line">        headers.put(<span class="string">"xiaoming"</span>, <span class="string">"123456"</span>);</span><br><span class="line">        headers.put(<span class="string">"bbb"</span>, <span class="string">"56789"</span>);</span><br><span class="line">        channel.queueBind(queueName, EXCHANGE_NAME, <span class="string">""</span>, headers);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"A Waiting for messages. To exit press CTRL+C"</span>);</span><br><span class="line">        Consumer consumer = <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, BasicProperties properties, <span class="keyword">byte</span>[] body)</span></span></span><br><span class="line"><span class="function">                    <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                String message = <span class="keyword">new</span> String(body, <span class="string">"UTF-8"</span>);</span><br><span class="line">                System.out.println(<span class="string">"A Recv '"</span> + message + <span class="string">"'"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        channel.basicConsume(queueName, <span class="keyword">true</span>, consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="源码链接"><a href="#源码链接" class="headerlink" title="源码链接"></a>源码链接</h2><p>你可以在这个地方看到本篇博客代码：</p><p><a href="https://github.com/mstao/rabbitmq-learning" target="_blank" rel="noopener">https://github.com/mstao/rabbitmq-learning</a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="http://www.rabbitmq.com/getstarted.html" target="_blank" rel="noopener">http://www.rabbitmq.com/getstarted.html</a></li><li><a href="http://www.rabbitmq.com/tutorials/amqp-concepts.html" target="_blank" rel="noopener">http://www.rabbitmq.com/tutorials/amqp-concepts.html</a></li><li><a href="http://blog.csdn.net/whycold/article/details/41119807" target="_blank" rel="noopener">http://blog.csdn.net/whycold/article/details/41119807</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> RabbitMQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> RabbitMQ </tag>
            
            <tag> Exchange Types </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ReentrantLock源码笔记 - 释放锁（JDK 1.8）</title>
      <link href="/2017/11/12/ReentrantLock%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B0%20-%20%E9%87%8A%E6%94%BE%E9%94%81/"/>
      <url>/2017/11/12/ReentrantLock%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B0%20-%20%E9%87%8A%E6%94%BE%E9%94%81/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="ReentrantLock源码学习-释放锁（unlock）"><a href="#ReentrantLock源码学习-释放锁（unlock）" class="headerlink" title="ReentrantLock源码学习 - 释放锁（unlock）"></a>ReentrantLock源码学习 - 释放锁（unlock）</h2><hr><p>上次谈到了利用ReentrantLock的非公平和公平加锁方式，那么接下来看看释放锁的流程</p><p>首先调用ReentrantLock的unlock方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.release(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后会调用AbstractQueuedSynchronizer（AQS）的release方法，在这个方法中首先会调用ReentrantLock的Sync的tryRelease方法，来进行尝试释放锁，如果返回true，那么获取CLH队列的头结点，判断头结点不为空并且头结点的状态不为0（None），那么就调用AQS的unparkSuccessor方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在tryRelease方法里，首先让当前的state与传入的值（这里为1）进行相减，然后得到c，判断当前线程是不是获取独占锁的线程，如果不是，直接抛出异常；如果是，那么需要判断c是否为0，因为只有c为0时，才符合释放独占锁的条件，这是设置独占锁线程为null，最后设置下state的值（注意这里c为0不为0都会设置）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c = getState() - releases;</span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        free = <span class="keyword">true</span>;</span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    setState(c);</span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来来看方法unparkSuccessor，该方法的作用就是为了释放node节点的后继结点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * If status is negative (i.e., possibly needing signal) try</span></span><br><span class="line"><span class="comment">     * to clear in anticipation of signalling.  It is OK if this</span></span><br><span class="line"><span class="comment">     * fails or if status is changed by waiting thread.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     <span class="comment">// 获取节点的状态</span></span><br><span class="line">    <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>); <span class="comment">// 利用CAS 将状态设置为0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Thread to unpark is held in successor, which is normally</span></span><br><span class="line"><span class="comment">     * just the next node.  But if cancelled or apparently null,</span></span><br><span class="line"><span class="comment">     * traverse backwards from tail to find the actual</span></span><br><span class="line"><span class="comment">     * non-cancelled successor.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 获取节点的后继节点</span></span><br><span class="line">    Node s = node.next;</span><br><span class="line">    <span class="comment">// 判断后继节点是否为空 或者 后者后继节点的状态为CANCELLED</span></span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        s = <span class="keyword">null</span>; <span class="comment">// 将后继节点置为null</span></span><br><span class="line">        <span class="comment">// 从尾节点从后向前开始遍历知道节点为空或者当前节点为止</span></span><br><span class="line">        <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>) <span class="comment">// 如果此时节点的状态小于等于0</span></span><br><span class="line">                s = t; <span class="comment">// 将此节点赋给传入节点的后继节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>)  <span class="comment">// 节点不为空，释放</span></span><br><span class="line">        LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h3><p><a href="http://blog.csdn.net/luonanqin/article/details/41871909" target="_blank" rel="noopener">http://blog.csdn.net/luonanqin/article/details/41871909</a></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> JUC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> Lock </tag>
            
            <tag> JUC </tag>
            
            <tag> ReentrantLock </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>在 Spring Data Redis中使用AOP进行数据缓存</title>
      <link href="/2017/11/11/%E5%9C%A8%20Spring%20Data%20Redis%E4%B8%AD%E4%BD%BF%E7%94%A8AOP%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E7%BC%93%E5%AD%98/"/>
      <url>/2017/11/11/%E5%9C%A8%20Spring%20Data%20Redis%E4%B8%AD%E4%BD%BF%E7%94%A8AOP%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E7%BC%93%E5%AD%98/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="为什么要对数据进行缓存"><a href="#为什么要对数据进行缓存" class="headerlink" title="为什么要对数据进行缓存"></a>为什么要对数据进行缓存</h2><p>当我们将数据从数据库中取出来后，如果我们需要再一次进行同样的操作，获取相同的数据，那么再次查询数据库无疑不是很好的方式，这时我们可以考虑来将我们的数据缓存起来，当再次获取相同的数据时，直接从缓存拿就行了。</p><h2 id="进行缓存需要考虑什么问题"><a href="#进行缓存需要考虑什么问题" class="headerlink" title="进行缓存需要考虑什么问题"></a>进行缓存需要考虑什么问题</h2><ol><li>缓存数据存在什么地方？</li><li>怎样识别相同的操作(判断两次取的数据相同，生成唯一标识)</li><li>数据更新时缓存该如何处理？</li><li>缓存数据是否设置过期时间？</li><li>如何序列化查询结果？查询结果可能是单个实体对象，也可能是一个List。</li><li>代码该写在哪？不能对原有代码有侵入性</li></ol><p>针对以上问题，我们下面来慢慢分析解决。</p><h2 id="采用Redis缓存数据"><a href="#采用Redis缓存数据" class="headerlink" title="采用Redis缓存数据"></a>采用Redis缓存数据</h2><p>Redis是一个开源（BSD许可），内存存储的数据结构服务器，可用作数据库，高速缓存和消息队列代理。它支持字符串、哈希表、列表、集合、有序集合，位图，hyperloglogs等数据类型。内置复制、Lua脚本、LRU收回、事务以及不同级别磁盘持久化功能，同时通过Redis Sentinel提供高可用，通过Redis Cluster提供自动分区。</p><p>我们在 Spring 中使用 Redis 是通过 Spring Data Redis 提供的 RedisTemplate 来操作Redis</p><p><strong>添加依赖</strong><br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.data<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.4.1.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>spring集合Redis的配置如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- redis 相关配置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"poolConfig"</span> <span class="attr">class</span>=<span class="string">"redis.clients.jedis.JedisPoolConfig"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxIdle"</span> <span class="attr">value</span>=<span class="string">"$&#123;redis.maxIdle&#125;"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxWaitMillis"</span> <span class="attr">value</span>=<span class="string">"$&#123;redis.maxWait&#125;"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"testOnBorrow"</span> <span class="attr">value</span>=<span class="string">"true"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"jedisConnectionFactory"</span> <span class="attr">class</span>=<span class="string">"org.springframework.data.redis.connection.jedis.JedisConnectionFactory"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">p:host-name</span>=<span class="string">"$&#123;redis.host&#125;"</span> <span class="attr">p:port</span>=<span class="string">"$&#123;redis.port&#125;"</span> <span class="attr">p:pool-config-ref</span>=<span class="string">"poolConfig"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- redis template definition --&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"redisTemplate"</span> <span class="attr">class</span>=<span class="string">"org.springframework.data.redis.core.RedisTemplate"</span>&gt;</span>  </span><br><span class="line">    <span class="comment">&lt;!-- 设置 Redis 连接工厂--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"connectionFactory"</span> <span class="attr">ref</span>=<span class="string">"jedisConnectionFactory"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 设置默认 Serializer ，包含 keySerializer &amp; valueSerializer --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"defaultSerializer"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"com.alibaba.fastjson.support.spring.GenericFastJsonRedisSerializer"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 单独设置 keySerializer --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"keySerializer"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"com.alibaba.fastjson.support.spring.GenericFastJsonRedisSerializer"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 单独设置 valueSerializer --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"valueSerializer"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"com.alibaba.fastjson.support.spring.GenericFastJsonRedisSerializer"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="为查询生成唯一标识"><a href="#为查询生成唯一标识" class="headerlink" title="为查询生成唯一标识"></a>为查询生成唯一标识</h2><p>由于Redis是以key-value形式存储数据，所以我们要考虑该如何对查询生成唯一的标识呢？首先我们可以想到可以根据sql语句来作为key，但ORM框架我用的是MyBatis，这就不是一个好的方式。其实如果两次查询调用的类名、方法名和参数值相同，我们就可以确定这两次查询结果一定是相同的（在数据没有变动的前提下）。因此，我们可以将这三个元素组合成一个字符串做为key, 就解决了标识问题。<br>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 生成缓存需要的key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> clazzName</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 生成的key</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">generateKey</span><span class="params">(String clazzName, String methodName, Object[] args)</span> </span>&#123;</span><br><span class="line">    StringBuffer sb = <span class="keyword">new</span> StringBuffer(clazzName);</span><br><span class="line">    sb.append(Constants.ELIMITER);</span><br><span class="line">    sb.append(methodName);</span><br><span class="line">    sb.append(Constants.ELIMITER);</span><br><span class="line">    <span class="keyword">if</span> (args != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Object arg : args) &#123;</span><br><span class="line">            sb.append(arg);</span><br><span class="line">            sb.append(Constants.ELIMITER);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 去除最后一个分隔符</span></span><br><span class="line">    sb.replace(sb.length() - <span class="number">1</span>, sb.length(), Constants.ELIMITER);</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="代码该写在什么地方"><a href="#代码该写在什么地方" class="headerlink" title="代码该写在什么地方"></a>代码该写在什么地方</h2><p>由于考虑到不能对原有代码有侵入性，所以我们就要用到AOP了。我们可以把从数据库查询出来的数据映射到实体类，然后将其序列化为json，从缓存中取出来后再进行反序列化，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 序列化数据</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> source</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> json字符串</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">serialize</span><span class="params">(Object source)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> JSON.toJSONString(source);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 反序列化</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> source</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> clazz</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> modelType</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 反序列化的数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">deserialize</span><span class="params">(String source, Class&lt;?&gt; clazz, Class&lt;?&gt; modelType)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 判断是否为List</span></span><br><span class="line">    <span class="keyword">if</span> (List.class.isAssignableFrom(clazz)) &#123;</span><br><span class="line">        <span class="keyword">return</span> JSON.parseArray(source, modelType);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 正常反序列化</span></span><br><span class="line">    <span class="keyword">return</span> JSON.parseObject(source, clazz);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><p>因为我们要拦截的是Mapper接口方法，因此必须命令spring使用JDK的动态代理而不是cglib的代理。为此，我们需要做以下配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 当proxy-target-class为false时使用JDK动态代理 --&gt;</span><br><span class="line">&lt;!-- 为true时使用cglib --&gt;</span><br><span class="line">&lt;!-- cglib无法拦截接口方法 --&gt;</span><br><span class="line">&lt;aop:aspectj-autoproxy proxy-target-class=&quot;false&quot; /&gt;</span><br></pre></td></tr></table></figure></p><p>然后我们定义两个方法级别的自定义注解，其中RedisCache代表该方法需要进行缓存数据，<br>RedisEvict代表需要清除缓存<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> RedisCache &#123;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"rawtypes"</span>)</span><br><span class="line">    <span class="function">Class <span class="title">type</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">expire</span><span class="params">()</span> <span class="keyword">default</span> -1</span>;      <span class="comment">//缓存多少秒,默认无限期  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> RedisEvict &#123;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"rawtypes"</span>)</span><br><span class="line">    <span class="function">Class <span class="title">type</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注解使用方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@RedisCache</span>(type = User.class)</span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">selectByPrimaryKey</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> userDao.selectByPrimaryKey(id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@RedisEvict</span>(type = User.class)</span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">deleteByPrimaryKey</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">    userDao.deleteByPrimaryKey(id);</span><br><span class="line">    User user = <span class="keyword">new</span> User();</span><br><span class="line">    user.setId(id);</span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先对于要进行数据缓存操作，我们先要生成唯一标识key值，然后去Redis查询，判断缓存是否命中</p><ul><li>如果缓存命中，那么将数据反序列化，将其返回</li><li>如果缓存未命中，那么去数据库查询数据，然后将数据进行序列化，这是需要判断是否设置了超时时间，如果没有设置，那么默认无限期，如果设置了，那么对数据设置时间。</li></ul><p>具体AOP代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisCacheAspect</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(RedisCacheAspect.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate&lt;String, String&gt; redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从Redis获取缓存的数据或者将数据缓存到Redis</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pjp</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 获取到的数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Around</span>(<span class="string">"execution(* com.han.service..*Impl.select*(..))"</span> +</span><br><span class="line">            <span class="string">"|| execution(* com.han.service..*Impl.get*(..))"</span> +</span><br><span class="line">            <span class="string">"|| execution(* com.han.service..*Impl.find*(..))"</span> +</span><br><span class="line">            <span class="string">"|| execution(* com.han.service..*Impl.search*(..))"</span>)</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(&#123; <span class="string">"unchecked"</span>, <span class="string">"rawtypes"</span> &#125;)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">cache</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">// 生成key</span></span><br><span class="line">        String key = getKey(pjp);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (logger.isDebugEnabled())&#123;</span><br><span class="line">            logger.debug(<span class="string">"已生成key = &#123;&#125;"</span> + key);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 得到目标方法</span></span><br><span class="line">        Method targetMethod = getTargetMethod(pjp);</span><br><span class="line">        <span class="comment">// 得到被代理的方法上的注解</span></span><br><span class="line">        Class&lt;?&gt; modelType = targetMethod.getAnnotation(RedisCache.class).type();</span><br><span class="line">        String hashName = modelType.getName();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 利用Redis的Hash数据类型（散列）</span></span><br><span class="line">        HashOperations opsForHash = redisTemplate.opsForHash();</span><br><span class="line">        <span class="comment">// 检查redis中是否有缓存</span></span><br><span class="line">        String value = (String) opsForHash.get(hashName, key);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 最终返回结果</span></span><br><span class="line">        Object result = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 判断缓存是否命中</span></span><br><span class="line">        <span class="keyword">if</span> (value != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 缓存命中</span></span><br><span class="line">            <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                logger.debug(<span class="string">"缓存命中, value = &#123;&#125;"</span>, value);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 得到被代理方法的返回值类型</span></span><br><span class="line">            Class&lt;?&gt; returnType = ((MethodSignature) pjp.getSignature()).getReturnType();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 反序列化从缓存中拿到的json</span></span><br><span class="line">            result = deserialize(value, returnType, modelType);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                logger.debug(<span class="string">"反序列化结果 = &#123;&#125;"</span>, result);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 缓存未命中</span></span><br><span class="line">            <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                logger.debug(<span class="string">"缓存未命中"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 跳过缓存,到后端查询数据</span></span><br><span class="line">            result = pjp.proceed(pjp.getArgs());</span><br><span class="line">            <span class="comment">// 序列化查询结果</span></span><br><span class="line">            String jsonStr = serialize(result);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取设置的缓存时间</span></span><br><span class="line">            <span class="keyword">int</span> timeout = targetMethod.getAnnotation(RedisCache.class).expire();</span><br><span class="line">            <span class="comment">// 如果没有设置过期时间,则无限期缓存(默认-1)</span></span><br><span class="line">            <span class="keyword">if</span> (timeout &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                opsForHash.put(hashName, key, jsonStr);  </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">final</span> TimeUnit unit = TimeUnit.SECONDS;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">long</span> rawTimeout = TimeoutUtils.toMillis(timeout, unit);</span><br><span class="line">                <span class="comment">// 设置缓存时间  </span></span><br><span class="line">                redisTemplate.execute(<span class="keyword">new</span> RedisCallback&lt;Object&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Object <span class="title">doInRedis</span><span class="params">(RedisConnection redisConn)</span> <span class="keyword">throws</span> DataAccessException </span>&#123;</span><br><span class="line">                        <span class="comment">// 配置文件中指定了这是一个String类型的连接</span></span><br><span class="line">                        <span class="comment">// 所以这里向下强制转换一定是安全的</span></span><br><span class="line">                        StringRedisConnection conn = (StringRedisConnection) redisConn;</span><br><span class="line">                        <span class="comment">// 判断hash名是否存在</span></span><br><span class="line">                        <span class="comment">// 如果不存在，创建该hash并设置过期时间</span></span><br><span class="line">                        <span class="keyword">if</span> (!conn.exists(hashName)) &#123;</span><br><span class="line">                            conn.hSet(hashName, key, jsonStr);</span><br><span class="line">                            conn.expire(hashName, rawTimeout);</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            conn.hSet(hashName, key, jsonStr);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在方法调用前清除缓存，然后调用业务方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> jp</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 获取到的数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Around</span>(<span class="string">"execution(* com.han.service..*Impl.delete*(..))"</span> +</span><br><span class="line">            <span class="string">"|| execution(* com.han.service..*Impl.remove*(..))"</span>)</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"rawtypes"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">evictCache</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">// 得到目标的方法</span></span><br><span class="line">        Method targetMethod = getTargetMethod(pjp);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 得到被代理的方法上的注解</span></span><br><span class="line">        Class modelType = targetMethod.getAnnotation(RedisEvict.class).type();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">            logger.debug(<span class="string">"清空缓存:&#123;&#125;"</span>, modelType.getName());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 清除对应缓存</span></span><br><span class="line">        redisTemplate.delete(modelType.getName());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> pjp.proceed(pjp.getArgs());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 更新缓存的数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 新获取的数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Around</span>(<span class="string">"execution(* com.han.service..*Impl.update*(..))"</span> +</span><br><span class="line">            <span class="string">"|| execution(* com.han.service..*Impl.insert*(..))"</span> +</span><br><span class="line">            <span class="string">"|| execution(* com.han.service..*Impl.save*(..))"</span>)</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(&#123; <span class="string">"unchecked"</span>, <span class="string">"rawtypes"</span> &#125;)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">updateCache</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">// 生成key</span></span><br><span class="line">        String key = getKey(pjp);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (logger.isDebugEnabled())&#123;</span><br><span class="line">            logger.debug(<span class="string">"已生成key = &#123;&#125;"</span> + key);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 得到目标方法</span></span><br><span class="line">        Method targetMethod = getTargetMethod(pjp);</span><br><span class="line">        <span class="comment">// 得到被代理的方法上的注解</span></span><br><span class="line">        Class&lt;?&gt; modelType = targetMethod.getAnnotation(RedisCache.class).type();</span><br><span class="line">        String hashName = modelType.getName();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 利用Redis的Hash数据类型（散列）</span></span><br><span class="line">        HashOperations opsForHash = redisTemplate.opsForHash();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 跳过缓存,到后端查询数据</span></span><br><span class="line">        Object result = pjp.proceed(pjp.getArgs());</span><br><span class="line">        <span class="comment">// 序列化查询结果</span></span><br><span class="line">        String jsonStr = serialize(result);</span><br><span class="line">        <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">            logger.debug(<span class="string">"序列化结果 = &#123;&#125;"</span>, result);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取设置的缓存时间</span></span><br><span class="line">        <span class="keyword">int</span> timeout = targetMethod.getAnnotation(RedisCache.class).expire();</span><br><span class="line">        <span class="comment">// 如果没有设置过期时间,则无限期缓存(默认-1)</span></span><br><span class="line">        <span class="keyword">if</span> (timeout &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            opsForHash.put(hashName, key, jsonStr);  </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> TimeUnit unit = TimeUnit.SECONDS;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> rawTimeout = TimeoutUtils.toMillis(timeout, unit);</span><br><span class="line">            <span class="comment">// 设置缓存时间  </span></span><br><span class="line">            redisTemplate.execute(<span class="keyword">new</span> RedisCallback&lt;Object&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> Object <span class="title">doInRedis</span><span class="params">(RedisConnection redisConn)</span> <span class="keyword">throws</span> DataAccessException </span>&#123;</span><br><span class="line">                    <span class="comment">// 配置文件中指定了这是一个String类型的连接</span></span><br><span class="line">                    <span class="comment">// 所以这里向下强制转换一定是安全的</span></span><br><span class="line">                    StringRedisConnection conn = (StringRedisConnection) redisConn;</span><br><span class="line">                    <span class="comment">// 判断hash名是否存在</span></span><br><span class="line">                    <span class="comment">// 如果不存在，创建该hash并设置过期时间</span></span><br><span class="line">                    <span class="keyword">if</span> (!conn.exists(hashName)) &#123;</span><br><span class="line">                        conn.hSet(hashName, key, jsonStr);</span><br><span class="line">                        conn.expire(hashName, rawTimeout);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        conn.hSet(hashName, key, jsonStr);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 得到目标方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pjp</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 目标方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> SecurityException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NoSuchMethodException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Method <span class="title">getTargetMethod</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> NoSuchMethodException,</span></span><br><span class="line"><span class="function">                                            SecurityException </span>&#123;</span><br><span class="line">        Signature sig = pjp.getSignature();</span><br><span class="line">        <span class="keyword">if</span> (!(sig <span class="keyword">instanceof</span> MethodSignature)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"该注解只能用于方法"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        MethodSignature msig = (MethodSignature) sig;</span><br><span class="line">        Object target = pjp.getTarget();</span><br><span class="line">        Method targetMethod = target.getClass().getMethod(msig.getName(), msig.getParameterTypes());</span><br><span class="line">        <span class="keyword">return</span> targetMethod;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过类名，方法名和参数来获取对应的key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pjp</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 生成的key</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">getKey</span><span class="params">(ProceedingJoinPoint pjp)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取类名</span></span><br><span class="line">        String clazzName = pjp.getTarget().getClass().getName();</span><br><span class="line">        <span class="comment">// 获取方法名</span></span><br><span class="line">        String methodName = pjp.getSignature().getName();</span><br><span class="line">        <span class="comment">// 方法参数</span></span><br><span class="line">        Object[] args = pjp.getArgs();</span><br><span class="line">        <span class="comment">// 生成key</span></span><br><span class="line">        <span class="keyword">return</span> generateKey(clazzName, methodName, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成缓存需要的key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> clazzName</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 生成的key</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">generateKey</span><span class="params">(String clazzName, String methodName, Object[] args)</span> </span>&#123;</span><br><span class="line">        StringBuffer sb = <span class="keyword">new</span> StringBuffer(clazzName);</span><br><span class="line">        sb.append(Constants.ELIMITER);</span><br><span class="line">        sb.append(methodName);</span><br><span class="line">        sb.append(Constants.ELIMITER);</span><br><span class="line">        <span class="keyword">if</span> (args != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Object arg : args) &#123;</span><br><span class="line">                sb.append(arg);</span><br><span class="line">                sb.append(Constants.ELIMITER);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 去除最后一个分隔符</span></span><br><span class="line">        sb.replace(sb.length() - <span class="number">1</span>, sb.length(), Constants.ELIMITER);</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 序列化数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> source</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> json字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">serialize</span><span class="params">(Object source)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> JSON.toJSONString(source);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 反序列化</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> source</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> clazz</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> modelType</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 反序列化的数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Object <span class="title">deserialize</span><span class="params">(String source, Class&lt;?&gt; clazz, Class&lt;?&gt; modelType)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 判断是否为List</span></span><br><span class="line">        <span class="keyword">if</span> (clazz.isAssignableFrom(List.class)) &#123;</span><br><span class="line">            <span class="keyword">return</span> JSON.parseArray(source, modelType);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 正常反序列化</span></span><br><span class="line">        <span class="keyword">return</span> JSON.parseObject(source, clazz);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> Spring Data </tag>
            
            <tag> AOP </tag>
            
            <tag> 缓存 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ReentrantLock源码笔记 - 获取锁（JDK 1.8）</title>
      <link href="/2017/11/10/ReentrantLock%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B0%20-%20%E8%8E%B7%E5%8F%96%E9%94%81/"/>
      <url>/2017/11/10/ReentrantLock%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B0%20-%20%E8%8E%B7%E5%8F%96%E9%94%81/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="ReentrantLock-学习-获取锁（JDK-1-8）"><a href="#ReentrantLock-学习-获取锁（JDK-1-8）" class="headerlink" title="ReentrantLock 学习 - 获取锁（JDK 1.8）"></a>ReentrantLock 学习 - 获取锁（JDK 1.8）</h2><hr><p>ReentrantLock 提供非公平锁与公平锁两种加锁方式, 默认加锁方式为非公平锁。</p><h3 id="ReentrantLock类的结构为："><a href="#ReentrantLock类的结构为：" class="headerlink" title="ReentrantLock类的结构为："></a>ReentrantLock类的结构为：<br></h3><p><img src="/images/ReentrantLock.png" alt="image"></p><p>从图中可以看出，ReentrantLock类包含三个静态内部类：</p><ul><li>Sync</li><li>NonfairSync</li><li>FairSync</li></ul><p>其中Sync类继承AbstractQueuedSynchronize（AQS), NonfairSync和FairSync继承Sync。</p><h3 id="ReentrantLock的基本用法："><a href="#ReentrantLock的基本用法：" class="headerlink" title="ReentrantLock的基本用法："></a>ReentrantLock的基本用法：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      lock.lock();  <span class="comment">// block until condition holds</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// ... method body</span></span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="ReentrantLock的创建"><a href="#ReentrantLock的创建" class="headerlink" title="ReentrantLock的创建"></a>ReentrantLock的创建</h3><ul><li>非公平锁</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br></pre></td></tr></table></figure><ul><li>公平锁</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Lock lock = <span class="keyword">new</span> ReentrantLock(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure><p>由于默认创建的为非公平锁，所以想创建公平锁，就需要向其构造方法传入true。</p><ol><li>创建非公平锁的构造方法为：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates an instance of &#123;<span class="doctag">@code</span> ReentrantLock&#125;.</span></span><br><span class="line"><span class="comment"> * This is equivalent to using &#123;<span class="doctag">@code</span> ReentrantLock(false)&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync = <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>创建公平锁的构造方法为：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据传入的布尔值来判断创建哪种锁</span></span><br><span class="line"><span class="comment"> * Creates an instance of &#123;<span class="doctag">@code</span> ReentrantLock&#125; with the</span></span><br><span class="line"><span class="comment"> * given fairness policy.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> fair &#123;<span class="doctag">@code</span> true&#125; if this lock should use a fair ordering policy</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="非公平锁"><a href="#非公平锁" class="headerlink" title="非公平锁"></a>非公平锁</h3><h4 id="非公平锁的用法"><a href="#非公平锁的用法" class="headerlink" title="非公平锁的用法"></a>非公平锁的用法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lock.lock();</span><br></pre></td></tr></table></figure><p>在ReetrantLock类的内部提供了一个加锁的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.lock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个方法里又调用了==sync==的==lock==方法，又因为Sync这个类为一个抽象类，在ReentrantLock类实例化的时候，根据参数来判断调用哪个具体的类。</p><p>这里先谈谈非公平锁的加锁实现。</p><h4 id="非公平锁实现简单步骤："><a href="#非公平锁实现简单步骤：" class="headerlink" title="非公平锁实现简单步骤："></a><strong>非公平锁实现简单步骤</strong>：</h4><p> 基予CAS(Compare And Swap)将state由0设置为1。<br></p><ul><li>如果设置成功，那么直接获得锁，并设置独占锁的线程为当前线程。<br></li><li>如果设置失败，原先内存state的值不是0，已经有其他线程获得锁，那么就会再获取一次state。<br><ol><li>如果state为0， 那么就会再次利用CAS将state的值由0设置为1，如果成功，设置独占锁的线程为当前线。<br></li><li>如果state不为0，那么需要判断当前线程是否是独占锁的线程，如果是，那么就将state加1， 并且判断当前state的值不能小于0；如果不是，那么就将该线程封装在一个Node(AQS里面)里,并加入到等待列队里，等其他线程唤醒。</li></ol></li></ul><a id="more"></a><h4 id="具体流程如下："><a href="#具体流程如下：" class="headerlink" title="具体流程如下："></a>具体流程如下：</h4><p>首先通过ReentrantLock的lock方法调用到其内部类NonFairLock的lock方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">        setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在lock方法中，先调用compareAndSetState方法来将state由0设置为1，如果设置成功，设置当前线程为独占锁线程，如果失败，则调用AbstractQueuedSynchronizer类的acquire(1)方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>向aquire方法传入参数1，此方法是线程获取临界资源的顶层入口， 如果获得到资源则直接返回，如果失败，则将当前先后才能放入到等待列队，直到获取到资源才返回。此过程忽略中断影响，模式为独占模式。</p><p>因为这个方法涉及到线程的入队操作，下面来看看AbstractQueuedSynchronizer类内部封装的Node.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 同步等待队列（双向链表）节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Node SHARED = <span class="keyword">new</span> Node();</span><br><span class="line">    <span class="comment">// 一个标记：用于表明该节点在独占模式下进行等待</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Node EXCLUSIVE = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线程被取消了</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED =  <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 节点等待触发</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIGNAL    = -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 节点等待条件</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CONDITION = -<span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 节点状态需要向后传播</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PROPAGATE = -<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> waitStatus;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 前驱节点</span></span><br><span class="line">    <span class="keyword">volatile</span> Node prev;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 后继节点</span></span><br><span class="line">    <span class="keyword">volatile</span> Node next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线程</span></span><br><span class="line">    <span class="keyword">volatile</span> Thread thread;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Node nextWaiter;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nextWaiter == SHARED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> Node <span class="title">predecessor</span><span class="params">()</span> <span class="keyword">throws</span> NullPointerException </span>&#123;</span><br><span class="line">        Node p = prev;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node() &#123;    <span class="comment">// Used to establish initial head or SHARED marker</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node(Thread thread, Node mode) &#123;     <span class="comment">// Used by addWaiter</span></span><br><span class="line">        <span class="keyword">this</span>.nextWaiter = mode;</span><br><span class="line">        <span class="keyword">this</span>.thread = thread;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node(Thread thread, <span class="keyword">int</span> waitStatus) &#123; <span class="comment">// Used by Condition</span></span><br><span class="line">        <span class="keyword">this</span>.waitStatus = waitStatus;</span><br><span class="line">        <span class="keyword">this</span>.thread = thread;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>tryAcquire方法会调用ReentrantLock中NonfairSync内部类中的tryAcquire方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后调用nonfairTryAcquire方法进行再一次尝试获取锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当前线程</span></span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="comment">// 再一次获取state</span></span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="comment">// 如果state为0，说明其他线程已经释放了锁，可以尝试获取锁</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 利用CAS来设置当前state的值</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            <span class="comment">// 如果成功则设置当前线程为独占锁线程，然后直接返回</span></span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">// 如果当前state不是0，则判断当前线程是否为独占锁线程</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="comment">// 将state进行+1操作，判断state值后返回</span></span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;  <span class="comment">// 获取锁失败，考虑将线程加入等待队列</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在nonfairTryAcquire方法为再一次尝试获取锁，这个过程可能获取锁的线程已经释放了锁，所以再一次判断state的值，如果state的值为0，那么利用CAS将state由0设值为1，如果成功，获取锁成功，设值当前线程为独占锁线程，直接返回；如果state不为0，则判断当前线程是否为独占锁线程（可重入锁来源，state每加一次1，那么就需要释放锁的次数也要+1，这样才能保证state最终在线程释放锁的情况下值为0），如果是，将state加1，然后返回；其他情况返回false，获取锁失败。</p><p>如果当前线程获取锁失败，就需要将该线程加入等待队列的末尾。<br>该等待列队是CLH队列，队列的示意图如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">     +------+  prev +-----+       +-----+</span><br><span class="line">head |      | &lt;---- |     | &lt;---- |     |  tail</span><br><span class="line">     +------+       +-----+       +-----+</span><br></pre></td></tr></table></figure><p>接下来就会调用AQS的addWaiter(Node.EXCLUSIVE)方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 根据当前线程创建一个Node节点，并设置为独占模式</span></span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">    <span class="comment">// 试图进行快速入队操作，仅尝试一次</span></span><br><span class="line">    <span class="comment">// 将队列的尾节点tail赋给pred</span></span><br><span class="line">    Node pred = tail;</span><br><span class="line">    <span class="comment">// 判断尾节点是否为空</span></span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 将尾节点作为创造出来的节点的前驱节点，即将创造出来的节点</span></span><br><span class="line">        <span class="comment">// 链接到为尾节点后</span></span><br><span class="line">        node.prev = pred;</span><br><span class="line">        <span class="comment">// 利用CAS将尾节点tail由pred设置为node</span></span><br><span class="line">        <span class="comment">// 此时队列 node1 &lt;-&gt; node</span></span><br><span class="line">        <span class="comment">// 再加上 node1 &lt;-&gt; prev</span></span><br><span class="line">        <span class="comment">// 所以此时队列应为  node1 &lt;-&gt; prev &lt;-&gt; node</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            <span class="comment">// 如果成功，则将pred的后继节点为node</span></span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    enq(node); <span class="comment">// 正常入队</span></span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体的实现流程已在代码中注释，如果不是快速入队，那么就进行正常入队，即调用AQS的enq(node)方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 等待，直到插入到队列位置</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// 将尾节点tail赋给t</span></span><br><span class="line">        Node t = tail;</span><br><span class="line">        <span class="comment">// 判断尾节点是否为空，如果尾节点为空，说明队列为空</span></span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// Must initialize</span></span><br><span class="line">            <span class="comment">// 生成一个新节点，将head由null设置为新节点的值</span></span><br><span class="line">            <span class="comment">// 如果设置失败，说明在这个过程中已经有其他线程设置过head了</span></span><br><span class="line">            <span class="comment">// 当成功的将这个dummy节点设置到head节点上去时，我们又将这个head节点// 设置给了tail节点，即head与tail都是当前这个dummy节点，</span></span><br><span class="line">            <span class="comment">// 之后有新节点入队的话，就插入到该dummy之后</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">                tail = head;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">//如果尾节点不为空，则按照快速入队操作进行操作</span></span><br><span class="line">            node.prev = t;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123; <span class="comment">// 尝试将尾节点设置为node</span></span><br><span class="line">                t.next = node; <span class="comment">// 将node节点设置为尾节点,即将尾节点的后继节点设置为node节点</span></span><br><span class="line">                <span class="keyword">return</span> t;  <span class="comment">// 返回原先的尾节点</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>入队成功之后需要调用AQS的acquireQueued(addWaiter(Node.EXCLUSIVE), arg))方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 队列中的结点在独占且忽略中断的模式下获取锁</span></span><br><span class="line"><span class="comment">  * 如果获取成功则返回false</span></span><br><span class="line"><span class="comment">  * 如果获取失败</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>; <span class="comment">// 失败标志</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>; <span class="comment">//中断标志</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123; <span class="comment">// 无限等待</span></span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor(); <span class="comment">// 获取插入节点的前一个节点p</span></span><br><span class="line">            <span class="comment">// 仅当当前的节点的前驱节点并且</span></span><br><span class="line">            <span class="comment">// 尝试获取锁成功，跳出循环</span></span><br><span class="line">            <span class="comment">// 当第一次循环就获取成功了，interrupted为false，不需要中断</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node); <span class="comment">// 设置头结点</span></span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125; <span class="comment">// 当获取(锁)失败后，检查并且更新结点状态, 挂起当前节点并检查中断</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果acquireQueued方法没有跳出循环（获取锁失败），那么就要判断当前节点是否可以安全的挂起（park），下面就会调用AQS的shouldParkAfterFailedAcquire(Node pred, Node node) 方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当获取(资源)失败后，检查并且更新结点状态</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ws = pred.waitStatus; <span class="comment">// 获取前驱节点的状态</span></span><br><span class="line">     <span class="comment">// 当且仅当状态为SIGNAL时，表示当前节点在以后可以被唤醒，那么就可以进行挂起// （park）操作了</span></span><br><span class="line">     <span class="comment">// 此时 ws的值为-1</span></span><br><span class="line">    <span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * This node has already set status asking a release</span></span><br><span class="line"><span class="comment">         * to signal it, so it can safely park.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">// ws大于零说明前驱节点的状态为CANCEL, 即为1</span></span><br><span class="line">    <span class="comment">// 即前驱节点的线程被取消了，需要将其从队列中除去，最终返回false</span></span><br><span class="line">    <span class="comment">// 不能被安全的挂起</span></span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Predecessor was cancelled. Skip over predecessors and</span></span><br><span class="line"><span class="comment">         * indicate retry.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">// 这句话node.prev = pred = pred.prev;</span></span><br><span class="line">            <span class="comment">// 相当于</span></span><br><span class="line">            <span class="comment">// pred = pred.prev;</span></span><br><span class="line">            <span class="comment">// node.prev = pred;</span></span><br><span class="line">            node.prev = pred = pred.prev;</span><br><span class="line">        &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>); <span class="comment">// 找到pred结点前面最近的一个状态不为CANCELLED的结点</span></span><br><span class="line">        pred.next = node; <span class="comment">// 将该节点的后继节点设置为当前节点</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// waitStatus 为PROPAGATE -3 或者是0 表示无状态,(为CONDITION -2时，表示此节点在condition queue中)</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * waitStatus must be 0 or PROPAGATE.  Indicate that we</span></span><br><span class="line"><span class="comment">         * need a signal, but don't park yet.  Caller will need to</span></span><br><span class="line"><span class="comment">         * retry to make sure it cannot acquire before parking.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// 利用CAS来将当前节点的前驱节点的状态设置为SIGNAL</span></span><br><span class="line">        <span class="comment">// 如果设置成功的话，下次再来访问 状态就为SIGNAL了</span></span><br><span class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">// 如果ws不为SIGNAL, 其他情况全部返回false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在该方法中需要判断当前节点的前驱节点的状态，如果状态为SIGNAL时，表示当前节点在以后可以被唤醒，那么就可以进行挂起了<br><br><strong>如果不是</strong></p><ul><li>那么就需要判断该前驱节点（线程）是否被取消了，如果被取消，那么这个前驱节点应该从队列中除去，再经过while循环找到pred结点前面最近的一个状态不为CANCELLED的结点，并将当前节点的前驱节点设置为该节点；</li><li>如果该前驱节点的waitStatus不为CANCELLED,那么利用CAS将当前节点的前驱节点的状态设置为SIGNAL</li></ul><p>接下来就会执行AQS 中的parkAndCheckInterrupt()方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 进行挂起（park）操作并且返回该线程是否被中断</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LockSupport.park(<span class="keyword">this</span>); <span class="comment">//挂起当前线程</span></span><br><span class="line">    <span class="keyword">return</span> Thread.interrupted(); <span class="comment">// 如果当前线程已经被中断了，返回true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>parkAndCheckInterrupt方法首先执行挂起（park）操作，然后返回该线程是否已经被中断。</p><p>此时回到acquireQueued(final Node node, int arg)方法，看finally语句块中的cancelAcquire(node)方法，该方法在挂起失败后执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 取消继续获取锁</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">cancelAcquire</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Ignore if node doesn't exist</span></span><br><span class="line">    <span class="comment">// node为空，返回</span></span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// node节点内的线程置为空</span></span><br><span class="line">    node.thread = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Skip cancelled predecessors</span></span><br><span class="line">    <span class="comment">// 该节点的前驱节点</span></span><br><span class="line">    Node pred = node.prev;</span><br><span class="line">    <span class="comment">// 找到pred结点前面最近的一个状态不为CANCELLED的结点</span></span><br><span class="line">    <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>)</span><br><span class="line">        node.prev = pred = pred.prev;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// node结点为尾结点，则利用CAS设置尾结点为pred结点</span></span><br><span class="line">    <span class="keyword">if</span> (node == tail &amp;&amp; compareAndSetTail(node, pred)) &#123;</span><br><span class="line">        compareAndSetNext(pred, predNext, <span class="keyword">null</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">// node结点不为尾结点，或者CAS设置不成功</span></span><br><span class="line">        <span class="comment">// If successor needs signal, try to set pred's next-link</span></span><br><span class="line">        <span class="comment">// so it will get one. Otherwise wake it up to propagate.</span></span><br><span class="line">        <span class="keyword">int</span> ws;</span><br><span class="line">        <span class="comment">// （pred结点不为头结点，并且pred结点的状态为SIGNAL）或者</span></span><br><span class="line">        <span class="comment">//  ws小于0，并且比较并设置等待状态为SIGNAL成功，并且pred结点内的线程不为空</span></span><br><span class="line">        <span class="keyword">if</span> (pred != head &amp;&amp;</span><br><span class="line">            ((ws = pred.waitStatus) == Node.SIGNAL ||</span><br><span class="line">             (ws &lt;= <span class="number">0</span> &amp;&amp; compareAndSetWaitStatus(pred, ws, Node.SIGNAL))) &amp;&amp;</span><br><span class="line">            pred.thread != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Node next = node.next; <span class="comment">// 获取节点的后继节点</span></span><br><span class="line">            <span class="comment">// 如果后继节点不为空 并且后继节点的等待状态小于等于0</span></span><br><span class="line">            <span class="keyword">if</span> (next != <span class="keyword">null</span> &amp;&amp; next.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                compareAndSetNext(pred, predNext, next); <span class="comment">// 比较并设置pred.next = next;</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            unparkSuccessor(node); <span class="comment">// 释放节点的后继节点</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        node.next = node; <span class="comment">// help GC</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在该方法中取消继续获取锁。</p><p>在该方法中会调用一个方法unparkSuccessor，该方法的作用就是为了释放node节点的后继结点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * If status is negative (i.e., possibly needing signal) try</span></span><br><span class="line"><span class="comment">     * to clear in anticipation of signalling.  It is OK if this</span></span><br><span class="line"><span class="comment">     * fails or if status is changed by waiting thread.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     <span class="comment">// 获取节点的状态</span></span><br><span class="line">    <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>); <span class="comment">// 利用CAS 将状态设置为0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Thread to unpark is held in successor, which is normally</span></span><br><span class="line"><span class="comment">     * just the next node.  But if cancelled or apparently null,</span></span><br><span class="line"><span class="comment">     * traverse backwards from tail to find the actual</span></span><br><span class="line"><span class="comment">     * non-cancelled successor.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 获取节点的后继节点</span></span><br><span class="line">    Node s = node.next;</span><br><span class="line">    <span class="comment">// 判断后继节点是否为空 或者 后者后继节点的状态为CANCELLED</span></span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        s = <span class="keyword">null</span>; <span class="comment">// 将后继节点置为null</span></span><br><span class="line">        <span class="comment">// 从尾节点从后向前开始遍历知道节点为空或者当前节点为止</span></span><br><span class="line">        <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>) <span class="comment">// 如果此时节点的状态小于等于0</span></span><br><span class="line">                s = t; <span class="comment">// 将此节点赋给传入节点的后继节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>)  <span class="comment">// 节点不为空，释放</span></span><br><span class="line">        LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，ReentrantLock获取非公平锁的步骤就结束了。</p><h3 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h3><p>如果需要使用公平锁，那么在创建ReentrantLock实例的时候需要向其构造函数传入布尔值true，然后在构造方法里利用三元运算创建公平锁的实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="公平锁的用法"><a href="#公平锁的用法" class="headerlink" title="公平锁的用法"></a>公平锁的用法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lock.lock();</span><br></pre></td></tr></table></figure><h4 id="公平锁加锁的简单步骤："><a href="#公平锁加锁的简单步骤：" class="headerlink" title="公平锁加锁的简单步骤："></a>公平锁加锁的简单步骤：</h4><p>获取一次state的值</p><ul><li>如果state为0，查看CLH队列中是否还有其他线程在等待获取锁，如果有，则获取锁失败；如果没有，则利用CAS将state的值由0设置为1，如果成功，设置独占锁的线程为当前线。</li><li>如果state不为0或者CLH队列中还有其他线程在等待获取锁，查看当前线程是不是已经是独占锁的线程了，如果是，则将当前的锁数量+1；如果不是，则将该线程封装在一个Node内，并加入到等待队列中去。等待被其前一个线程节点唤醒。</li></ul><p>此过程严格遵守“先到先得”策略。</p><h4 id="公平锁与非公平锁的重要区别是："><a href="#公平锁与非公平锁的重要区别是：" class="headerlink" title="公平锁与非公平锁的重要区别是："></a>公平锁与非公平锁的重要区别是：</h4><p>非公平锁在要获取锁的时候，首先会尝试直接获取锁，而公平锁则需要判断CLH队列中是否还有其他线程在等待获取锁。</p><h4 id="公平锁具体获取流程："><a href="#公平锁具体获取流程：" class="headerlink" title="公平锁具体获取流程："></a>公平锁具体获取流程：</h4><p>首先调用FairSync静态内部类的lock方法，在这个方法中直接调用AQS的acquire方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>AQS的acquire方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后会调用FairSync的tryAcquire方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 和非公平锁的区别：即使当前锁是空闲的，也要查看CLH队列中是否还有其他线程在等</span></span><br><span class="line"><span class="comment">  * 待获取锁，如果有则获取失败，严格遵守“先到先得”的策略  </span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当前线程</span></span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="comment">// 获取state</span></span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="comment">// 判断state的值是否为0</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 这一步是判断CLH队列中是否还有其他等待获取锁的线程，如果有返回true，没有则返回false</span></span><br><span class="line">        <span class="comment">// 同时还需要利用CAS将state由0设置为1</span></span><br><span class="line">        <span class="comment">// 如果上述两步都返回true，那么设置独占锁线程为当前线程</span></span><br><span class="line">        <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">            compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;  <span class="comment">// 如果当前state不是0，则判断当前线程是否为独占锁线程</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="comment">// 将state进行+1操作，判断state值后返回</span></span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">// 获取锁失败，考虑将线程加入等待队列</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个方法中，首先获取state的值，判断当前是否可以获取锁</p><ul><li>如果state为0，说明锁没有被其他线程获取，但由于是公平锁，那么需要判断CLH队列中是否还有其他线程在等待获取锁，如果有，那么就获取锁失败了；如果没有，则需要利用CAS将state由0设置为1，这两步都返回true，那么设置独占锁线程为当前线程</li><li>如果当前state不是0，则判断当前线程是否为独占锁线程，如果是，将state加1，然后返回</li><li>其他情况返回false，获取锁失败。</li></ul><p>判断CLH队列中是否还有其他等待获取锁的线程需要调用CAS的hasQueuedPredecessors方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断CLH队列中是否还有其他等待获取锁的线程</span></span><br><span class="line"><span class="comment"> * 如果当前线程之前有一个排队的线程，返回true</span></span><br><span class="line"><span class="comment"> * 如果当前线程在队列的头部或队列为空，返回false</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasQueuedPredecessors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// The correctness of this depends on head being initialized</span></span><br><span class="line">    <span class="comment">// before tail and on head.next being accurate if the current</span></span><br><span class="line">    <span class="comment">// thread is first in queue.</span></span><br><span class="line">    Node t = tail; <span class="comment">// Read fields in reverse initialization order</span></span><br><span class="line">    Node h = head;</span><br><span class="line">    Node s;</span><br><span class="line">    <span class="keyword">return</span> h != t &amp;&amp;</span><br><span class="line">        ((s = h.next) == <span class="keyword">null</span> || s.thread != Thread.currentThread());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>接下来的流程和非公平一样。</p><h3 id="总结：非公平锁与公平锁获取锁对比："><a href="#总结：非公平锁与公平锁获取锁对比：" class="headerlink" title="总结：非公平锁与公平锁获取锁对比："></a>总结：非公平锁与公平锁获取锁对比：</h3><ul><li>NonfairSync： 非公平锁在要获取锁的时候，首先会尝试直接获取锁</li><li>FairSync 而公平锁则需要判断CLH队列中是否还有其他线程在等待获取锁</li></ul><p>ReentrantLock是基于AbstractQueuedSynchronizer（AQS）实现的，AQS可以实现独占锁也可以实现共享锁，ReentrantLock只是使用了其中的独占锁模式。</p><h3 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h3><p><a href="http://www.cnblogs.com/java-zhao/p/5131544.html" target="_blank" rel="noopener">http://www.cnblogs.com/java-zhao/p/5131544.html</a></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> JUC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> Lock </tag>
            
            <tag> JUC </tag>
            
            <tag> ReentrantLock </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>设计模式之观察者模式</title>
      <link href="/2017/10/17/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
      <url>/2017/10/17/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>我们在生活中会遇到这样一些例子，比如你订阅了某人的博客，那么这个人发布博客的时候会将消息推送给你，而且不是只推送你自己一人，只要订阅了该人的博客，那么订阅者都会收到通知，像这样的例子生活中实在是太多了。其实这种操作可以抽象一下，A对象（观察者）对B对象（被观察者）的某种变化高度敏感，需要在B变化的一瞬间做出反应，同时在B对象中维护着所有A的集合。我们在实际编程中称这种模式为观察者模式，有时也称为发布/订阅(Publish/Subscribe)模型。</p><p>在JDK的util包中已经帮我们实现了观察者模式，不过我们还是先通过自己写代码来看看观察者到底是怎么回事，自己该如何简单的实现，相信通过自己的简单实现，来理解JDK的观察者模式的实现是十分容易的。</p><p>在观察者模式中，首先要有两个角色，观察者与被观察者，这两者拥有的功能是不同的。对于观察者，需要有一个方法来接收被观察者发出的信息(update)，而对于被观察者而言，需要在其内部维护一个观察者的列表，用来记录需要通知的观察者(list)，所以需要一个添加观察者的方法(addWatcher），同时还要有一个方法可以用来移除观察者(removeWatcher), 最后我们需要一个用来通知所有观察者的方法(notifyWatchers), 一切准备就绪，那么我们来看代码吧。</p><p>先定义两个接口，观察者(Watcher)和被观察者(Watched),代码如下：</p><p>首先是观察者接口，定义了update方法用来接收通知</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 观察者</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mingshan</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Watcher</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用来接收通知</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span>  <span class="title">update</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>然后是被观察者接口，定义了三个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 被观察者</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mingshan</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Watched</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加观察者</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> watcher</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addWatcher</span><span class="params">(Watcher watcher)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 移除观察者</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> watcher</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removeWatcher</span><span class="params">(Watcher watcher)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通知观察者</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">notifyWatchers</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们先实现被观察者，重写接口的方法，在其内部维护一个列表，用来存放所有的观察者，当需要通知观察者时，我们就可以调用notifyWatchers方法了，遍历通知所有观察者。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thief</span> <span class="keyword">implements</span> <span class="title">Watched</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;Watcher&gt; list = <span class="keyword">new</span> ArrayList&lt;Watcher&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addWatcher</span><span class="params">(Watcher watcher)</span> </span>&#123;</span><br><span class="line">        list.add(watcher);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeWatcher</span><span class="params">(Watcher watcher)</span> </span>&#123;</span><br><span class="line">        list.remove(watcher);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyWatchers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Watcher watcher: list) &#123;</span><br><span class="line">            watcher.update();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们再实现观察者，重写update方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Police</span> <span class="keyword">implements</span> <span class="title">Watcher</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"小偷正在偷东西，警察行动！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">------------------------------</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Inspector</span> <span class="keyword">implements</span> <span class="title">Watcher</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"小偷正在偷东西，城管行动！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后我们写个测试类测试一下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObserverTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thief thief = <span class="keyword">new</span> Thief();</span><br><span class="line">        Police police = <span class="keyword">new</span> Police();</span><br><span class="line">        Inspector inspector = <span class="keyword">new</span> Inspector();</span><br><span class="line">        thief.addWatcher(police);</span><br><span class="line">        thief.addWatcher(inspector);</span><br><span class="line"></span><br><span class="line">        thief.notifyWatchers();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>以上是我们自己实现的观察者模式，前面说过了在JDK中已经帮我们实现好了观察者模式，那么我们来用一下：</p><p>观察者：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 被观察者 (JDK)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mingshan</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thief</span> <span class="keyword">extends</span> <span class="title">Observable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"我是小偷-_-"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"ss准备下手偷东西了！"</span>);</span><br><span class="line">        setChanged();</span><br><span class="line">        notifyObservers(<span class="string">"-小偷说话：哈哈，你猜我是谁-"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>观察者：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Observable;</span><br><span class="line"><span class="keyword">import</span> java.util.Observer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Police</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Observable o, Object arg)</span> </span>&#123;</span><br><span class="line">        System.out.println(o + <span class="string">"小偷正在偷东西，警察行动！"</span>+ arg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">——————————————————————————————————————</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Observable;</span><br><span class="line"><span class="keyword">import</span> java.util.Observer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Inspector</span> <span class="keyword">implements</span> <span class="title">Observer</span>  </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Observable o, Object arg)</span> </span>&#123;</span><br><span class="line">        System.out.println(o + <span class="string">"小偷正在偷东西，城管行动！"</span> + arg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObserverTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thief thief = <span class="keyword">new</span> Thief();</span><br><span class="line">        Police police = <span class="keyword">new</span> Police();</span><br><span class="line">        Inspector inspector = <span class="keyword">new</span> Inspector();</span><br><span class="line">        thief.addObserver(police);</span><br><span class="line">        thief.addObserver(inspector);</span><br><span class="line">        thief.work();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Observable类源码中，我们可以看到有个changed的布尔值成员变量，用来标志当前对象是否已经被改变，所有在通知观察者之前我们将其置为true</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Observable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> changed = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">private</span> Vector&lt;Observer&gt; obs;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Construct an Observable with zero Observers. */</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Observable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        obs = <span class="keyword">new</span> Vector&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加观察者，并且一个观察者只能被添加一次</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">addObserver</span><span class="params">(Observer o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">if</span> (!obs.contains(o)) &#123;</span><br><span class="line">            obs.addElement(o);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 移除观察者</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">deleteObserver</span><span class="params">(Observer o)</span> </span>&#123;</span><br><span class="line">        obs.removeElement(o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通知所有的观察者</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyObservers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        notifyObservers(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通知所有的观察者(遍历)，同时可以将一些信息传递给观察者，实际上是调用观察** 者的update方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyObservers</span><span class="params">(Object arg)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * a temporary array buffer, used as a snapshot of the state of</span></span><br><span class="line"><span class="comment">         * current Observers.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Object[] arrLocal;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!changed)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            arrLocal = obs.toArray();</span><br><span class="line">            clearChanged();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = arrLocal.length-<span class="number">1</span>; i&gt;=<span class="number">0</span>; i--)</span><br><span class="line">            ((Observer)arrLocal[i]).update(<span class="keyword">this</span>, arg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除观察者</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">deleteObservers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        obs.removeAllElements();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将判断当前对象是否改变的flag设置为true</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setChanged</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        changed = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  将判断当前对象是否改变的flag设置为false</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">clearChanged</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        changed = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断当前对象是否改变</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">hasChanged</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> changed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 统计观察者数量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">countObservers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> obs.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 设计模式 </tag>
            
            <tag> 观察者模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>设计模式之单例模式</title>
      <link href="/2017/10/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
      <url>/2017/10/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>我们在项目中会遇到这样一些情况，比如一个类，我们想让这个类在系统中有且仅有一个对象，不能够重复创建类的实例，因为这种类是无状态的，我们只需要有过一个类的实例就行了。这时我们需要用到设计模式的单例模式。</p><p>单例模式分为饿汉式和懒汉式，下面对这两种模式简单介绍:</p><ol><li>饿汉式是指当系统启动或者类被加载时就已经创建了类的实例</li><li>懒汉式是指当该类第一次被调用的时候才会去创建该类的实例</li></ol><p>单例模式有很多实现，不同实现有优有劣，下面谈谈单例的具体的一些实现</p><h2 id="单例模式-饿汉式"><a href="#单例模式-饿汉式" class="headerlink" title="单例模式  - 饿汉式"></a>单例模式  - 饿汉式</h2><p>如果不实现懒加载的话，那么就用饿汉式实现单例就比较简单，首先让无参构造函数私有化，我们可以直接对该类进行实例化，然后将其赋值给类的成员变量instance，然后提供一个外部可以访问的方法来获取类的实例。下面是代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 单例模式  - 饿汉式</span></span><br><span class="line"><span class="comment"> * 线程安全，但未实现懒加载。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mingshan</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonDemo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonDemo1</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> SingletonDemo1 instance = <span class="keyword">new</span> SingletonDemo1();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonDemo1 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="单例模式-懒汉式"><a href="#单例模式-懒汉式" class="headerlink" title="单例模式  - 懒汉式"></a>单例模式  - 懒汉式</h2><p>如果想实现懒加载，那么就要用到懒汉式了。懒汉式是当类第一次被调用的时候才被实例化，但这个时候就会出现线程安全问题，所以我们需要对进行类实例化的部分进行加锁，来保证类的实例只有一个，由于加锁的问题，性能就会降低。虽然做到了线程安全，并且解决了多实例的问题，但是它并不高效。因为在任何时候只能有一个线程调用 getInstance()方法。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 单例模式  - 懒汉模式</span></span><br><span class="line"><span class="comment"> * 实现延迟加载 ，所以 getInstance() 方法必须同步</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 此方法实现单例模式 性能比饿汉式低</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mingshan</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonDemo2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingletonDemo2 instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonDemo2</span><span class="params">()</span> </span>&#123;&#125;    </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> SingletonDemo2 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> SingletonDemo2();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>还有一种实现懒加载的方式使用静态内部类来实现单例，由于静态内部类外部不能被访问到，这一种写法简单，比较容易理解，推荐使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 单例模式  使用静态内部类 实现延迟加载</span></span><br><span class="line"><span class="comment"> * 比较推荐</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mingshan</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonDemo3</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonDemo3</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> SingletonDemo3 instance = <span class="keyword">new</span> SingletonDemo3();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonDemo3 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面写了一个线程安全的单例模式的懒汉式，但却不是十分理想，假如同时有好多线程去调用getInstance方法，那么同一时间只有一个线程能够获取到类的实例，其他的线程都要排队等待该线程释放锁，效率低下。所以此时引出了“双重检验锁”。现在同时有两个线程进入到getInstance方法中，那么两个线程都会进入到第一个判空语句块中，因为此时还没有创建类的实例，接下来只有一个线程能获取到锁，进入到synchronized (SingletonDemo4.class){}语句块中，创建类的实例后释放锁，当前等待线程就会获取到锁，此时如果没有第二次判空操作，那么第二个线程就会再创建一次类的实例，这样就违背了单例的原则，所以双重检验锁就是这么来的。因为上来不是直接就加锁，而是在进行判空后加锁，也就是只有该类还没有被实例化时才会被加锁，当有实例了就不用加锁了，自然就提高了性能。当代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 懒汉式的再次优化</span></span><br><span class="line"><span class="comment"> * 双重检验锁，解决线程安全问题</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mingshan</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonDemo4</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> SingletonDemo4 instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonDemo4</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonDemo4 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (SingletonDemo4.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;            </span><br><span class="line">                    instance = <span class="keyword">new</span> SingletonDemo4();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里用到了volatile关键字，这里保证了不同线程对这个变量进行操作时的可见性。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 设计模式 </tag>
            
            <tag> 单例模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>谈谈基于ZooKeeper的分布式锁</title>
      <link href="/2017/10/08/%E8%B0%88%E8%B0%88%E5%9F%BA%E4%BA%8EZooKeeper%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
      <url>/2017/10/08/%E8%B0%88%E8%B0%88%E5%9F%BA%E4%BA%8EZooKeeper%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>分布式锁可以基于以下几种方式实现：</p><ul><li>基于数据库的乐观锁，用于分布式锁</li><li>基于缓存(Redis, memcached)实现分布式锁</li><li>基于ZooKeeper实现分布式锁</li></ul><p>在这篇文章中，主要讲讲ZooKeeper以及分布式锁的实现，通过了解基于ZooKeeper分布式锁实现的原理，我们会对ZooKeeper有一个基本的了解。</p><h2 id="ZooKeeper介绍"><a href="#ZooKeeper介绍" class="headerlink" title="ZooKeeper介绍"></a>ZooKeeper介绍</h2><p>首先谈谈ZooKeeper，ZooKeeper是一种为分布式应用所设计的高可用、高性能且一致的开源协调服务，它提供了一项基本服务：分布式锁服务。由于ZooKeeper的开源特性，后来我们的开发者在分布式锁的基础上，摸索了出了其他的使用方法：配置维护、组服务、分布式消息队列、分布式通知/协调等。</p><p>在ZooKeeper中，有一个被称为ZNode的节点，在该节点可以存储同步相关的数据，并且多个ZNode节点可以形成类似下图的结构。</p><p><img src="/images/zookeeper.png" alt="image"></p><h3 id="基本命令："><a href="#基本命令：" class="headerlink" title="基本命令："></a>基本命令：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">1. 查看节点</span><br><span class="line">    ls /</span><br><span class="line">2. 创建节点</span><br><span class="line">    create /zk myData</span><br><span class="line">3. 查看节点</span><br><span class="line">    get /zk</span><br><span class="line">4. 设置节点</span><br><span class="line">    set /zk myData2</span><br><span class="line">5. 删除节点</span><br><span class="line">    delete /zk</span><br><span class="line">6. 创建临时节点</span><br><span class="line">    create -e /han data</span><br><span class="line">7. 创建顺序节点</span><br><span class="line">    create -s /han/ data</span><br><span class="line">8. 创建顺序临时节点</span><br><span class="line">    create -s -e /han/ data</span><br></pre></td></tr></table></figure><h3 id="ZNode"><a href="#ZNode" class="headerlink" title="ZNode"></a>ZNode</h3><p>客户端可以在一个ZNode上设置一个监视器（Watch），如果该ZNode数据发生变更，ZooKeeper会通知客户端，从而触发监视器中实现的逻辑的执行。其中ZNode有以下几种类型：</p><ul><li>PERSISTENT</li><li>PERSISTENT_SEQUENTIAL</li><li>EPHEMERAL</li><li>EPHEMERAL_SEQUENTIAL</li></ul><p>下面分别解释一下：</p><ol><li>PERSISTENT为持久节点，持久节点是指在节点创建后，就一直存在，直到有删除操作来主动清除这个节点——不会因为创建该节点的客户端会话失效而消失。<br>ZooKeeper命令：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create /zk myData</span><br></pre></td></tr></table></figure><ol start="2"><li>PERSISTENT_SEQUENTIAL为持久顺序节点，基本特性与持久节点一致，但每个父节点会为他的第一级子节点维护一份时序，会记录每个子节点创建的先后顺序。命令：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create -s /han/ data</span><br></pre></td></tr></table></figure><p>用这条命令的话，需要先创建/han节点，节点类型为PERSISTENT。</p><ol start="3"><li>EPHEMERAL为临时节点，客户端会话失效或连接关闭后，该节点会被自动删除，且不能在临时节点下面创建子节点，命令：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create -e /han</span><br></pre></td></tr></table></figure><p>如果在临时节点下面还要创建子节点，那么zk就会提示：Ephemerals cannot have children</p><ol start="4"><li>EPHEMERAL_SEQUENTIAL为临时顺序节点，该节点的除了不是持久性节点，其他特性与持久顺序节点一致。命令：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create -s -e /han/ data</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="不利用EPHEMERAL-SEQUENTIA简单实现"><a href="#不利用EPHEMERAL-SEQUENTIA简单实现" class="headerlink" title="不利用EPHEMERAL_SEQUENTIA简单实现"></a>不利用EPHEMERAL_SEQUENTIA简单实现</h2><p>首先我们需要一个业务,这里模拟一下订单生成，利用时间加上序号来表示，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> pers.mingshan.ZookeeperLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 订单号生成器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mingshan</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderCodeGenerator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getOrderCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yy-MM-dd HH:mm:ss - "</span>);</span><br><span class="line">        Date date = <span class="keyword">new</span> Date();</span><br><span class="line">        sdf.format(date);</span><br><span class="line">        <span class="keyword">return</span> sdf.format(date) + ++i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里只是简单模拟一下，不考虑其他因素。<br>然后我们需要对外提供获取订单号的服务，这里我们用到了CountDownLatch, CountDownLatch是一个同步工具类，它允许一个或多个线程一直等待，直到其他线程的操作执行完后再执行。所以我们需要所有的线程都创建完毕后去同时生成订单编号，模拟一下并发。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> pers.mingshan.ZookeeperLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.log4j.Logger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderServiceImpl</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> OrderCodeGenerator generator = <span class="keyword">new</span> OrderCodeGenerator();</span><br><span class="line">    <span class="comment">// 同时并发的线程数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NUM = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> Logger logger = Logger.getLogger(getClass());</span><br><span class="line">    <span class="comment">// 根据线程数初始化倒计数器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> CountDownLatch cdl = <span class="keyword">new</span> CountDownLatch(NUM);</span><br><span class="line">    <span class="comment">// lock锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Lock lock = <span class="keyword">new</span> ZookeeperDistributeLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createOrderCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String orderCode = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            orderCode = generator.getOrderCode();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        logger.info((Thread.currentThread().getName() + <span class="string">": 成功获取锁 =====&gt; "</span> + orderCode));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 等待其他线程初始化</span></span><br><span class="line">            cdl.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        createOrderCode();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        OrderServiceImpl service = <span class="keyword">new</span> OrderServiceImpl();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NUM; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(service).start();</span><br><span class="line">            <span class="comment">// 每初始化一个线程， 计数器减一</span></span><br><span class="line">            cdl.countDown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个类中，我们实例化了ZookeeperDistributeLock，然后我们对获取订单编号的方法进行加锁操作，在finally语句块中执行释放锁操作。</p><p>下面来看ZookeeperDistributeLock，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> pers.mingshan.ZookeeperLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.I0Itec.zkclient.IZkDataListener;</span><br><span class="line"><span class="keyword">import</span> org.I0Itec.zkclient.ZkClient;</span><br><span class="line"><span class="keyword">import</span> org.I0Itec.zkclient.exception.ZkNodeExistsException;</span><br><span class="line"><span class="keyword">import</span> org.apache.log4j.Logger;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 利用Zookeeper节点名称的唯一性进行加锁和释放锁操作。</span></span><br><span class="line"><span class="comment"> * 利用znode名称唯一性进行加锁，所有客户端去竞争加锁，但只有一个会加锁</span></span><br><span class="line"><span class="comment"> * 成功，其他客户端需要等待加锁成功的客户端去释放锁，释放锁操作则是删除该节点，</span></span><br><span class="line"><span class="comment"> * 同时通知所有watch这个节点的客户端，其他的客户端再竞争加锁。</span></span><br><span class="line"><span class="comment"> * 由于释放锁会通知所有watch该节点的客户端，所以会出现羊群效应，</span></span><br><span class="line"><span class="comment"> * 造成资源浪费。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mingshan</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZookeeperDistributeLock</span> <span class="keyword">implements</span> <span class="title">Lock</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Logger logger = Logger.getLogger(ZookeeperDistributeLock.class);</span><br><span class="line">    <span class="comment">// Zookeeper IP和端口</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ZK_IP_PORT = <span class="string">"localhost:2181"</span>;</span><br><span class="line">    <span class="comment">// Node 的名称</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String LOCK_NODE = <span class="string">"/lockS"</span>;</span><br><span class="line">    <span class="comment">// 创建 Zookeeper 的客户端</span></span><br><span class="line">    <span class="keyword">private</span> ZkClient zkClient = <span class="keyword">new</span> ZkClient(ZK_IP_PORT);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 减数器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> CountDownLatch cdl = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 阻塞式加锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 先尝试加锁，加锁成功后就直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (tryLock()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果不成功， 需要等待其他线程 释放锁</span></span><br><span class="line">        waitForLock();</span><br><span class="line">        <span class="comment">// 递归调用加锁</span></span><br><span class="line">        lock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 等待其他线程释放锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">waitForLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 给节点加 监听器</span></span><br><span class="line">        IZkDataListener listener = <span class="keyword">new</span> IZkDataListener() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDataDeleted</span><span class="params">(String dataPath)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                logger.info(<span class="string">"----node delete event------"</span>);</span><br><span class="line">                <span class="keyword">if</span> (cdl != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    cdl.countDown();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDataChange</span><span class="params">(String dataPath, Object data)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行订阅node节点的数据变化</span></span><br><span class="line">        zkClient.subscribeDataChanges(LOCK_NODE, listener);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (zkClient.exists(LOCK_NODE)) &#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                cdl = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">                cdl.await();</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 取消订阅node节点的数据变化</span></span><br><span class="line">        zkClient.unsubscribeDataChanges(LOCK_NODE, listener);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 实现非阻塞式加锁</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            zkClient.createPersistent(LOCK_NODE);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ZkNodeExistsException e) &#123;</span><br><span class="line">            logger.error(<span class="string">"加锁失败 -- reason -"</span> + e.getMessage());</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        zkClient.delete(LOCK_NODE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Condition <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 利用Zookeeper节点名称的唯一性进行加锁和释放锁操作。利用znode名称唯一性进行加锁，所有客户端去竞争加锁，但只有一个会加锁成功， 其他客户端需要等待加锁成功的客户端去释放锁，释放锁操作则是删除该节点，同时通知所有watch这个节点的客户端，其他的客户端再竞争加锁。由于释放锁会通知所有watch该节点的客户端，所以会出现羊群效应，造成资源浪费。</p><h2 id="利用EPHEMERAL-SEQUENTIA解决“羊群效应”"><a href="#利用EPHEMERAL-SEQUENTIA解决“羊群效应”" class="headerlink" title="利用EPHEMERAL_SEQUENTIA解决“羊群效应”"></a>利用EPHEMERAL_SEQUENTIA解决“羊群效应”</h2><p>实现逻辑：</p><p>首先创建一个持久节点</p><p>在trylock方法中先判断当前临时顺序节点是否存在，如果不存在，那么就创建一个临时顺序节点，临时顺序节点为持久节点的子节点</p><p>然后获取所有的临时顺序节点并进行排序，判断当前节点是否为最小节点</p><ul><li>如果当前结点为最小节点，说明当前可以加锁</li><li>如果当前临时节点并非最小，代表当前客户端没有获取锁，需要继续等待,此时获取比当前节点序号小的节点（比当前节点小的最大节点, 将此值赋给beforePath,例如： 当前节点是 /lock/000000003, 那么beforePath为 /lock/000000002，只有当beforePath获得锁并且释放锁后，当前客户端才能去获取锁,这样可以 避免羊群效应</li></ul><p>在lock方法中，首先会调用trylock进行尝试加锁，如果加锁失败，那么就要调用waitForLock方法，在该方法中，对当前临时顺序节点的前一个节点进行监听，此时只需给前面的节点的添加wathcher即可。</p><p>实现代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> pers.mingshan.ZookeeperLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.I0Itec.zkclient.IZkDataListener;</span><br><span class="line"><span class="keyword">import</span> org.I0Itec.zkclient.ZkClient;</span><br><span class="line"><span class="keyword">import</span> org.I0Itec.zkclient.serialize.SerializableSerializer;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mingshan</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZookeeperImproveDistributeLock</span> <span class="keyword">implements</span> <span class="title">Lock</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(ZookeeperImproveDistributeLock.class);</span><br><span class="line">    <span class="comment">// Zookeeper IP和端口</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ZK_IP_PORT = <span class="string">"localhost:2181"</span>;</span><br><span class="line">    <span class="comment">// Node 的名称</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String LOCK_ROOT_NODE = <span class="string">"/lock"</span>;</span><br><span class="line">    <span class="comment">// 创建 Zookee的客户端</span></span><br><span class="line">    <span class="keyword">private</span> ZkClient zkClient = <span class="keyword">new</span> ZkClient(ZK_IP_PORT, <span class="number">1000</span>, <span class="number">1000</span>, <span class="keyword">new</span> SerializableSelizer());</span><br><span class="line">    <span class="comment">// 当前创建的节点</span></span><br><span class="line">    <span class="keyword">private</span> String selfPath;</span><br><span class="line">    <span class="comment">// 当前节点的前一个节点</span></span><br><span class="line">    <span class="keyword">private</span> String beforePath;</span><br><span class="line">    <span class="comment">// 节点默认值</span></span><br><span class="line">    <span class="keyword">private</span> String data = <span class="string">"data"</span>;</span><br><span class="line">    <span class="comment">// 减数器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> CountDownLatch cdl = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ZookeeperImproveDistributeLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 先创建一个主节点，以便其他线程在此节点之下创建临时顺序节点</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.zkClient.exists(LOCK_ROOT_NODE)) &#123;</span><br><span class="line">            <span class="keyword">this</span>.zkClient.createPersistent(LOCK_ROOT_NODE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 先尝试加锁，加锁成功后就直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (!tryLock()) &#123;</span><br><span class="line">            waitForLock();</span><br><span class="line">            lock();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            logger.info(Thread.currentThread().getName() + <span class="string">"---获取锁"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">waitForLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 给节点加 监听器</span></span><br><span class="line">        IZkDataListener listener = <span class="keyword">new</span> IZkDataListener() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDataDeleted</span><span class="params">(String dataPath)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                logger.info(<span class="string">"----before node delete event------"</span>);</span><br><span class="line">                <span class="keyword">if</span> (cdl != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    cdl.countDown();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDataChange</span><span class="params">(String dataPath, Object data)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 此时只需给前面的节点的添加wathcher即可</span></span><br><span class="line">        zkClient.subscribeDataChanges(<span class="keyword">this</span>.beforePath, listener);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (zkClient.exists(<span class="keyword">this</span>.beforePath)) &#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                cdl = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">                cdl.await();</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 取消订阅前面的节点的变化</span></span><br><span class="line">        zkClient.unsubscribeDataChanges(<span class="keyword">this</span>.beforePath, listener);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 判断当前节点是否存在</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.selfPath == <span class="keyword">null</span> || <span class="keyword">this</span>.selfPath.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 在当前节点下创建临时顺序节点，例如0000000034,</span></span><br><span class="line">            <span class="comment">// 生成的节点应为 /lock/0000000034</span></span><br><span class="line">            <span class="keyword">this</span>.selfPath = <span class="keyword">this</span>.zkClient.createEphemeralSequential(LOCK_ROOT_NODE + <span class="string">"/"</span>, data);</span><br><span class="line">            logger.info(<span class="string">"当前节点为 ————&gt; "</span> + <span class="keyword">this</span>.selfPath);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取所有的临时顺序节点，并进行排序</span></span><br><span class="line">        List&lt;String&gt; allESNodes = zkClient.getChildren(LOCK_ROOT_NODE);</span><br><span class="line">        Collections.sort(allESNodes);</span><br><span class="line">        logger.info(<span class="string">"0  ————&gt; "</span>+ allESNodes.get(<span class="number">0</span>));</span><br><span class="line">        <span class="comment">// 判断当前节点是否为最小节点</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.selfPath.equals(LOCK_ROOT_NODE + <span class="string">"/"</span> + allESNodes.get(<span class="number">0</span>))) &#123;</span><br><span class="line">            <span class="comment">// 如果当前结点为最小节点，说明当前可以加锁</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果当前临时节点并非最小，代表当前客户端没有获取锁，需要继续等待,</span></span><br><span class="line">            <span class="comment">// 此时获取比当前节点序号小的节点（比当前节点小的最大节点, 将此值赋给beforePath</span></span><br><span class="line">            <span class="comment">// 例如： 当前节点是 /lock/000000003, 那么beforePath为 /lock/000000002，</span></span><br><span class="line">            <span class="comment">// 只有当beforePath获得锁并且释放锁后，当前客户端才能去获取锁</span></span><br><span class="line">            <span class="comment">// 这样可以 避免羊群效应</span></span><br><span class="line">            <span class="keyword">int</span> wz = Collections.binarySearch(allESNodes, <span class="keyword">this</span>.selfPath.substring(<span class="number">6</span>));</span><br><span class="line">            <span class="keyword">this</span>.beforePath = LOCK_ROOT_NODE + <span class="string">"/"</span> + allESNodes.get(wz - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 删除当前节点，释放锁</span></span><br><span class="line">        zkClient.delete(<span class="keyword">this</span>.selfPath);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Condition <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码还有其他实现方式，代码如下（网上的）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> pers.mingshan.ZookeeperLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.*;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.data.Stat;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZookeeperOptimizedDistributedLock</span> <span class="keyword">implements</span> <span class="title">Watcher</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> threadId;</span><br><span class="line">    <span class="keyword">private</span> ZooKeeper zk = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> String selfPath;</span><br><span class="line">    <span class="keyword">private</span> String waitPath;</span><br><span class="line">    <span class="keyword">private</span> String LOG_PREFIX_OF_THREAD;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SESSION_TIMEOUT = <span class="number">10000</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String GROUP_PATH = <span class="string">"/disLocks"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SUB_PATH = <span class="string">"/disLocks/sub"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String CONNECTION_STRING = <span class="string">"localhost:2181"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THREAD_NUM = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">//确保连接zk成功</span></span><br><span class="line">    <span class="keyword">private</span> CountDownLatch connectedSemaphore = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//确保所有线程运行结束</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> CountDownLatch threadSemaphore = <span class="keyword">new</span> CountDownLatch(THREAD_NUM);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOG = LoggerFactory.getLogger(ZookeeperOptimizedDistributedLock.class);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ZookeeperOptimizedDistributedLock</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.threadId = id;</span><br><span class="line">        LOG_PREFIX_OF_THREAD = <span class="string">"【第"</span>+threadId+<span class="string">"个线程】"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; THREAD_NUM; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> threadId = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        ZookeeperOptimizedDistributedLock dc = <span class="keyword">new</span> ZookeeperOptimizedDistributedLock(threadId);</span><br><span class="line">                        dc.createConnection(CONNECTION_STRING, SESSION_TIMEOUT);</span><br><span class="line">                        <span class="comment">//GROUP_PATH不存在的话，由一个线程创建即可；</span></span><br><span class="line">                        <span class="keyword">synchronized</span> (threadSemaphore)&#123;</span><br><span class="line">                            dc.createPath(GROUP_PATH, <span class="string">"该节点由线程"</span> + threadId + <span class="string">"创建"</span>, <span class="keyword">true</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                        dc.getLock();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        LOG.error(<span class="string">"【第"</span>+threadId+<span class="string">"个线程】 抛出的异常："</span>);</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;.start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            threadSemaphore.await();</span><br><span class="line">            LOG.info(<span class="string">"所有线程运行结束!"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取锁</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">getLock</span><span class="params">()</span> <span class="keyword">throws</span> KeeperException, InterruptedException </span>&#123;</span><br><span class="line">        selfPath = zk.create(SUB_PATH, <span class="keyword">null</span>, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL);</span><br><span class="line">        LOG.info(LOG_PREFIX_OF_THREAD+<span class="string">"创建锁路径:"</span>+selfPath);</span><br><span class="line">        <span class="keyword">if</span>(checkMinPath())&#123;</span><br><span class="line">            getLockSuccess();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> path 节点path</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data 初始数据内容</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">createPath</span><span class="params">( String path, String data, <span class="keyword">boolean</span> needWatch)</span></span></span><br><span class="line"><span class="function">                <span class="keyword">throws</span> KeeperException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(zk.exists(path, needWatch)==<span class="keyword">null</span>)&#123;</span><br><span class="line">            LOG.info( LOG_PREFIX_OF_THREAD + <span class="string">"节点创建成功, Path: "</span></span><br><span class="line">                    + <span class="keyword">this</span>.zk.create( path,</span><br><span class="line">                    data.getBytes(),</span><br><span class="line">                    ZooDefs.Ids.OPEN_ACL_UNSAFE,</span><br><span class="line">                    CreateMode.PERSISTENT )</span><br><span class="line">                    + <span class="string">", content: "</span> + data );</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建ZK连接</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> connectString  ZK服务器地址列表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sessionTimeout Session超时时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createConnection</span><span class="params">( String connectString, <span class="keyword">int</span> sessionTimeout )</span></span></span><br><span class="line"><span class="function">                <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">            zk = <span class="keyword">new</span> ZooKeeper( connectString, sessionTimeout, <span class="keyword">this</span>);</span><br><span class="line">            connectedSemaphore.await();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取锁成功</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getLockSuccess</span><span class="params">()</span> <span class="keyword">throws</span> KeeperException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (zk.exists(<span class="keyword">this</span>.selfPath,<span class="keyword">false</span>) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            LOG.error(LOG_PREFIX_OF_THREAD+<span class="string">"本节点已不在了..."</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        LOG.info(LOG_PREFIX_OF_THREAD + <span class="string">"获取锁成功，赶紧干活！"</span>);</span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        LOG.info(LOG_PREFIX_OF_THREAD + <span class="string">"删除本节点："</span>+selfPath);</span><br><span class="line">        zk.delete(<span class="keyword">this</span>.selfPath, -<span class="number">1</span>);</span><br><span class="line">        releaseConnection();</span><br><span class="line">        threadSemaphore.countDown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 关闭ZK连接</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">releaseConnection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( <span class="keyword">this</span>.zk !=<span class="keyword">null</span> ) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.zk.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> ( InterruptedException e ) &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        LOG.info(LOG_PREFIX_OF_THREAD + <span class="string">"释放连接"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 检查自己是不是最小的节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkMinPath</span><span class="params">()</span> <span class="keyword">throws</span> KeeperException, InterruptedException </span>&#123;</span><br><span class="line">         List&lt;String&gt; subNodes = zk.getChildren(GROUP_PATH, <span class="keyword">false</span>);</span><br><span class="line">         Collections.sort(subNodes);</span><br><span class="line">         <span class="keyword">int</span> index = subNodes.indexOf( selfPath.substring(GROUP_PATH.length() + <span class="number">1</span>));</span><br><span class="line">         <span class="keyword">switch</span> (index)&#123;</span><br><span class="line">             <span class="keyword">case</span> -<span class="number">1</span>:&#123;</span><br><span class="line">                 LOG.error(LOG_PREFIX_OF_THREAD+<span class="string">"本节点已不在了..."</span>+selfPath);</span><br><span class="line">                 <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">case</span> <span class="number">0</span>:&#123;</span><br><span class="line">                 LOG.info(LOG_PREFIX_OF_THREAD+<span class="string">"子节点中，我果然是老大"</span>+selfPath);</span><br><span class="line">                 <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">default</span>:&#123;</span><br><span class="line">                 <span class="keyword">this</span>.waitPath = GROUP_PATH +<span class="string">"/"</span>+ subNodes.get(index - <span class="number">1</span>);</span><br><span class="line">                 LOG.info(LOG_PREFIX_OF_THREAD+<span class="string">"获取子节点中，排在我前面的"</span>+waitPath);</span><br><span class="line">                 <span class="keyword">try</span>&#123;</span><br><span class="line">                     zk.getData(waitPath, <span class="keyword">true</span>, <span class="keyword">new</span> Stat());</span><br><span class="line">                     <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                 &#125;<span class="keyword">catch</span>(KeeperException e)&#123;</span><br><span class="line">                     <span class="keyword">if</span>(zk.exists(waitPath,<span class="keyword">false</span>) == <span class="keyword">null</span>)&#123;</span><br><span class="line">                         LOG.info(LOG_PREFIX_OF_THREAD+<span class="string">"子节点中，排在我前面的"</span>+waitPath+<span class="string">"已失踪，幸福来得太突然?"</span>);</span><br><span class="line">                         <span class="keyword">return</span> checkMinPath();</span><br><span class="line">                     &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                         <span class="keyword">throw</span> e;</span><br><span class="line">                     &#125;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(event == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Event.KeeperState keeperState = event.getState();</span><br><span class="line">        Event.EventType eventType = event.getType();</span><br><span class="line">        <span class="keyword">if</span> ( Event.KeeperState.SyncConnected == keeperState) &#123;</span><br><span class="line">            <span class="keyword">if</span> ( Event.EventType.None == eventType ) &#123;</span><br><span class="line">                LOG.info( LOG_PREFIX_OF_THREAD + <span class="string">"成功连接上ZK服务器"</span> );</span><br><span class="line">                connectedSemaphore.countDown();</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (event.getType() == Event.EventType.NodeDeleted &amp;&amp; event.getPath().equals(waitPath)) &#123;</span><br><span class="line">                LOG.info(LOG_PREFIX_OF_THREAD + <span class="string">"收到情报，排我前面的家伙已挂，我是不是可以出山了？"</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span>(checkMinPath())&#123;</span><br><span class="line">                        getLockSuccess();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (KeeperException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> ( Event.KeeperState.Disconnected == keeperState ) &#123;</span><br><span class="line">            LOG.info( LOG_PREFIX_OF_THREAD + <span class="string">"与ZK服务器断开连接"</span> );</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ( Event.KeeperState.AuthFailed == keeperState ) &#123;</span><br><span class="line">            LOG.info( LOG_PREFIX_OF_THREAD + <span class="string">"权限检查失败"</span> );</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ( Event.KeeperState.Expired == keeperState ) &#123;</span><br><span class="line">            LOG.info( LOG_PREFIX_OF_THREAD + <span class="string">"会话失效"</span> );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://blog.csdn.net/desilting/article/details/41280869" target="_blank" rel="noopener">http://blog.csdn.net/desilting/article/details/41280869</a></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> ZooKeeper </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> ZooKeeper </tag>
            
            <tag> 分布式锁 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>利用SpringMVC实现RESTful API，并与Swagger集成生成API文档</title>
      <link href="/2017/10/01/%E5%88%A9%E7%94%A8SpringMVC%E5%AE%9E%E7%8E%B0RESTful%20API%EF%BC%8C%E5%B9%B6%E4%B8%8ESwagger%E9%9B%86%E6%88%90%E7%94%9F%E6%88%90API%E6%96%87%E6%A1%A3/"/>
      <url>/2017/10/01/%E5%88%A9%E7%94%A8SpringMVC%E5%AE%9E%E7%8E%B0RESTful%20API%EF%BC%8C%E5%B9%B6%E4%B8%8ESwagger%E9%9B%86%E6%88%90%E7%94%9F%E6%88%90API%E6%96%87%E6%A1%A3/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="认识RESTful-API"><a href="#认识RESTful-API" class="headerlink" title="认识RESTful API"></a>认识RESTful API</h2><p>RESTful API是目前比较成熟的API设计理论，它通过统一的API接口来对外提供服务，这样对其他调用者来说比较友好，更加容易实现前后端分离。那么如果要使用RESTful API来写我们的代码，那么就需要先知道RESTful API规范。</p><h2 id="参考RESTful-API规范"><a href="#参考RESTful-API规范" class="headerlink" title="参考RESTful API规范"></a>参考RESTful API规范</h2><p>下面是两篇文章讲解RESTful API的，推荐：</p><ol><li><a href="http://www.ruanyifeng.com/blog/2014/05/restful_api.html" target="_blank" rel="noopener">RESTful API 设计指南</a></li><li><a href="http://www.csdn.net/article/2013-06-13/2815744-RESTful-API" target="_blank" rel="noopener">RESTful API 设计最佳实践</a></li></ol><h2 id="SpringMVC实现RESTful-API"><a href="#SpringMVC实现RESTful-API" class="headerlink" title="SpringMVC实现RESTful API"></a>SpringMVC实现RESTful API</h2><p>SpringMVC提供了一些注解来实现RESTful API, 例如<strong>@RestController</strong>，同时我们用Swagger来生成API文档，这样更加利于测试API。</p><h3 id="常见swagger注解一览与使用"><a href="#常见swagger注解一览与使用" class="headerlink" title="常见swagger注解一览与使用"></a>常见swagger注解一览与使用</h3><p><strong>最常用的5个注解</strong></p><p>@Api：修饰整个类，描述Controller的作用<br>@ApiOperation：描述一个类的一个方法，或者说一个接口<br>@ApiParam：单个参数描述<br>@ApiModel：用对象来接收参数<br>@ApiProperty：用对象接收参数时，描述对象的一个字段</p><p><strong>其它若干</strong></p><p>@ApiResponse：HTTP响应其中1个描述<br>@ApiResponses：HTTP响应整体描述<br>@ApiClass<br>@ApiError<br>@ApiErrors<br>@ApiParamImplicit<br>@ApiParamsImplicit</p><p><strong>其中@ApiOperation和@ApiParam参数说明</strong></p><p>@ApiOperation和@ApiParam为添加的API相关注解，参数说明如下：<br>@ApiOperation(value = “接口说明”, httpMethod = “接口请求方式”, response = “接口返回参数类型”, notes = “接口发布说明”；其他参数可参考源码；<br>@ApiParam(required = “是否必须参数”, name = “参数名称”, value = “参数具体描述”</p><h3 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h3><p>首先在pom.xml文件中添加swagger依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- swagger --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.mangofactory<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>swagger-springmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-annotations<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="Swagger-UI配置"><a href="#Swagger-UI配置" class="headerlink" title="Swagger-UI配置"></a>Swagger-UI配置</h3><p>首先从<a href="https://github.com/swagger-api/swagger-ui" target="_blank" rel="noopener">Swagger-UI下载地址</a>下载Swagger-UI文件，然后将其拷贝到webapp目录下，我这里新建了一个swagger文件夹，然后解压后的文件拷贝到这个文件夹里面了。</p><p>修改swagger/index.html文件，默认是从连接<a href="http://petstore.swagger.io/v2/swagger.json获取" target="_blank" rel="noopener">http://petstore.swagger.io/v2/swagger.json获取</a> API 的JSON，这里需要将url值修改为http://{ip}:{port}/{projectName}/api-docs的形式，{}中的值根据自身情况填写。比如我的url值为：<a href="http://localhost:8080/lightblog/api-docs" target="_blank" rel="noopener">http://localhost:8080/lightblog/api-docs</a></p><h3 id="编写swagger配置文件"><a href="#编写swagger配置文件" class="headerlink" title="编写swagger配置文件"></a>编写swagger配置文件</h3><p>配置完Swagger-UI后，我们需要配置Swagger，并将其交给Spring进行管理。<br><a id="more"></a><br>SwaggerConfig类代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lightblog.swagger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.mangofactory.swagger.configuration.SpringSwaggerConfig;</span><br><span class="line"><span class="keyword">import</span> com.mangofactory.swagger.models.dto.ApiInfo;</span><br><span class="line"><span class="keyword">import</span> com.mangofactory.swagger.plugin.EnableSwagger;</span><br><span class="line"><span class="keyword">import</span> com.mangofactory.swagger.plugin.SwaggerSpringMvcPlugin;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ComponentScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.EnableWebMvc;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: Minsghan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: Created in 16:40 2017/10/3</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Modified</span> By:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebMvc</span><span class="comment">//如果没加这个会报错</span></span><br><span class="line"><span class="meta">@EnableSwagger</span><span class="comment">//上面三个注释都是必要的</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(basePackages=<span class="string">"com.lightblog.controller"</span>)<span class="comment">//添加这个注释，会自动扫描该类中的每一个方法自动生成api文档</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SwaggerConfig</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> SpringSwaggerConfig springSwaggerConfig;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Required to autowire SpringSwaggerConfig</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSpringSwaggerConfig</span><span class="params">(SpringSwaggerConfig springSwaggerConfig)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.springSwaggerConfig = springSwaggerConfig;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Every SwaggerSpringMvcPlugin bean is picked up by the swagger-mvc</span></span><br><span class="line"><span class="comment">     * framework - allowing for multiple swagger groups i.e. same code base</span></span><br><span class="line"><span class="comment">     * multiple swagger resource listings.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SwaggerSpringMvcPlugin <span class="title">customImplementation</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SwaggerSpringMvcPlugin(<span class="keyword">this</span>.springSwaggerConfig)</span><br><span class="line">                .apiInfo(apiInfo())</span><br><span class="line">                .includePatterns(<span class="string">".*?"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ApiInfo <span class="title">apiInfo</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ApiInfo apiInfo = <span class="keyword">new</span> ApiInfo(</span><br><span class="line">                <span class="string">"springmvc搭建swagger"</span>,</span><br><span class="line">                <span class="string">"spring-API swagger测试"</span>,</span><br><span class="line">                <span class="string">"My Apps API terms of service"</span>,</span><br><span class="line">                <span class="string">"499445428@qq.com"</span>,</span><br><span class="line">                <span class="string">"web app"</span>,</span><br><span class="line">                <span class="string">"My Apps API License URL"</span>);</span><br><span class="line">        <span class="keyword">return</span> apiInfo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将 springSwaggerConfig加载到spring容器，配置如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 将 springSwaggerConfig加载到spring容器 --&gt;</span><br><span class="line">&lt;bean class=&quot;com.mangofactory.swagger.configuration.SpringSwaggerConfig&quot; /&gt;</span><br><span class="line">&lt;!-- 将自定义的swagger配置类加载到spring容器 --&gt;</span><br><span class="line">&lt;bean class=&quot;com.lightblog.swagger.SwaggerConfig&quot; /&gt;</span><br></pre></td></tr></table></figure><h3 id="Controller实现REST-API以及与Swagger集成"><a href="#Controller实现REST-API以及与Swagger集成" class="headerlink" title="Controller实现REST API以及与Swagger集成"></a>Controller实现REST API以及与Swagger集成</h3><p>在Controller中，我们不需要返回页面了，而是要返回json格式的数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lightblog.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.lightblog.model.User;</span><br><span class="line"><span class="keyword">import</span> com.lightblog.service.UserService;</span><br><span class="line"><span class="keyword">import</span> com.wordnik.swagger.annotations.Api;</span><br><span class="line"><span class="keyword">import</span> com.wordnik.swagger.annotations.ApiOperation;</span><br><span class="line"><span class="keyword">import</span> com.wordnik.swagger.annotations.ApiParam;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.HttpHeaders;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.HttpStatus;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.MediaType;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.ResponseEntity;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.util.UriComponentsBuilder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: The api of user.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: Minsghan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: Created in 15:27 2017/10/3</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Modified</span> By:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Api</span>(value=<span class="string">"user"</span>)</span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/api/user"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> <span class="keyword">extends</span> <span class="title">BaseController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span>: Mingshan</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Description</span>: Get list of user.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>:  null</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span>: 15:16 2017/10/3</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">""</span>, method = RequestMethod.GET)</span><br><span class="line">    <span class="meta">@ApiOperation</span>(value=<span class="string">"获取所有用户信息"</span>, httpMethod=<span class="string">"GET"</span>, notes=<span class="string">"Get users"</span>, response=ResponseEntity.class)</span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;List&lt;User&gt;&gt; listAllUsers() &#123;</span><br><span class="line">        List&lt;User&gt; users = userService.findAll();</span><br><span class="line">        <span class="keyword">if</span>(users.isEmpty())&#123;</span><br><span class="line">            <span class="comment">// You many decide to return HttpStatus.NOT_FOUND</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ResponseEntity&lt;List&lt;User&gt;&gt;(HttpStatus.NO_CONTENT);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ResponseEntity&lt;List&lt;User&gt;&gt;(users, HttpStatus.OK);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span>: Mingshan</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Description</span>: Get information of user by id.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>:  * <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span>: 15:34 2017/10/3</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"/&#123;id&#125;"</span>, method = RequestMethod.GET, produces = MediaType.APPLICATION_JSON_VALUE)</span><br><span class="line">    <span class="meta">@ApiOperation</span>(value=<span class="string">"获取用户信息"</span>, httpMethod=<span class="string">"GET"</span>, notes=<span class="string">"Get user by id"</span>, response=User.class)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResponseEntity&lt;User&gt; <span class="title">getUser</span><span class="params">(@ApiParam(required=<span class="keyword">true</span>,value=<span class="string">"用户ID"</span>,name=<span class="string">"id"</span>)</span>@<span class="title">PathVariable</span><span class="params">(<span class="string">"id"</span>)</span> <span class="keyword">long</span> id) </span>&#123;</span><br><span class="line">        logger.info(<span class="string">"Fetching User with id "</span> + id);</span><br><span class="line">        User user = userService.findById(id);</span><br><span class="line">        <span class="keyword">if</span> (user == <span class="keyword">null</span>) &#123;</span><br><span class="line">            logger.info(<span class="string">"User with id "</span> + id + <span class="string">" not found"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ResponseEntity&lt;User&gt;(HttpStatus.NOT_FOUND);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ResponseEntity&lt;User&gt;(user, HttpStatus.OK);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span>: Mingshan</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Description</span>: Create a user.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>:  * <span class="doctag">@param</span> null</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span>: 15:34 2017/10/3</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">""</span>, method = RequestMethod.POST)</span><br><span class="line">    <span class="meta">@ApiOperation</span>(value=<span class="string">"新增用户"</span>, httpMethod=<span class="string">"POST"</span>, notes=<span class="string">"Create user"</span>, response=ResponseEntity.class)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResponseEntity&lt;Void&gt; <span class="title">createUser</span><span class="params">(@ApiParam(required=<span class="keyword">true</span>,value=<span class="string">"用户信息"</span>,name=<span class="string">"User"</span>)</span></span></span><br><span class="line"><span class="function">                                               @RequestBody User user, UriComponentsBuilder ucBuilder) </span>&#123;</span><br><span class="line">        logger.info(<span class="string">"Creating User "</span> + user.getName());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (userService.isUserExist(user)) &#123;</span><br><span class="line">            System.out.println(<span class="string">"A User with name "</span> + user.getName() + <span class="string">" already exist"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ResponseEntity&lt;Void&gt;(HttpStatus.CONFLICT);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        userService.insert(user);</span><br><span class="line"></span><br><span class="line">        HttpHeaders headers = <span class="keyword">new</span> HttpHeaders();</span><br><span class="line">        headers.setLocation(ucBuilder.path(<span class="string">"/user/&#123;id&#125;"</span>).buildAndExpand(user.getId()).toUri());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ResponseEntity&lt;Void&gt;(headers, HttpStatus.CREATED);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span>: Mingshan</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Description</span>: Update a user.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>:  * <span class="doctag">@param</span> null</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span>: 15:33 2017/10/3</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"/&#123;id&#125;"</span>, method = RequestMethod.PUT)</span><br><span class="line">    <span class="meta">@ApiOperation</span>(value=<span class="string">"更新用户信息"</span>, httpMethod=<span class="string">"PUT"</span>, notes=<span class="string">"Update user"</span>, response=User.class)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResponseEntity&lt;User&gt; <span class="title">updateUser</span><span class="params">(@ApiParam(required=<span class="keyword">true</span>,value=<span class="string">"用户ID"</span>,name=<span class="string">"id"</span>)</span>@<span class="title">PathVariable</span><span class="params">(<span class="string">"id"</span>)</span> <span class="keyword">long</span> id,</span></span><br><span class="line"><span class="function">                                           @RequestBody User user) </span>&#123;</span><br><span class="line">        logger.info(<span class="string">"Updating User "</span> + id);</span><br><span class="line"></span><br><span class="line">        User currentUser = userService.findById(id);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (currentUser == <span class="keyword">null</span>) &#123;</span><br><span class="line">            logger.info(<span class="string">"User with id "</span> + id + <span class="string">" not found"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ResponseEntity&lt;User&gt;(HttpStatus.NOT_FOUND);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        currentUser.setName(user.getName());</span><br><span class="line">        currentUser.setAge(user.getAge());</span><br><span class="line"></span><br><span class="line">        userService.update(currentUser);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ResponseEntity&lt;User&gt;(currentUser, HttpStatus.OK);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span>: Mingshan</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Description</span>: Delete a user by id.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>:  * <span class="doctag">@param</span> null</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span>: 15:32 2017/10/3</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"/&#123;id&#125;"</span>, method = RequestMethod.DELETE)</span><br><span class="line">    <span class="meta">@ApiOperation</span>(value=<span class="string">"删除用户"</span>, httpMethod=<span class="string">"DELETE"</span>, notes=<span class="string">"Delete user by id"</span>, response=ResponseEntity.class)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResponseEntity&lt;Void&gt; <span class="title">deleteUser</span><span class="params">(@ApiParam(required=<span class="keyword">true</span>,value=<span class="string">"用户ID"</span>,name=<span class="string">"id"</span>)</span>@<span class="title">PathVariable</span><span class="params">(<span class="string">"id"</span>)</span> <span class="keyword">long</span> id) </span>&#123;</span><br><span class="line">        logger.info(<span class="string">"Fetching &amp; Deleting User with id "</span> + id);</span><br><span class="line"></span><br><span class="line">        User user = userService.findById(id);</span><br><span class="line">        <span class="keyword">if</span> (user == <span class="keyword">null</span>) &#123;</span><br><span class="line">            logger.info(<span class="string">"Unable to delete. User with id "</span> + id + <span class="string">" not found"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ResponseEntity&lt;Void&gt;(HttpStatus.NOT_FOUND);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        userService.delete(id);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ResponseEntity&lt;Void&gt;(HttpStatus.NO_CONTENT);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="运行截图"><a href="#运行截图" class="headerlink" title="运行截图"></a>运行截图</h3><p><img src="https://ip.freep.cn/590836/snipaste20171008_163312.png" alt="image"><br><img src="https://ip.freep.cn/590836/snipaste20171008_163351.png" alt="image"></p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol><li><a href="http://blog.csdn.net/fansunion/article/details/51923720" target="_blank" rel="noopener">http://blog.csdn.net/fansunion/article/details/51923720</a></li><li><a href="http://blog.csdn.net/w605283073/article/details/51338765" target="_blank" rel="noopener">http://blog.csdn.net/w605283073/article/details/51338765</a></li></ol><p>官网：<a href="http://swagger.io/" target="_blank" rel="noopener">http://swagger.io/</a></p><p>GitHub：</p><p>swagger-springmvc:<a href="https://github.com/martypitt/swagger-springmvc" target="_blank" rel="noopener">https://github.com/martypitt/swagger-springmvc</a></p><p>swagger-ui:<a href="https://github.com/swagger-api/swagger-ui" target="_blank" rel="noopener">https://github.com/swagger-api/swagger-ui</a></p><p>swagger-core:<a href="https://github.com/swagger-api/swagger-core" target="_blank" rel="noopener">https://github.com/swagger-api/swagger-core</a></p><p>swagger-spec：<a href="https://github.com/swagger-api/swagger-spec" target="_blank" rel="noopener">https://github.com/swagger-api/swagger-spec</a></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> RESTful-API </tag>
            
            <tag> Swagger </tag>
            
            <tag> SpringMVC </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>在Service层进行事务控制</title>
      <link href="/2017/09/15/%E5%9C%A8Service%E5%B1%82%E8%BF%9B%E8%A1%8C%E4%BA%8B%E5%8A%A1%E6%8E%A7%E5%88%B6/"/>
      <url>/2017/09/15/%E5%9C%A8Service%E5%B1%82%E8%BF%9B%E8%A1%8C%E4%BA%8B%E5%8A%A1%E6%8E%A7%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="利用接口回调实现JDBCTemplate"><a href="#利用接口回调实现JDBCTemplate" class="headerlink" title="利用接口回调实现JDBCTemplate"></a>利用接口回调实现JDBCTemplate</h2><ol><li><p>设计一个回调接口JDBCCallback<t>, 用来设置参数和获取结果集, 代码如下：<br></t></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">JDBCCallback</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function">T <span class="title">rsToObject</span><span class="params">(ResultSet rs)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setParams</span><span class="params">(PreparedStatement pstmt)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>设计一个抽象类JDBCAbstractCallBack<t>，该类实现JDBCCallback<t>接口，重写接口中的两个方法，<br> 不需要具体实现，只需要重写一下就可以了，这样在DAO层用的时候不用这两个方法全部都要实现，代码如下：</t></t></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * JDBC abstract callback class, implements &#123;<span class="doctag">@link</span> JDBCCallback&#125; interface.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Mingshan</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">JDBCAbstractCallBack</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">JDBCCallback</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">rsToObject</span><span class="params">(ResultSet rs)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setParams</span><span class="params">(PreparedStatement pstmt)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line"><span class="comment">// NOOP</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>设计一个JDBCTemplate类，该类实现增删改查的基本方法，把公共的代码抽取出来，以便DAO层去调用JDBCTemplate来实现具体的业务，部分代码如下：</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * JDBC Template, applys for delete, query, update, save functions.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Mingshan</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDBCTemplate</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Querys data by sql.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;T&gt; <span class="title">query</span><span class="params">(String sql, JDBCCallback&lt;T&gt; jdbcCallback)</span> </span>&#123;</span><br><span class="line">        Connection conn = <span class="keyword">null</span>;</span><br><span class="line">        PreparedStatement pstmt = <span class="keyword">null</span>;</span><br><span class="line">        ResultSet rs = <span class="keyword">null</span>;</span><br><span class="line">        List&lt;T&gt; data = <span class="keyword">new</span> ArrayList&lt;T&gt;();</span><br><span class="line">        <span class="keyword">boolean</span> needMyClose = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// Gets connection of JDBC.</span></span><br><span class="line">            ConnectionHolder connectionHolder = (ConnectionHolder) AppContext.getAppContext()</span><br><span class="line">                    .getObject(Constants.APP_REQUEST_THREAD_CONNECTION);</span><br><span class="line">            <span class="keyword">if</span> (connectionHolder != <span class="keyword">null</span>) &#123;</span><br><span class="line">                conn = connectionHolder.getConn();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (conn == <span class="keyword">null</span>) &#123;</span><br><span class="line">                conn = DB.getConn();</span><br><span class="line">                needMyClose = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            pstmt = DB.getPrepareStatement(conn, sql);</span><br><span class="line">            <span class="comment">// Sets parameters for PreparedStatement.</span></span><br><span class="line">            jdbcCallback.setParams(pstmt);</span><br><span class="line">            rs = pstmt.executeQuery();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (rs.next()) &#123;</span><br><span class="line">                <span class="comment">// Gets data from database.</span></span><br><span class="line">                T object = jdbcCallback.rsToObject(rs);</span><br><span class="line">                data.add(object);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> DBException();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            DB.close(rs);</span><br><span class="line">            DB.close(pstmt);</span><br><span class="line">            <span class="keyword">if</span> (needMyClose) &#123;</span><br><span class="line">                DB.close(conn);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(String sql, JDBCCallback&lt;T&gt; jdbcCallback)</span> </span>&#123;</span><br><span class="line">        Connection conn = <span class="keyword">null</span>;</span><br><span class="line">        PreparedStatement pstmt = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">boolean</span> needMyClose = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ConnectionHolder connectionHolder = (ConnectionHolder) AppContext.getAppContext()</span><br><span class="line">                    .getObject(Constants.APP_REQUEST_THREAD_CONNECTION);</span><br><span class="line">            <span class="keyword">if</span> (connectionHolder != <span class="keyword">null</span>) &#123;</span><br><span class="line">                conn = connectionHolder.getConn();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (conn == <span class="keyword">null</span>) &#123;</span><br><span class="line">                conn = DB.getConn();</span><br><span class="line">                needMyClose = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            pstmt = DB.getPrepareStatement(conn, sql);</span><br><span class="line">            jdbcCallback.setParams(pstmt);</span><br><span class="line">            pstmt.execute();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> DBException();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            DB.close(pstmt);</span><br><span class="line">            <span class="keyword">if</span> (needMyClose) &#123;</span><br><span class="line">                DB.close(conn);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>其他的增删改查可以按照上面的模式进行扩展，就不写了。</p><ol start="4"><li>在DAO层使用JDBCTemplate，部分代码如下：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> JDBCTemplate&lt;User&gt; jdbcTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setJdbcTemplate</span><span class="params">(JDBCTemplate&lt;User&gt; jdbcTemplate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.jdbcTemplate = jdbcTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">findUserByUserName</span><span class="params">(<span class="keyword">final</span> String userName)</span> </span>&#123;</span><br><span class="line">        User user = <span class="keyword">null</span>;</span><br><span class="line">        String sql = <span class="string">"SELECT * FROM user WHERE user_name = ?"</span>;</span><br><span class="line">        user = jdbcTemplate.queryOne(sql, <span class="keyword">new</span> JDBCAbstractCallBack&lt;User&gt;() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> User <span class="title">rsToObject</span><span class="params">(ResultSet rs)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">                User user = <span class="keyword">new</span> User();</span><br><span class="line">                user.setPassword(rs.getString(Constants.USER_PASSWORD));</span><br><span class="line">                user.setUserName(rs.getString(Constants.USER_USER_NAME));</span><br><span class="line">                user.setId(rs.getInt(Constants.USER_ID));</span><br><span class="line">                <span class="keyword">return</span> user;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setParams</span><span class="params">(PreparedStatement pstmt)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">                pstmt.setString(<span class="number">1</span>, userName);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>—————————————————————————OVER————————————————————————————</p><hr><h2 id="如何在Service层进行事务控制？"><a href="#如何在Service层进行事务控制？" class="headerlink" title="如何在Service层进行事务控制？"></a>如何在Service层进行事务控制？</h2><ol><li><p>设计一个ConnectionHolder类，用来存放Connection。<br> 该类有两个成员变量 Connection conn, boolean isOpenTransaction, 并且提供getter和setter方法。<br> Connection conn 用来存放Connection, boolean isOpenTransaction 用来判断需不需要开启事务</p></li><li><p>编写ConnectionProxy类，并实现InvocationHandler接口，该类用来真正实现事务控制，具体解析如下：</p><ol><li><p>首先需要获取配置的事务传播，用来判断哪些方法需要进行事务控制，哪些不需要，可以参考Spring配置事务的代码，这里先模拟一下，XML配置信息如下，然后需要对XML配置信息进行解析，然后以map形式返回，这时我们就可以按照我们的需求来判断当前要调用Service层的方法到底是属于哪一种，进而判断是否要进行事务控制。如果需要关闭数据库连接，那么数据库连接应在代理类中关闭。</p></li><li><p>判读connectionHolder对象是否已被创建，如果已被创建，直接使用，然后进行事务控制判断；如果不存在，那么在这里创建，需要拿到数据库连接，然后进行事务控制判断。这里用到了Connection共用，即一个request只有一个Connection。</p></li><li><p>利用反射调用方法， 此时方法会出现异常， 需要进行捕获。如果事务开启，并且调用方法出现异常了，那么就需要事     务回滚，最后关闭连接。</p></li><li><p>DAO层的写法请参考JDBCTemplate, 为了防止数据库连接中断，需要DAO层再进行一次连接判断，此时数据库的连接就     需要在DAO层关闭了。</p></li></ol></li></ol><p>事务配置：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- TransactionInterceptor --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"TransactionInterceptor"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"transactionAttributes"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"update*"</span> <span class="attr">propagation</span>=<span class="string">"REQUIRED"</span>&gt;</span><span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"delete*"</span> <span class="attr">propagation</span>=<span class="string">"REQUIRED"</span>&gt;</span><span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"save*"</span> <span class="attr">propagation</span>=<span class="string">"REQUIRED"</span>&gt;</span><span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"find*"</span> <span class="attr">propagation</span>=<span class="string">"SUPPORTS"</span>&gt;</span><span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"select*"</span> <span class="attr">propagation</span>=<span class="string">"SUPPORTS"</span>&gt;</span><span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>代理类代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * JDBC ConnectionProxy.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Mingshan</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConnectionProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line">    <span class="keyword">private</span> TransactionConfig transactionConfig = AppContext.getAppContext().getTransactionConfig();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTarget</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        Object result = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// If current thread close connection.</span></span><br><span class="line">        <span class="keyword">boolean</span> needMyClose = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">boolean</span> isCommitOrRollBackTran = <span class="keyword">false</span>;</span><br><span class="line">        Map&lt;String, String&gt; tranAttributeMap = transactionConfig.getTranAttributeMap();</span><br><span class="line">        String[] allowed = getTransactionAttribute(transactionConfig);</span><br><span class="line">        String originKey = method.getName() + <span class="string">"*"</span>;</span><br><span class="line">        <span class="comment">// Before advice.</span></span><br><span class="line">        ConnectionHolder connectionHolder = (ConnectionHolder) AppContext.getAppContext()</span><br><span class="line">                .getObject(Constants.APP_REQUEST_THREAD_CONNECTION);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (connectionHolder == <span class="keyword">null</span>) &#123;</span><br><span class="line">            Connection conn = DB.getConn();</span><br><span class="line">            connectionHolder = <span class="keyword">new</span> ConnectionHolder();</span><br><span class="line">            connectionHolder.setConn(conn);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (StringUtil.matchStr(method.getName(), allowed) &amp;&amp; (tranAttributeMap.get(originKey).equals(<span class="string">"REQUIRED"</span>))) &#123;</span><br><span class="line">                connectionHolder.setOpenTran(<span class="keyword">true</span>);</span><br><span class="line">                DB.setAutoCommit(conn, <span class="keyword">false</span>);</span><br><span class="line">                isCommitOrRollBackTran = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            AppContext.getAppContext().addObject(Constants.APP_REQUEST_THREAD_CONNECTION, connectionHolder);</span><br><span class="line">            isCommitOrRollBackTran = <span class="keyword">true</span>;</span><br><span class="line">            needMyClose = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (StringUtil.matchStr(method.getName(), allowed) &amp;&amp; (tranAttributeMap.get(originKey).equals(<span class="string">"REQUIRED"</span>))) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!connectionHolder.isOpenTran()) &#123;</span><br><span class="line">                    connectionHolder.setOpenTran(<span class="keyword">true</span>);</span><br><span class="line">                    DB.setAutoCommit(connectionHolder.getConn(), <span class="keyword">false</span>);</span><br><span class="line">                    isCommitOrRollBackTran = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            result = method.invoke(target, args);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (isCommitOrRollBackTran) &#123;</span><br><span class="line">                DB.commit(connectionHolder.getConn());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isCommitOrRollBackTran) &#123;</span><br><span class="line">                DB.rollback(connectionHolder.getConn());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// After advice.</span></span><br><span class="line">            <span class="keyword">if</span> (needMyClose) &#123;</span><br><span class="line">                connectionHolder = (ConnectionHolder) AppContext.getAppContext()</span><br><span class="line">                        .getObject(Constants.APP_REQUEST_THREAD_CONNECTION);</span><br><span class="line">                DB.close(connectionHolder.getConn());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Stores key in map as an array.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> transactionConfig</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> String[]</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> String[] getTransactionAttribute(TransactionConfig transactionConfig) &#123;</span><br><span class="line">        Map&lt;String, String&gt; tranAttributeMap = transactionConfig.getTranAttributeMap();</span><br><span class="line">        Set&lt;String&gt; keySet = tranAttributeMap.keySet();</span><br><span class="line">        String[] methodPrefixs =<span class="keyword">new</span> String[keySet.size()];</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (String key : keySet) &#123;</span><br><span class="line">            <span class="keyword">int</span> index = key.indexOf(<span class="string">"*"</span>);</span><br><span class="line">            <span class="keyword">if</span> (index == -<span class="number">1</span>) &#123;</span><br><span class="line">                key = key.substring(<span class="number">0</span>, key.length() - <span class="number">1</span>);</span><br><span class="line">                methodPrefixs[i] = key;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                methodPrefixs[i] = key;</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> methodPrefixs;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="附：ApplicationContextFilter"><a href="#附：ApplicationContextFilter" class="headerlink" title="附：ApplicationContextFilter"></a>附：ApplicationContextFilter</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Application Context Filter, include &#123;<span class="doctag">@link</span> HttpServletRequest&#125; request,</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> HttpServletResponse&#125; response, &#123;<span class="doctag">@link</span> Connection&#125; JDBC Connection.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Mingshan</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppContextFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> TransactionConfig transactionConfig = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AppContextFilter</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(FilterConfig fConfig)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">        ServletContext servletContext = fConfig.getServletContext();</span><br><span class="line">        transactionConfig = (TransactionConfig) servletContext.getAttribute(<span class="string">"transactionConfig"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain chain)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        HttpServletRequest request = (HttpServletRequest) servletRequest;</span><br><span class="line">        HttpServletResponse response = (HttpServletResponse) servletResponse;</span><br><span class="line"></span><br><span class="line">        AppContext appContext = AppContext.getAppContext();</span><br><span class="line">        appContext.addObject(Constants.APP_CONTEXT_REQUEST, request);</span><br><span class="line">        appContext.addObject(Constants.APP_CONTEXT_RESPONSE, response);</span><br><span class="line">        appContext.setTransactionConfig(transactionConfig);</span><br><span class="line">        ConnectionHolder connectionHolder = (ConnectionHolder) AppContext.getAppContext()</span><br><span class="line">                .getObject(Constants.APP_REQUEST_THREAD_CONNECTION);</span><br><span class="line">        <span class="keyword">boolean</span> needMyClose = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(connectionHolder == <span class="keyword">null</span>) &#123;</span><br><span class="line">            connectionHolder = <span class="keyword">new</span> ConnectionHolder();</span><br><span class="line">            Connection conn = DB.getConn();</span><br><span class="line">            connectionHolder.setConn(conn);</span><br><span class="line">            AppContext.getAppContext().addObject(Constants.APP_REQUEST_THREAD_CONNECTION, connectionHolder);</span><br><span class="line">            needMyClose = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            chain.doFilter(request, response);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException ioException) &#123;</span><br><span class="line">            <span class="keyword">throw</span> ioException;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ServletException servletException) &#123;</span><br><span class="line">            <span class="keyword">throw</span> servletException;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException runntimeException) &#123;</span><br><span class="line">            <span class="keyword">throw</span> runntimeException;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (needMyClose) &#123;</span><br><span class="line">                connectionHolder = (ConnectionHolder) AppContext.getAppContext()</span><br><span class="line">                        .getObject(Constants.APP_REQUEST_THREAD_CONNECTION);</span><br><span class="line">                DB.close(connectionHolder.getConn());</span><br><span class="line">            &#125;</span><br><span class="line">            appContext.clear();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// NOOP</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>—————————————————————————OVER————————————————————————————</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>利用hibernate进行多表查询问题</title>
      <link href="/2017/08/10/%E5%88%A9%E7%94%A8hibernate%E8%BF%9B%E8%A1%8C%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2%E9%97%AE%E9%A2%98/"/>
      <url>/2017/08/10/%E5%88%A9%E7%94%A8hibernate%E8%BF%9B%E8%A1%8C%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在Hibernate框架中，一个实体类映射为一个数据库表，在进行多表查询时,如何将不同表中的数据整合起来，并且映射为一个实体类是利用Hibernate进行多表查询的关键，根据我的理解，先将代码整理一下：</p><blockquote><p>实体类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table</span>(name = <span class="string">"ps_trends"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Trends</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">2228382525594394975L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue</span>(strategy = GenerationType.IDENTITY)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column</span>(name = <span class="string">"item_title"</span>)</span><br><span class="line">    <span class="keyword">private</span> String itemTitle;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column</span>(name = <span class="string">"item_content"</span>)</span><br><span class="line">    <span class="keyword">private</span> String itemContent;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column</span>(name = <span class="string">"type_id"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>  typeId;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column</span>(name = <span class="string">"add_time"</span>)</span><br><span class="line">    <span class="keyword">private</span> String addTime;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column</span>(name = <span class="string">"view_count"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> viewCount;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column</span>(name = <span class="string">"is_image"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> isImage;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column</span>(name = <span class="string">"is_publish"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> isPublish;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//临时属性</span></span><br><span class="line">    <span class="meta">@Transient</span></span><br><span class="line">    <span class="keyword">private</span> String itemTypeFlag;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transient</span></span><br><span class="line">    <span class="keyword">private</span> String itemTypeName;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Trends</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Trends</span><span class="params">(<span class="keyword">int</span> id, String itemTitle, String itemContent, String addTime, <span class="keyword">int</span> viewCount,</span></span></span><br><span class="line"><span class="function"><span class="params">      String itemTypeName,String itemTypeFlag)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.itemTitle = itemTitle;</span><br><span class="line">        <span class="keyword">this</span>.itemContent = itemContent;</span><br><span class="line">        <span class="keyword">this</span>.addTime = addTime;</span><br><span class="line">        <span class="keyword">this</span>.viewCount = viewCount;</span><br><span class="line">        <span class="keyword">this</span>.itemTypeName = itemTypeName;</span><br><span class="line">        <span class="keyword">this</span>.itemTypeFlag = itemTypeFlag;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    setter ，getter方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote> <a id="more"></a><p>这里有两个属性注解为Transient，因为它们不是主表的映射字段。同时写一个有参构造方法，构造方法的参数列表即为要查询的映射字段。</p><blockquote><p>DaoImpl方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Trends <span class="title">findTrendsInfoById</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">    String hql=<span class="string">"select new com.primaryschool.home.entity.Trends(t.id,t.itemTitle,t.itemContent,t.addTime,t.viewCount,tt.itemTypeName,tt.itemTypeFlag)from Trends t,TrendsType tt  where tt.id=t.typeId and t.id=? and t.isPublish=1"</span>;</span><br><span class="line">    Query query=sessionFactory.getCurrentSession().createQuery(hql);</span><br><span class="line">    query.setInteger(<span class="number">0</span>, id);</span><br><span class="line">    <span class="keyword">return</span> (Trends) query.uniqueResult();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><p>在findTrendsInfoById(int id)方法中，hql语句有些特别，它是将两个表的需要字段传入到Trends实体类的构造方法中，这样就可以直接利用getter方法进行取值了。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hibernate </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Linux目录结构</title>
      <link href="/2017/08/03/Linux%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84%E8%AE%B0%E5%BD%95/"/>
      <url>/2017/08/03/Linux%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="Linux目录结构："><a href="#Linux目录结构：" class="headerlink" title="Linux目录结构："></a>Linux目录结构：</h3><p><img src="/images/linux目录.png" alt="image"></p><p><strong>/:</strong> 根目录，一般根目录下只存放目录，不要存放文件，/etc、/bin、/dev、/lib、/sbin应该和根目录放置在一个分区中</p><p><strong>/bin:/usr/bin</strong>: 可执行二进制文件的目录，如常用的命令ls、tar、mv、cat等。</p><p><strong>/boot</strong>: 放置linux系统启动时用到的一些文件。/boot/vmlinuz为linux的内核文件，以及/boot/gurb。建议单独分区，分区大小100M即可</p><p><strong>/dev</strong>：存放linux系统下的设备文件，访问该目录下某个文件，相当于访问某个设备，常用的是挂载光驱mount /dev/cdrom /mnt。</p><p><strong>/etc</strong>：系统配置文件存放的目录，不建议在此目录下存放可执行文件，重要的配置文件有/etc/inittab、/etc/fstab、/etc/init.d、/etc/X11、/etc/sysconfig、/etc/xinetd.d修改配置文件之前记得备份。<br>注：/etc/X11存放与x windows有关的设置。</p><p><strong>/home</strong>：系统默认的用户家目录，新增用户账号时，用户的家目录都存放在此目录下，~表示当前用户的家目录，~test表示用户test的家目录。建议单独分区，并设置较大的磁盘空间，方便用户存放数据</p><p><strong>/lib:/usr/lib:/usr/local/lib</strong>：系统使用的函数库的目录，程序在执行过程中，需要调用一些额外的参数时需要函数库的协助，比较重要的目录为/lib/modules。</p><a id="more"></a><p><strong>/lost+fount</strong>：系统异常产生错误时，会将一些遗失的片段放置于此目录下，通常这个目录会自动出现在装置目录下。如加载硬盘于/disk 中，此目录下就会自动产生目录/disk/lost+found</p><p><strong>/mnt:/media</strong>：光盘默认挂载点，通常光盘挂载于/mnt/cdrom下，也不一定，可以选择任意位置进行挂载。</p><p><strong>/opt</strong>：给主机额外安装软件所摆放的目录。如：FC4使用的Fedora 社群开发软件，如果想要自行安装新的KDE 桌面软件，可以将该软件安装在该目录下。以前的 Linux 系统中，习惯放置在 /usr/local 目录下</p><p><strong>/proc</strong>：此目录的数据都在内存中，如系统核心，外部设备，网络状态，由于数据都存放于内存中，所以不占用磁盘空间，比较重要的目录有/proc/cpuinfo、/proc/interrupts、/proc/dma、/proc/ioports、/proc/net/*等</p><p><strong>/root</strong>：系统管理员root的家目录，系统第一个启动的分区为/，所以最好将/root和/放置在一个分区下。</p><p><strong>/sbin:/usr/sbin:/usr/local/sbin</strong>：放置系统管理员使用的可执行命令，如fdisk、shutdown、mount等。与/bin不同的是，这几个目录是给系统管理员root使用的命令，一般用户只能”查看”而不能设置和使用。</p><p><strong>/tmp</strong>：一般用户或正在执行的程序临时存放文件的目录,任何人都可以访问,重要数据不可放置在此目录下</p><p><strong>/srv</strong>：服务启动之后需要访问的数据目录，如www服务需要访问的网页数据存放在/srv/www内</p><p><strong>/usr</strong>：应用程序存放目录，/usr/bin存放应用程序，/usr/share存放共享数据，/usr/lib存放不能直接运行的，却是许多程序运行所必需的一些函数库文件。/usr/local:存放软件升级包。/usr/share/doc:系统说明文件存放目录。/usr/share/man: 程序说明文件存放目录，使用 man<br>ls时会查询/usr/share/man/man1/ls.1.gz的内容建议单独分区，设置较大的磁盘空间</p><p><strong>/var</strong>：放置系统执行过程中经常变化的文件，如随时更改的日志文件/var/log，/var/log/message：所有的登录文件存放目录，/var/spool/mail：邮件存放的目录，/var/run:程序或服务启动后，其PID存放在该目录下。建议单独分区，设置较大的磁盘空间</p><p>转载自：<br><a href="https://www.cnblogs.com/CoderJYF/p/6092604.html" target="_blank" rel="noopener">https://www.cnblogs.com/CoderJYF/p/6092604.html</a></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Linux基本命令</title>
      <link href="/2017/08/01/Linux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"/>
      <url>/2017/08/01/Linux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="目录操作："><a href="#目录操作：" class="headerlink" title="目录操作："></a>目录操作：</h2><ul><li>创建目录：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir $HOME/testFolder</span><br></pre></td></tr></table></figure><ul><li>切换目录：</li></ul><p><strong>使用 cd 命令切换目录</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd $HOME/testFolder</span><br></pre></td></tr></table></figure><p><strong>使用 cd ../ 命令切换到上一级目录</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd ../</span><br></pre></td></tr></table></figure><ul><li>移动目录</li></ul><p><strong>使用 mv 命令移动目录</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv $HOME/testFolder /var/tmp</span><br></pre></td></tr></table></figure><ul><li>删除目录</li></ul><p><strong>使用 rm -rf 命令删除目录</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -rf /var/tmp/testFolder</span><br></pre></td></tr></table></figure><ul><li>查看目录下的文件</li></ul><p><strong>使用 ls 命令查看 /etc<br> 目录下所有文件和文件夹</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls /etc</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h2><ul><li>创建文件</li></ul><p><strong>使用 touch 命令创建文件</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch ~/testFile</span><br></pre></td></tr></table></figure><ul><li>复制文件</li></ul><p><strong>使用 cp 命令复制文件</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp ~/testFile ~/testNewFile</span><br></pre></td></tr></table></figure><ul><li>删除文件</li></ul><p><strong>使用 rm 命令删除文件, 输入 y 后回车确认删除</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm ~/testFile</span><br></pre></td></tr></table></figure><ul><li>查看文件内容</li></ul><p><strong>使用 cat 命令查看 .bash_history 文件内容</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat ~/.bash_history</span><br></pre></td></tr></table></figure><h2 id="过滤-管道与重定向"><a href="#过滤-管道与重定向" class="headerlink" title="过滤, 管道与重定向"></a>过滤, 管道与重定向</h2><ul><li>过滤</li></ul><p><strong>过滤出 /etc/passwd 文件中包含 root 的记录</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep &apos;root&apos; /etc/passwd</span><br></pre></td></tr></table></figure><p><strong>递归地过滤出 /var/log/ 目录中包含 linux 的记录</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -r &apos;linux&apos; /var/log/</span><br></pre></td></tr></table></figure><ul><li>管道</li></ul><p>简单来说, Linux 中管道的作用是将上一个命令的输出作为下一个命令的输入, 像 pipe 一样将各个命令串联起来执行, 管道的操作符是 |</p><p><strong>比如, 我们可以将 cat 和 grep 两个命令用管道组合在一起</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/passwd | grep &apos;root&apos;</span><br></pre></td></tr></table></figure><p>过滤出 /etc 目录中名字包含 ssh 的目录(不包括子目录)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls /etc | grep &apos;ssh&apos;</span><br></pre></td></tr></table></figure><ul><li>重定向</li></ul><p><strong>可以使用 &gt; 或 &lt; 将命令的输出重定向到一个文件中</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &apos;Hello World&apos; &gt; ~/test.txt</span><br></pre></td></tr></table></figure><h2 id="运维常用命令"><a href="#运维常用命令" class="headerlink" title="运维常用命令"></a>运维常用命令</h2><ul><li>ping 命令</li></ul><p><strong>对 cloud.tencent.com 发送 4 个 ping 包, 检查与其是否联通</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping -c 4 cloud.tencent.com</span><br></pre></td></tr></table></figure><ul><li>netstat 命令</li></ul><p>netstat 命令用于显示各种网络相关信息，如网络连接, 路由表, 接口状态等等</p><p><strong>列出所有处于监听状态的tcp端口</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -lt</span><br></pre></td></tr></table></figure><p><strong>查看所有的端口信息, 包括 PID 和进程名称</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -tulpn</span><br></pre></td></tr></table></figure><ul><li>ps 命令</li></ul><p><strong>过滤得到当前系统中的 ssh 进程信息</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -aux | grep &apos;ssh</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>java枚举探究</title>
      <link href="/2017/07/26/java%E6%9E%9A%E4%B8%BE%E6%8E%A2%E7%A9%B6/"/>
      <url>/2017/07/26/java%E6%9E%9A%E4%B8%BE%E6%8E%A2%E7%A9%B6/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在jdk1.5中引入枚举这个小功能，这个功能虽然用的不多，但是却给我们的开发带来很多便利，我们<br>今天来看看java的枚举是个什么样子。</p><h2 id="枚举的主要操作方法"><a href="#枚举的主要操作方法" class="headerlink" title="枚举的主要操作方法"></a>枚举的主要操作方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">Enum</span><span class="params">(String name,<span class="keyword">int</span> ordinal)</span>  <span class="comment">//接受枚举的名称和枚举的常量创建枚举对象  </span></span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> Object <span class="title">clone</span><span class="params">()</span><span class="keyword">throws</span> CloneNotSupportedException  <span class="comment">//克隆枚举对象  </span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(E o)</span> <span class="comment">//比较枚举与指定对象的顺序</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object other)</span>  <span class="comment">//比较两个枚举对象  </span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span>  <span class="comment">//返回枚举常量的哈希码  </span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">name</span><span class="params">()</span>  <span class="comment">//返回枚举类的名称  </span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">ordinal</span><span class="params">()</span>  <span class="comment">//返回枚举常量的序号  </span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Enum&lt;T&gt;&gt; T <span class="title">valueOf</span><span class="params">(Class&lt;T&gt; <span class="keyword">enum</span> Type,String name)</span>  <span class="comment">//返回带指定名称的指定枚举类型的枚举常量</span></span></span><br></pre></td></tr></table></figure><h2 id="先定义一个枚举，用enum关键字"><a href="#先定义一个枚举，用enum关键字" class="headerlink" title="先定义一个枚举，用enum关键字"></a>先定义一个枚举，用enum关键字</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义枚举</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mingshan</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> EnumTest &#123;</span><br><span class="line"> MON, TUE, WED, THU, FRI, SAT, SUN;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里将星期定义为枚举类型，但没有赋值，既然已经定义好了，那么就先测试一下吧。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 枚举测试</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mingshan</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历枚举</span></span><br><span class="line"><span class="keyword">for</span>(EnumTest e : EnumTest.values()) &#123;</span><br><span class="line">System.out.println(e.toString());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"我是分割线------"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//switch 操作</span></span><br><span class="line">EnumTest fri = EnumTest.FRI;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span>(fri)&#123;</span><br><span class="line"><span class="keyword">case</span> MON :</span><br><span class="line">System.out.println(<span class="string">"今天是星期一"</span>); <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> FRI :</span><br><span class="line">System.out.println(<span class="string">"今天是星期五"</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span> :</span><br><span class="line">    System.out.println(<span class="string">"-----"</span>); <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回</span></span><br><span class="line">System.out.println(fri.getDeclaringClass());</span><br><span class="line"></span><br><span class="line"><span class="comment">//利用compareTo进行比较</span></span><br><span class="line"><span class="keyword">switch</span> (fri.compareTo(EnumTest.SAT)) &#123;</span><br><span class="line"><span class="keyword">case</span> -<span class="number">1</span>:</span><br><span class="line">System.out.println(<span class="string">"之前"</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">System.out.println(<span class="string">"之后"</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以遍历枚举，用java的foreach进行遍历，调用枚举的values方法获取定义的枚举列表，但当<br>我们编写自定义enum时，却不包含values这个方法，这个方法是当我门编译文件时，编译器自动帮我<br>们加上的。枚举还可以进行switch操作，可以对获取的枚举进行判断。利用compareTo函数进行比较两个<br>枚举的顺序</p><a id="more"></a><h2 id="给-enum-对象加一下-value-的属性和-getValue-的方法"><a href="#给-enum-对象加一下-value-的属性和-getValue-的方法" class="headerlink" title="给 enum 对象加一下 value 的属性和 getValue() 的方法"></a>给 enum 对象加一下 value 的属性和 getValue() 的方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 赋初值</span></span><br><span class="line"><span class="comment"> * 给 enum 对象加一下 value 的属性和 getValue() 的方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mingshan</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> EnumTest2 &#123;</span><br><span class="line">    MON(<span class="number">1</span>), TUE(<span class="number">2</span>), WED(<span class="number">3</span>), THU(<span class="number">4</span>), FRI(<span class="number">5</span>), SAT(<span class="number">6</span>) &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isRest</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    SUN(<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isRest</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> value;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">EnumTest2</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.value = value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isRest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>获取属性值</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取属性值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">System.out.println(EnumTest2.FRI.getValue());</span><br></pre></td></tr></table></figure><blockquote><p>EnumSet的使用</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//EnumSet的使用</span></span><br><span class="line">EnumSet&lt;EnumTest2&gt; allOf = EnumSet.allOf(EnumTest2.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历枚举</span></span><br><span class="line"><span class="keyword">for</span> (EnumTest2 enumTest2 : allOf) &#123;</span><br><span class="line">System.out.println(enumTest2.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>EnumMap的使用</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">EnumMap&lt;EnumTest2, Object&gt; enumMap = <span class="keyword">new</span> EnumMap&lt;&gt;(EnumTest2.class);</span><br><span class="line"></span><br><span class="line">enumMap.put(EnumTest2.FRI, <span class="string">"星期五"</span>);</span><br><span class="line">enumMap.put(EnumTest2.SUN, <span class="string">"星期天"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历map</span></span><br><span class="line"><span class="keyword">for</span> (Entry&lt;EnumTest2, Object&gt; enumTest2 : enumMap.entrySet()) &#123;</span><br><span class="line">System.out.println(enumTest2.getKey()+<span class="string">"---"</span>+enumTest2.getValue());</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>java多态学习</title>
      <link href="/2017/07/25/java%E5%A4%9A%E6%80%81%E5%AD%A6%E4%B9%A0/"/>
      <url>/2017/07/25/java%E5%A4%9A%E6%80%81%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在java多态中，引用与对象可以是不同的类型，如:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A b=<span class="keyword">new</span> B();</span><br></pre></td></tr></table></figure><p>运用多态时，引用类型可以是实际对象类型的父类，即实际对象类型已经是一个比较具体的类，而引用类型则是一个比较抽象的类，任何extends过声明引用类型的对象都可以赋值给这个引用变量，这样就可以做出类似动态数组的东西，如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Animal[] a=<span class="keyword">new</span> Animal[<span class="number">2</span>];</span><br><span class="line">a[<span class="number">0</span>]=<span class="keyword">new</span> Dog();</span><br><span class="line">a[<span class="number">1</span>]=<span class="keyword">new</span> Cat();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.length;i++)&#123;</span><br><span class="line">    a[i].eat();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>a数组里面可以放任何Animal的子类对象，调用的时候可以把子类都当作Animal来操作，实际上调用的是子类的方法，是不是很好玩呢→_→</p><p>当然，多态的应用很广泛呢，参数和返回类型也可以多态，如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vet</span></span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">giveShot</span><span class="params">(Anmial a)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">      a.makeNoise();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pet</span></span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">()</span></span>&#123;</span><br><span class="line">      Vet v=<span class="keyword">new</span> Vet();</span><br><span class="line">      Dog dog=<span class="keyword">new</span> Dog();</span><br><span class="line">      Cat cat=<span class="keyword">new</span> Cat();</span><br><span class="line">      v.giveShot(dog);</span><br><span class="line">      v.giveShot(cat);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>giveShot会接受任何Animal的子类的对象实例，根据传入的参数不同，会调用不同对象的方法。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>基于java中的泛型与反射构建通用DAO层</title>
      <link href="/2017/07/23/%E5%9F%BA%E4%BA%8Ejava%E4%B8%AD%E7%9A%84%E6%B3%9B%E5%9E%8B%E4%B8%8E%E5%8F%8D%E5%B0%84%E6%9E%84%E5%BB%BA%E9%80%9A%E7%94%A8DAO%E5%B1%82/"/>
      <url>/2017/07/23/%E5%9F%BA%E4%BA%8Ejava%E4%B8%AD%E7%9A%84%E6%B3%9B%E5%9E%8B%E4%B8%8E%E5%8F%8D%E5%B0%84%E6%9E%84%E5%BB%BA%E9%80%9A%E7%94%A8DAO%E5%B1%82/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在利用hibernate写通用DAO层时需要获取泛型的类型，比如我在写hql的update语句时需要获取泛型的实体类，由于泛型有擦除机制，所以与需要在运行过程中获取泛型的类型产生了矛盾。此时需要利用反射机制来实现此功能，下面来看一个小例子。</p><blockquote><p>首先建一个实体类Dog<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">8108340856807454651L</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> age;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><a id="more"></a><blockquote><p> 然后写一个基类，在此类中可以获取泛型的类型<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.han.one;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.ParameterizedType;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过反射获取泛型实例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span>  <span class="class"><span class="keyword">class</span> <span class="title">Genericity</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"rawtypes"</span>)</span><br><span class="line">    <span class="keyword">protected</span> Class clazz;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 把泛型的参数提取出来的过程放入到构造函数中写，因为</span></span><br><span class="line"><span class="comment">    * 当子类创建对象的时候，直接调用父类的构造函数</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Genericity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 通过反射机制获取子类传递过来的实体类的类型信息</span></span><br><span class="line">        ParameterizedType type = (ParameterizedType) <span class="keyword">this</span>.getClass().getGenericSuperclass();</span><br><span class="line">        <span class="comment">//得到t的实际类型</span></span><br><span class="line">        clazz = (Class&lt;T&gt;) type.getActualTypeArguments()[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取指定实例的所有属性名及对应值的Map实例</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> entity 实例</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 字段名及对应值的Map实例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     <span class="function"><span class="keyword">protected</span> Map&lt;String, Object&gt; <span class="title">getFieldValueMap</span><span class="params">(T entity)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// key是属性名，value是对应值</span></span><br><span class="line">        Map&lt;String, Object&gt; fieldValueMap = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取当前加载的实体类中所有属性</span></span><br><span class="line">        Field[] fields = <span class="keyword">this</span>.clazz.getDeclaredFields();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; fields.length; i++) &#123;</span><br><span class="line">            Field f = fields[i];</span><br><span class="line">            <span class="comment">// 属性名</span></span><br><span class="line">            String key = f.getName();</span><br><span class="line">            <span class="comment">//属性值</span></span><br><span class="line">            Object value = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">// 忽略序列化版本ID号</span></span><br><span class="line">            <span class="keyword">if</span> (! <span class="string">"serialVersionUID"</span>.equals(key)) &#123;</span><br><span class="line">            <span class="comment">// 取消Java语言访问检查</span></span><br><span class="line">            f.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    value =f.get(entity);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IllegalArgumentException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                fieldValueMap.put(key, value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fieldValueMap;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><p>在此类的构造方法中利用反射获取子类传递过来的实体类的类型信息，getFieldValueMap方法用于获取该实体类的属性信息</p><blockquote><p>最后写一个测试类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.han.one;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试：通过反射获取运行过程中泛型实例</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericityTest</span> <span class="keyword">extends</span> <span class="title">Genericity</span>&lt;<span class="title">Dog</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        GenericityTest gt = <span class="keyword">new</span> GenericityTest();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//赋值</span></span><br><span class="line">        Dog  dd = <span class="keyword">new</span> Dog();</span><br><span class="line">        dd.setAge(<span class="number">1</span>);</span><br><span class="line">        dd.setName(<span class="string">"旺财"</span>);</span><br><span class="line"></span><br><span class="line">        Map&lt;String,Object&gt; map = gt.getFieldValueMap(dd);</span><br><span class="line">        <span class="comment">//遍历</span></span><br><span class="line">        Set&lt;Map.Entry&lt;String, Object&gt;&gt; entrySet = map.entrySet();</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, Object&gt; entry : entrySet) &#123;</span><br><span class="line">            String key = entry.getKey();</span><br><span class="line">            Object value = entry.getValue();</span><br><span class="line">            System.out.println(key + <span class="string">"---"</span> + value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><p>在这个测试类中，此类继承基类，并向其传递实体类，这样在父类中就可以通过反射获取泛型的类型了。</p><p>以此为基础，就可以构建通用的DAO了，代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseDaoImpl</span>&lt;<span class="title">T</span>&gt;  <span class="keyword">implements</span> <span class="title">IBaseDao</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> SessionFactory  sessionFactory;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"rawtypes"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Class clazz;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BaseDaoImpl</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 通过反射机制获取子类传递过来的实体类的类型信息</span></span><br><span class="line">        ParameterizedType type = (ParameterizedType) <span class="keyword">this</span>.getClass().getGenericSuperclass();</span><br><span class="line">        clazz = (Class&lt;T&gt;) type.getActualTypeArguments()[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">update</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">        StringBuffer stringBuffer = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        stringBuffer.append(<span class="string">"update "</span> + <span class="keyword">this</span>.clazz.getSimpleName());</span><br><span class="line">        stringBuffer.append(<span class="string">" u set u.itemTitle=:itemTitle ,u.itemContent=:itemContent,u.addTime=:addTime,u.isImage=:isImage,u.isPublish=:isPublish,u.author=:author  where u.id=:id"</span>);</span><br><span class="line">        System.out.println(stringBuffer.toString());</span><br><span class="line">        Query query  = sessionFactory.getCurrentSession().createQuery(stringBuffer.toString());</span><br><span class="line">        query.setProperties(t);</span><br><span class="line">        <span class="keyword">return</span> (query.executeUpdate()&gt;<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里只是在update方法中利用反射获取实体类，通过拼装hql语句来达到重用目的，当然参数也可以动态获取，这里只是个小例子。</p><blockquote><p>总结</p></blockquote><p>java中泛型与反射的应用很广泛，想要完全掌握不是那么容易，多写多练是比较好的方式^_^</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>关于首页feed流如何展示和数据库如何设计问题</title>
      <link href="/2017/07/15/%E5%85%B3%E4%BA%8E%E9%A6%96%E9%A1%B5feed%E6%B5%81%E5%A6%82%E4%BD%95%E5%B1%95%E7%A4%BA%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E9%97%AE%E9%A2%98/"/>
      <url>/2017/07/15/%E5%85%B3%E4%BA%8E%E9%A6%96%E9%A1%B5feed%E6%B5%81%E5%A6%82%E4%BD%95%E5%B1%95%E7%A4%BA%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>最近在做一个简单的问答网站，首页的内容需要根据用户关注的话题和关注的问题等来展示最新的动态信息，刚开始的时候我想数据库表的设计是关键。</p><p>这里涉及到两个概念 <strong>推模式（push）</strong>和<strong>拉模式（pull）</strong>，这里有两篇大神分享的知识<a href="http://blog.sina.com.cn/s/blog_53b95aec0100ujim.html" target="_blank" rel="noopener"> 新浪微博架构和FEED架构分析–人人架构<em>paper0023</em>新浪博客</a>和<a href="http://www.cnblogs.com/sunli/archive/2010/08/24/twitter_feeds_push_pull.html" target="_blank" rel="noopener">微博feed系统的推(push)模式和拉(pull)模式和时间分区拉模式架构探讨</a>，讲解的比较清楚</p><blockquote><p>简单来说，什么是推，什么是拉呢？</p></blockquote><ol><li><strong>推模式</strong>是一个用户发表了一条动态，那么后台就遍历关注该用户的所有用户，向他们的feed中推送一条动态</li><li><strong>拉模式</strong>与推模式相反，当用户刷新首页时，后台会遍历该用户关注的用户的动态信息，并将动态信息压入到该用户的feed中</li></ol><p>简单介绍完推拉模式后，下面就要考虑数据库表该怎么设计了，我采用的是最简单的推模式，毕竟新手嘛，先掌握实现流程。</p><hr><p>首先设计feed表，这里我设计一个feed表来存储推送的信息，该表主要有以下几个字段</p><ul><li>id  自增id</li><li>suid  推送者uid</li><li>ruid  接收者uid</li><li>item_id  推送的信息id</li><li>type   推送信息类型</li><li>add_time  推送时间</li></ul><p>这是我感觉很简单的feed表，毕竟我那个问答站推送类型不是太多，当然还需要为这个表设计索引哦。<br>设计完数据库表后，下面该考虑后台推送逻辑和代码如何实现以及前台首页如何渲染feed流信息。</p><hr><p>后台我用的是PHP的ThinkPHP框架，新手表示该框架很好用，用该框架可以快速实现的我的想法，我感觉这一点还是很好的。首先在推送类型的选择中我选择了以下几种推送类型</p><ul><li>当一个话题下有新话题发起时，推送给关注该话题的用户</li><li>当一个问题有回答时，推送给关注该问题的用户</li><li>当一个话题的问题有新回答时，推送给关注该话题的用户</li></ul><p>上面推送过程中会产生大量的重复信息，所以需要在推送时对推送信息进行过滤，以避免重复的推送信息出现。代码就是当上面的推送类型产生时，将信息写入到feed表中，这里并没有对推送用户进行筛选（对推送用户的筛选可以降低数据库的压力）。</p><p>前台渲染的话需要对信息进行排序整合，并对每一条动态信息进行标记，以便在模板渲染时匹配对应的模板。<br>我写的简单部分整合代码，需要对信息进行遍历整合（这里没写）</p><pre><code> //如果推送类型 为a  则代表推送信息类型为  用户关注的话题有关的问题或关注的问题产生的回答 $aid=$val[&apos;item_id&apos;]; /**根据回答id获取获取与此回答有关的信息**/ //获取推送人的uid $suid=$val[&apos;suid&apos;]; //获取当前用户对回答的赞同状态 $upvote_status=$this-&gt;getUpvoteStatusByAid($aid, $uid);//获取feed流 回答信息 $a_info_all=$this-&gt;getFeedAnswerInfo($aid); $question_id=$a_info_all[0][&apos;question_id&apos;]; //根据问题id获取与此问题相关的话题信息 $tinfo_a=D(&apos;Topic&apos;)-&gt;getFeedTopicByQuestion($question_id); //将话题信息追加到回答信息数组中 $a_info_all[0][&apos;topic&apos;]= $tinfo_a; //将当前用户对回答的赞同状态最佳到信息数组中 $a_info_all[0][&apos;upvote_status&apos;]=$upvote_status; //将整理后的信息添加到feed数组中，并做一个标记 a,以便在模板中判断解析 $arr_fd[&apos;answer&apos;]=$a_info_all; $arr_fd[&apos;feed_flag&apos;]=&apos;a&apos;; $feed_return_arr[]=  $arr_fd;</code></pre><p>这里 $feed_return_arr[]是一个三维数组，在模板渲染的时候要注意一下。<br><a id="more"></a><br>上面是我对feed流简单的思考，如果是真实网络环境下这种简单的实现有许多大问题，比如feed表数据量过大，是否设定一个时间阀对表中超过该时间阀的推送信息进行删除以减少feed表的记录量等等。所以这种方式并不适合真实的网络环境，需要将推拉模式结合进行使用。</p>]]></content>
      
      
      <categories>
          
          <category> php </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>利用uploadify插件上传文件时java后台获取不到当前session问题</title>
      <link href="/2017/07/10/%E5%88%A9%E7%94%A8uploadify%E6%8F%92%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%E6%97%B6java%E5%90%8E%E5%8F%B0%E8%8E%B7%E5%8F%96%E4%B8%8D%E5%88%B0%E5%BD%93%E5%89%8Dsession%E9%97%AE%E9%A2%98/"/>
      <url>/2017/07/10/%E5%88%A9%E7%94%A8uploadify%E6%8F%92%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%E6%97%B6java%E5%90%8E%E5%8F%B0%E8%8E%B7%E5%8F%96%E4%B8%8D%E5%88%B0%E5%BD%93%E5%89%8Dsession%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>我在利用uploadify插件上传文件时发现java后台获取不到当前用户的session值，即当前的用户的session保存的信息失效，导致拦截器将上传请求拦截，这里的拦截器主要对登录的信息进行拦截验证，正因为此原因，导致上传文件失败，后来在利用firebug查找请求的时候，发现uploadify插件会自动生成一个新的session，导致原来的session失效，解决方法是将jsessionid通过url传到后台，这样后台就能识别当前session，问题也就解决了。代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">"#uploadify"</span>).uploadify(&#123;</span><br><span class="line">debug: <span class="literal">false</span>,</span><br><span class="line">swf :  CTPPATH+<span class="string">'/admin/static/uploadify/js/uploadify.swf'</span>,<span class="comment">//swf文件路径</span></span><br><span class="line">method: <span class="string">'get'</span>,<span class="comment">// 提交方式</span></span><br><span class="line">uploader:  CTPPATH+<span class="string">'/processUpload.ado;jsessionid=$&#123;pageContext.session.id&#125;'</span>, <span class="comment">// 服务器端处理该上传请求的程序(servlet, struts2-Action)   )&#125;;</span></span><br></pre></td></tr></table></figure><p>  代码中有许多属性这里没有贴出来，这里主要看uploader属性，uploader属性为CTPPATH+’/processUpload.ado;jsessionid=${pageContext.session.id}’，即在请求url中附上<br>;jsessionid=${pageContext.session.id}，这样上传就没问题了。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>网站消息推送之long polling（长轮询）初探</title>
      <link href="/2017/07/09/%E7%BD%91%E7%AB%99%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81%E4%B9%8Blong%20polling%EF%BC%88%E9%95%BF%E8%BD%AE%E8%AF%A2%EF%BC%89%E5%88%9D%E6%8E%A2/"/>
      <url>/2017/07/09/%E7%BD%91%E7%AB%99%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81%E4%B9%8Blong%20polling%EF%BC%88%E9%95%BF%E8%BD%AE%E8%AF%A2%EF%BC%89%E5%88%9D%E6%8E%A2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>网站的消息推送功能应用很广泛，比如论坛，问答网站等等都需要推送消息，那么采用什么样的推送方式更加便捷，更加节省服务器资源呢，这个需要根据网站的流量和规模来决定，因为long polling是我最先接触到的，我就来谈谈它吧。</p><p>长轮询初看像是轮流查询的意思，其实不是，它是客户端通过ajax发出请求，然后客户端挂起，等待服务器端响应，服务器端会检测有无新消息，如果有消息，服务器端会将新消息推送给客户端，结束本次请求，如果在有效请求期内没有新消息出现，那么会一直检测有无新消息出现。连接会保持一段时间周期直到数据或状态改变或者时间过期，通过这种机制来减少无效的客户端和服务器间的交互。</p><p>虽然长轮循比传统的轮询性能会有些提高，但在服务器端数据变化非常频繁的情况下，两者的性能并不能差多少，因为都是客户端先请求，服务器再响应，只是两者服务器端响应的机制不同。<br>下面来说说代码，服务器端我用的是php，客户端用的是jQuery</p><p>服务器端代码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@desc</span> ajax长轮询 来获取通知消息信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 通知信息数量&gt;o</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">longPolling</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!$_GET[<span class="string">'timed'</span>]) <span class="keyword">exit</span>();</span><br><span class="line">    date_default_timezone_set(<span class="string">"PRC"</span>);</span><br><span class="line">    session_write_close(); <span class="comment">//防止session访问互斥问题</span></span><br><span class="line">    set_time_limit(<span class="number">0</span>);<span class="comment">//无限请求超时时间</span></span><br><span class="line">    $timed = $_GET[<span class="string">'timed'</span>];</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        sleep(<span class="number">3</span>); <span class="comment">// 休眠3秒</span></span><br><span class="line">        <span class="comment">//判断有无新通知出现</span></span><br><span class="line">         $no_count=D(<span class="string">'Notifications'</span>)-&gt;getNotificationsCount(<span class="keyword">$this</span>-&gt;uid);</span><br><span class="line">         <span class="keyword">if</span> ($no_count&gt;<span class="number">0</span>) &#123;</span><br><span class="line">            $responseTime = time();</span><br><span class="line">            <span class="comment">// 返回数据信息，请求时间、返回数据时间、耗时</span></span><br><span class="line">            $content=<span class="keyword">array</span>(</span><br><span class="line">                <span class="string">'result'</span>         =&gt;$no_count,</span><br><span class="line">                <span class="string">'reponse_time'</span>   =&gt;$responseTime,</span><br><span class="line">                <span class="string">'request_time'</span>   =&gt;$timed,</span><br><span class="line">                <span class="string">'use_time'</span>       =&gt;($responseTime - $timed)</span><br><span class="line">            );</span><br><span class="line">            <span class="keyword">echo</span> <span class="keyword">$this</span>-&gt;ajaxReturn($content);</span><br><span class="line">            <span class="keyword">exit</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 模拟没有数据变化，将休眠 hold住连接</span></span><br><span class="line">            sleep(<span class="number">13</span>);</span><br><span class="line">            <span class="keyword">exit</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>从服务器段代码可以看出，里面有个while(true){}死循环，只有有新信息或者连接失效时会退出循环。</p><p>客户端代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 消息的处理 递归调用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> (<span class="function"><span class="keyword">function</span> <span class="title">longPolling</span>(<span class="params"></span>) </span>&#123;  </span><br><span class="line">         $.ajax(&#123;  </span><br><span class="line">             url: MODULE+<span class="string">"/Notifications/longPoll"</span>,  </span><br><span class="line">             data: &#123;<span class="string">"timed"</span>: <span class="built_in">Date</span>.parse(<span class="keyword">new</span> <span class="built_in">Date</span>())/<span class="number">1000</span>&#125;,  </span><br><span class="line">             dataType: <span class="string">"json"</span>,  </span><br><span class="line">             timeout: <span class="number">70000</span>,<span class="comment">//单位毫秒</span></span><br><span class="line">             error: <span class="function"><span class="keyword">function</span> (<span class="params">XMLHttpRequest, textStatus, errorThrown</span>) </span>&#123;  </span><br><span class="line"></span><br><span class="line">             <span class="keyword">if</span> (textStatus == <span class="string">"timeout"</span>) &#123; <span class="comment">// 请求超时  </span></span><br><span class="line">                     longPolling(); <span class="comment">// 递归调用  </span></span><br><span class="line">                 &#125; <span class="keyword">else</span> &#123; <span class="comment">// 其他错误，如网络错误等  </span></span><br><span class="line">                     longPolling();  </span><br><span class="line">                 &#125;  </span><br><span class="line">             &#125;,  </span><br><span class="line">             success: <span class="function"><span class="keyword">function</span> (<span class="params">data, textStatus</span>) </span>&#123;  </span><br><span class="line">                 <span class="comment">//此时已有消息过来了，将消息数量显示</span></span><br><span class="line">                 $(<span class="string">'.nav-counter'</span>).text(data.result);</span><br><span class="line">                 <span class="keyword">if</span> (textStatus == <span class="string">"success"</span>) &#123;</span><br><span class="line">                         <span class="comment">// 请求成功，继续请求</span></span><br><span class="line">                    longPolling();</span><br><span class="line">                 &#125;  </span><br><span class="line">             &#125;  </span><br><span class="line">         &#125;);  </span><br><span class="line"></span><br><span class="line">     &#125;)();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>客户端代码调用ajax进行处理，逻辑已经很清楚了。</p><p>以上就是我对long polling的理解，虽然长轮询较轮询有了不错的改进，但还是会消耗很多的服务器资源，并不是十分理想的网站消息推送方案。</p>]]></content>
      
      
      <categories>
          
          <category> php </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>php json_encode函数使用遇到的问题</title>
      <link href="/2017/07/01/php%20%20json_encode%E5%87%BD%E6%95%B0%E4%BD%BF%E7%94%A8%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/"/>
      <url>/2017/07/01/php%20%20json_encode%E5%87%BD%E6%95%B0%E4%BD%BF%E7%94%A8%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在php中有一个函数可以将数组转化为json数据存储格式，这个函数就是json_encode<br>但在使用这个函数时转化的格式不一致，比如：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//关联二位数组</span></span><br><span class="line">$a2=<span class="keyword">array</span>(    </span><br><span class="line">  <span class="string">'1'</span>=&gt;<span class="keyword">array</span>(<span class="string">'name'</span>=&gt;<span class="string">'john'</span>,<span class="string">'age'</span>=&gt;<span class="string">'32'</span>),</span><br><span class="line">  <span class="string">'2'</span>=&gt;<span class="keyword">array</span>(<span class="string">'name'</span>=&gt;<span class="string">'tom'</span>,<span class="string">'age'</span>=&gt;<span class="string">'22'</span>)</span><br><span class="line">);</span><br><span class="line">$json2=json_encode($a2);</span><br><span class="line"><span class="keyword">echo</span> $json2.<span class="string">"&lt;br&gt;"</span>; <span class="comment">//&#123;"1":&#123;"name":"john","age":"32"&#125;,"2":&#123;"name":"tom","age":"22"&#125;&#125;</span></span><br><span class="line"><span class="comment">//索引二维数组</span></span><br><span class="line">$a3=<span class="keyword">array</span>(</span><br><span class="line">   <span class="keyword">array</span>(<span class="string">'name'</span>=&gt;<span class="string">'zz'</span>,<span class="string">'age'</span>=&gt;<span class="string">'31'</span>),</span><br><span class="line">   <span class="keyword">array</span>(<span class="string">'name'</span>=&gt;<span class="string">'we'</span>,<span class="string">'AGE'</span>=&gt;<span class="string">'12'</span>)</span><br><span class="line">  );</span><br><span class="line"> $json3=json_encode($a3);</span><br><span class="line"> <span class="keyword">echo</span> $json3.<span class="string">"&lt;br&gt;"</span>;<span class="comment">//[&#123;"name":"zz","age":"31"&#125;,&#123;"name":"we","AGE":"12"&#125;]</span></span><br></pre></td></tr></table></figure></p><p>关联二维数组和索引二维数组转化为json数据格式不同，这时在前台用js解析json的时候就有差别</p><ul><li>对于关联数组生成的json数据格式 ，在前台直接用js的eval()将其转化为json对象，然后根据{key:value}取值</li><li>对于索引数组生成的json数据格式，用js的eval()转为json对象后，由于[]代表数组格式，所以遇到[]还是按照数组取值，遇到{key:value}这种形式的按照对象取值就行了</li></ul><p>当数组维数多的时候需要根据转换后的json数据格式用js进行相应的解析，避免出错。</p>]]></content>
      
      
      <categories>
          
          <category> php </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>javaweb下载文件时IE浏览器下报错问题</title>
      <link href="/2017/06/15/javaweb%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B6%E6%97%B6IE%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%8B%E6%8A%A5%E9%94%99%E9%97%AE%E9%A2%98/"/>
      <url>/2017/06/15/javaweb%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B6%E6%97%B6IE%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%8B%E6%8A%A5%E9%94%99%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>最近做的网站的一个下载功能出现了问题，在firefox浏览器以及360浏览器下下载均正常，也能将中文正常转换，但在IE浏览器下却出现了问题，当点击下载链接的时候，后台直接报错：<br><img src="http://www.mingzhiwen.cn/usr/uploads/2017/03/1999726111.png" alt="2017-03-17_113722.png"><br>后台我怎么兼容也不能解决问题，我下载的部分java代码：</p><p><img src="http://www.mingzhiwen.cn/usr/uploads/2017/03/95431087.png" alt="QQ图片20170317113901.png"></p><p>进过我仔细查找，发现我前台通过get方式提交的文件名包含一下字符，导致浏览器解析url不一致，所以需要将url通过javascript进行转码，即用encodeURIComponent函数进行编码，代码如下</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"javascript:location.href='$&#123;pageContext.request.contextPath&#125;/download.do?realname='+encodeURIComponent('$&#123;file_list.real_name&#125;')+'&amp;filename='+encodeURIComponent('$&#123;file_list.file_name&#125;');"</span> <span class="attr">class</span>=<span class="string">"file-name"</span>&gt;</span>$&#123;file_list.file_name&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>通过将文件名编码之后就能解决问题了</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>javaee 配置Tomcat数据源问题</title>
      <link href="/2017/06/08/javaee%20%E9%85%8D%E7%BD%AETomcat%E6%95%B0%E6%8D%AE%E6%BA%90%E9%97%AE%E9%A2%98/"/>
      <url>/2017/06/08/javaee%20%E9%85%8D%E7%BD%AETomcat%E6%95%B0%E6%8D%AE%E6%BA%90%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>最近用javaee写网站配置数据源时遇到了这个错误:</p><blockquote><p>java.lang.ClassCastException: org.apache.tomcat.dbcp.dbcp.PoolingDataSource$PoolGuardConnectionWrapper cannot be cast to com.mysql.jdbc.Connection</p></blockquote><p>经过我查看代码发现有些类中包导错了，涉及到数据库的包应该导入java.sql.*这个相关的，而我用ide自动导入为jdbc那个了，发生了类型不匹配问题，改掉就不会报这个错了。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>markdown-01</title>
      <link href="/2017/06/07/markdown-01/"/>
      <url>/2017/06/07/markdown-01/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><em>试试一下markdowm</em></p><h2 id="这是一个标题"><a href="#这是一个标题" class="headerlink" title="这是一个标题"></a>这是一个标题</h2><ol><li>这是第一行列表项</li><li>这是第二行列表项</li></ol><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><p>Markdown 支持有序列表和无序列表。</p><p>无序列表使用星号、加号或是减号作为列表标记：</p><pre>*   Red*   Green*   Blue</pre>等同于：<pre>+   Red+   Green+   Blue</pre>也等同于：<pre>-   Red-   Green-   Blue</pre>有序列表则使用数字接着一个英文句点：<pre>1.  Bird2.  McHale3.  Parish</pre><h2 id="代码区块"><a href="#代码区块" class="headerlink" title="代码区块"></a>代码区块</h2><p>markdown使用<pre></pre><code></code> 来将代码包裹起来</p><h2 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h2><hr><hr><hr><hr><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(&quot;helllo world&quot;);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[This link](http://example.net/) has no title attribute.</span><br></pre></td></tr></table></figure><p><a href="http://example.net/" target="_blank" rel="noopener">This link</a> has no title attribute.</p><h2 id="强调"><a href="#强调" class="headerlink" title="强调"></a>强调</h2><p>Markdown 使用星号（<em>）和底线（_）作为标记强调字词的符号，被 </em> 或 _ 包围的字词会被转成用 <em> 标签包围，用两个 * 或 _ 包起来的话，则会被转成 <strong>，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">*single asterisks*</span><br><span class="line"></span><br><span class="line">_single underscores_</span><br><span class="line"></span><br><span class="line">**double asterisks**</span><br><span class="line"></span><br><span class="line">__double underscores__</span><br></pre></td></tr></table></figure></strong></em></p><p>会转成：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;em&gt;single asterisks&lt;/em&gt;</span><br><span class="line"></span><br><span class="line">&lt;em&gt;single underscores&lt;/em&gt;</span><br><span class="line"></span><br><span class="line">&lt;strong&gt;double asterisks&lt;/strong&gt;</span><br><span class="line"></span><br><span class="line">&lt;strong&gt;double underscores&lt;/strong&gt;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> markdown </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>javaee 配置数据源后数据库连接未及时关闭出现的问题</title>
      <link href="/2017/06/06/javaee%20%20%E9%85%8D%E7%BD%AE%E6%95%B0%E6%8D%AE%E6%BA%90%E5%90%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%9C%AA%E5%8F%8A%E6%97%B6%E5%85%B3%E9%97%AD%E5%87%BA%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98/"/>
      <url>/2017/06/06/javaee%20%20%E9%85%8D%E7%BD%AE%E6%95%B0%E6%8D%AE%E6%BA%90%E5%90%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%9C%AA%E5%8F%8A%E6%97%B6%E5%85%B3%E9%97%AD%E5%87%BA%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>我在配置要数据源后没有仔细检查我的代码，有些数据库连接没有及时关闭，报以下异常:</p><blockquote><p>org.apache.tomcat.dbcp.dbcp.SQLNestedException: Cannot get a connection, pool error Timeout waiting for idle objec</p></blockquote><p>这个异常产生的原因是在使用完数据库连接后没有及时关闭，导致数据库连接池的连接没有可供使用的连接，进而报异常。<br>解决的方法是检查代码，将数据库连接及时关闭，并且在context.xml文件中加上</p><blockquote><p>removeAbandoned=”true” removeAbandonedTimeout=”60”<br>logAbandoned=”true”</p></blockquote><p>这样就解决问题了。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hello World</title>
      <link href="/2017/05/08/hello-world/"/>
      <url>/2017/05/08/hello-world/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
  
  
</search>
